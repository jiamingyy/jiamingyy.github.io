{"posts":[{"title":"AXI总线学习","text":"手撕 AXI 总线 AXI 总线AXI（Advanced eXtensible Interface）是一种总线协议，该协议是ARM公司提出的AMBA（Advanced Microcontroller Bus Architecture）3.0协议中最重要的部分，是一种面向高性能、高带宽、低延迟的片内总线。 AMBA 总线包括三个部分 APB AHB AXI: 向后兼容 AHB 和 APB AXI 的特点： 突发传输，可以一直传输，效率高 时序顺序，参考 IHI022E 文档 AXI 总线包含 5个通道，五个通道可以使读写数据过程分离。 写地址通道，信号前缀（aw_） 写数据通道，信号前缀（w_） 写响应通道，信号前缀（b_） 读地址通道，信号前缀（ar_） 读数据通道，信号前缀（r_） 前三个通道完成写数据的过程，后两个通道完成读数据的过程。 AXI 的时序，参考 XILINX 的代码，可以 使用 VIVADO自动生成的IP 进行仿真后查看时序 波形时序： VALID 和 READY 同时为高代表数据有效，其中VALID来自主机，READY 来自从机 先写地址，紧接着写数据，最后一个数据跟随LAST 先读地址，紧接着读数据，最后一个数据跟随LAST信号 写完数据，有一个响应信号。 ==LAST信号仅仅存在于数据读写数据通道中，在读写地址通道中是不包含的== AXI 实现步骤突发传输的数据长度为 1 - 256 （2的n 次方） 写步骤 写首地址 （写地址通道） 写完首地址，突发传输数据（写数据通道） 控制LAST 信号（写数据通道） 等待响应信号 （写响应通道） 读步骤 写首地址 等待从机传输的数据，当VALID和READY都为高时读取数据 接受LAST信号 实现的功能： 向从机的 0 地址写 1 - 10; 读从机的 0 地址","link":"/2023/03/22/AXI%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0/"},{"title":"Access Github Without Password","text":"为了更方便使用 Github，需要配置Github 的免密访问。 前言两种场景下需要用到免密访问 将 仓库push 到Github 使用 git@ 开头的地址Clone 仓库到本地 配置 Git 个人信息1234git config --global user.name &quot;用户名&quot; # 最好和GitHub的用户名保持一致git config --global user.email &quot;邮箱&quot; # 最好和GitHub的邮箱保持一致git config --list # 查看配置是狗成功 生成RSA执行下面的命令 1$ ssh-keygen -t rsa -C &quot;github注册邮箱&quot; 执行之后按两次回车，会在~/.ssh/ 目录下生成一个 id_rsa和 id_rsa.pub 文件，分别对应私钥和公钥文件。 设置Github访问公钥依次进入 Accounts -&gt; Settings -&gt; SSH and GPG keys。点击New SSH key 将 id_rsa.pub文件的内容复制带Key里面，title 可以随便写。 修改SSH 访问端口如果出现 remote host close connection错误。在.ssh文件夹下的config文件新增或者添加以下内容： 1234Host github.com HostName ssh.github.com User git Port 443 可以使用下面的命令测试是否可以正确访问 ： 1ssh -T git@github.com 出现以下提示则说明可以成功访问了。 1Hi ***! You've successfully authenticated, but GitHub does not provide shell access. 注意事项 不要修改 id_rsa和 id_rsa.pub文件的默认存放路径，git 会在每次上传的时候从~/.ssh文件夹中自动读取私钥并加密，这样就不用再输入密码了。","link":"/2022/03/11/Access-Github-Without-Password/"},{"title":"C语言函数指针","text":"C语言函数指针语法 12345678// 待用函数指针形参的函数声明UG_S16 UG_Init(UG_GUI* g, void (*p)(UG_S16, UG_S16, UG_COLOR), UG_S16 x, UG_S16 y){ // 强制类型转换 p_temp = (void (*)(UG_S16, UG_S16, UG_COLOR)) p; // 可以在内部直接调用 p(x, y, z); } 12345678// 函数指针性变量声明方式void (*global_key_callback)(uint8);void init_key(void (*key_callback)(uint8)){ // 函数指针赋值 global_key_callback = key_callback;}","link":"/2022/10/25/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"},{"title":"FPGA时序约束","text":"（实习准备）学习 FPGA 中如何进行时序约束。 问题建立为什么需要时序约束？ 满足电路的建立时间和保持时间，但是我们设计的RTL代码时不包含时序信息的。 如何分析电路的时序？ 时序电路：建立时间、保持时间 组合逻辑：恢复时间、撤销时间 以下面的电路为例： 访问的时序图如下： 对于同步时钟连接到的两个触发器，由于布线的长短不同，时钟沿到达不同触发器的时间是有差异的。 符号定义 : 建立时间余量 $T{su_slack}$，保持时间余量$T_{hd_slack}$，时钟周期$T$， 建立时间$T_{su}$，保持时间$T_{hd}$，组合逻辑延迟$T_{delay}$，逻辑门传输延迟$T_{co}$，时钟偏斜1$T_{clk1}$，时钟偏斜2$T_{clk2}$。 建立时间余量计算为： $$ T_{su\\_slack} = T + T_{clk2} - T_{su} - (T_{clk1} +T_{co} + T_{Delay}) $$ 保持时间余量为： $$ T_{hd\\_slack} = T + T_{clk1} + T_{co} + T_{delay} - (T + T_{clk2} + T_{hd}) \\\\ =T_{clk1} + T_{co} + T_{delay} - T_{clk2} - T_{hd} $$ 建立时间余量$T{su_slack}$是和时钟周期有关的，保持时间余量$T_{hd_slack}$和时钟周期没有关系。也就是说时钟的频率会影响建立时间余量。 真正在设计中，我们能够影响的就是有组合逻辑延迟$T_{delay}$。 VIVADO约束时序约束并不会对电路产生任何实质性的作用，只是可以辅助设计出正确的电路。 约束类型： 物理约束：I/O约束 时钟约束 VIVADO在做时序分析时，的默认条件： 默认所有时钟都是有关系的，都是同步的，都做时序分析。如果有异步时钟，则需要进行异步时钟约束 时钟类型的区分：如果使用到 DDR，PCI-E,GT接口，往往都需要多个时钟源 同步时钟：是指频率和相位有一定关系的时钟。大部分情况下来自同一个 时钟源 异步时钟：与同步时钟定义相反的时钟，来自不同的时钟源 在设计高速系统的时钟很容易发生时序违例（Timing Violation）。 时序违例指的是FPGA设计中某些信号到达目标寄存器或逻辑单元的时间超过了其允许的最大延迟，从而导致电路功能异常或无法正常工作。在FPGA设计过程中，时序违例通常是由时钟频率过高、复杂逻辑路径、布线不当等因素引起的。为避免时序违例，需要进行时序分析、时序约束设置、合理的优化布局等措施。 时钟约束的类型以及创建步骤 源时钟约束 告诉VIVADO当前的系统的输入时钟，以便VIVADO 进行建立时间和保持时间余量的分析。 创建源时钟约束步骤： 综合并布局布线 点击 IMPLEMENTATION下面的Edit timing Constraints在Clock 中选择 Create Clock 创建时钟，制定时钟的周期、上升沿时钟、下降沿时间 生成 时钟约束语句，并添加到XDC约束文件中 衍生时钟约束 自定义的时钟：例如自己写的倍频，分频，需要自己约束，选择创建时钟约束窗口中的Create Generated Clock 自动生成的时钟：使用自带的PLL 或者 MMCM IP 自动生成的时钟，这种情况是不需要自己进行约束的，VIVADO 会自动处理生成约束。 异步时钟约束 在VIVADO中声明那些是异步时钟，创建步骤： 选择Create Clock group 有多少个异步时钟就有多少个 组 选择 时钟的关系为 asyncchronous 互斥时钟 两个不会同时使用的时钟, 跟创建异步时钟步骤一致，只是时钟关系选择为 Logic exclusive 或者 physically exclusive 进阶问题 CDC跨时钟域约束","link":"/2023/03/22/FPGA%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F/"},{"title":"Diffusion Model","text":"","link":"/2023/03/27/Diffusion%20Model/"},{"title":"FPGA跨时钟域处理","text":"（实习准备）学习 FPGA 中跨时钟域通信问题的处理。 跨时钟域通信出现的问题： 亚稳态问题：如下图所示，触发器的存储需要有一个建立时间 $T{st}$ 和保持时间$T_{hd}$。数据变化的时间需要在 $T{st}$之前，需要在上升沿发生后至少保持$T{hd}$时间才能进行所存。如果数据不满足建立时间和保持时间，则会出现亚稳态问题，此时触发器中保存的内容是不定态。 解决办法 电平同步器： 针对单bit 脉冲同步器： 针对单bit FIFO, RAM ： 针对多bit 同步器 复位处理模块 快到慢的同步器 慢到快的同步器 双边缘检测器 “打两拍“ 同步的原理：异步赋值会产生亚稳态。概率数学上的处理的方式。每个触发器发生亚稳态的概率是独立的，多个触发器串联可以使 发生亚稳态的概率大大减小。“打三拍” 降低的概率和“打两拍”的差别不大。 同步复位代码： 123456789101112131415161718192021222324252627// 代码规范：// 模块名为 功能+_module ,如果是驱动则以 _driver结尾// 信号的名称 i_，o_ 分别表示 输入和输出的前缀// 寄存器变量的声明 以 reg_ 进行开头module sync_rst_module( input i_sysclk , input i_rst , output o_sync_rst )； // 告诉综合器，将这两个寄存器放在同一个 CLB 中 (* ANYNC_REG = &quot;TRUE&quot;*) reg r_rst1, r_rst2; // 一般的规范要求一个always块中只能处理一个信号，但是这里的设计比较简单，这里就直接写在一起了 always @(posedge i_sysclk) begin if (i_rst) begin r_rst1 &lt;= 1'b1; r_rst2 &lt;= 1'b1; end else begin r_rst1 &lt;= i_rst; r_rst2 &lt;= r_rst1; end end assign o_sync_rst = r_rst2; endmodule 慢时钟域到快时钟域同步：设计上和同步复位的代码是差不多的 12345678910111213141516module s2f_sync_module( input i_clk_slow , input i_signal , input i_clk_fast , output o_sync_signal )； (* ANYNC_REG = &quot;TRUE&quot;*) reg r_s1, r_s2; always @(posedge i_clk_fast) begin r_s1 &lt;= i_signal; r_s2 &lt;= r_s1; end assign o_sync_signal = r_s2; endmodule 快时钟域到慢时钟域同步：也叫脉冲同步器。 与慢到快不同的是需要进行脉冲周期延拓 12345678910111213141516171819202122232425262728293031module f2s_sync_module( input i_clk_slow , input i_signal , input i_clk_fast , output o_sync_signal )； reg r_d1, r_d2; // 延拓用的寄存器 wire r_pos; (* ANYNC_REG = &quot;TRUE&quot;*) reg r_s1, r_s2; always @(posedge i_clk_slow) begin r_d1 &lt;= i_signal; r_d2 &lt;= r_d1; end // 信号延拓 2个周期 assign r_pos = i_signal | r_d1 | r_d2; // 打两拍用的寄存器 (* ANYNC_REG = &quot;TRUE&quot;*) reg r_p1, r_p2; always @(posedge i_clk_slow) begin r_p1 &lt;= r_pos; r_p2 &lt;= r_p1; end // 同步输出 assign o_sync_signal = r_p2; endmodule 异步FIFO待补充， 参考 《Simulation and Synthesis Techniques for Asynchronous FIFO Design》","link":"/2023/03/21/FPGA%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86/"},{"title":"Git使用基础","text":"记录Git的常见用法。 Git基本概念 Git实现流程包括3个部分，工作区，暂存区(Stage)和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 Git 基础命令git中常用的操作包括以下几个部分： 初始化git仓库 添加文件到版本控制 提交当前文件到版本管理仓库 回退版本 初始化仓库以及提交文件123456789101112cd &lt;folder_name&gt;# 初始化一个 Git 仓库，该命令会在目录中生成一个 .git 文件夹git init # 添加需要版本控制的文件或者文件夹git add &lt;file_name&gt;# 移除添加到stage中的一个文件(对工作区没有影响)git rm --cached &lt;file_name&gt;# 查看当前状态git status 提交文件文件添加完成到Stage之后，可以使用 commit 命令提交到版本库。 1234567# 文件添加完后可进行提交git commit -m &quot;message&quot;# 查看提交历史git log# 简洁版历史git log --oneline 不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。 > commit 的内容遵循以下格式： > 第1行：提交修改内容的摘要 > 第2行：空行 > 第3行以后：修改的理由 提交回退当修改的代码出现了问题，可以对代码文件进行回退，这也是代码版本控制的重要功能。git中的版本回退使用reset命令。HEAD代表当前所指向的代码版本，HEAD^表示上一次提交 1234567891011# 回退到上2个版本git reset HEAD~2# 单独将一个文件回退一个版本git reset HEAD^ 1.txt# 回退到指定的提交, 后面接提交历史的hash值，可以通过 git log 查看，并不需要输入完整的hash值，只需要输入前几位就可以了git reset 023e# 可以在后面接 --hard 强制丢弃当前的所有未暂存的内容git reset --hard HEAD^ 分支操作1234567891011# 创建一个dev分支git checkout -b dev# 切换到master分支git checkout master# 将 dev分支合并到 master分支(接上面的命令)git merge dev# 删除dev分支git checkout -d dev 子模块12345678910111213# 查看当前已经添加的submodulegit submodule# 对于刚刚clone 下来的主仓库使用下面的命令进行初始化git submodule initgit submodule update # 或者git submodule update --init --recursive# 删除一个子模块。删除之前通过 git submodule 命令查看 submodule_namegit deinit [sub_module_name]git rm --cached [submodule_name]git commit -m &quot;remove ...&quot; 常见配置 配置初始化用户信息 在使用 git commit之前，还需要指定默认作为提交的用户 123# 如果是单独为某个仓库指定用户名和邮箱，把 global 参数去掉就可以了git config --global user.name 'user_name'git config --global user.email 'email' 正常显示中文git默认使用中文名称的时候是以 \\xxx这种形式显示的，虽然不影响我们的操作结果，但是不利于我们观察文件的变动信息，设置正常显示中文文件名的命令如下 1git config --global core.quotepath false","link":"/2022/08/16/Git%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"},{"title":"Linux炼丹中常用命令总结","text":"总结在服务器中跑深度学习的时候，常常需要使用的Linux 命令。 可搭配前面提到 docker搭建深度学习环境和tmux使用总结相关文章食用。 进程操作12345678# 查看当前运行的所有进程ps -aux# 结束一个进程, PID 可通过进程查找指令查看kill -s 9 PID# 结束所有python 进程（慎重使用）killall python 资源占用与文件查找1234567891011121314151617181920# 实时交互式显示 当前系统资源占用情况htoptop# 实时监控 GPU 占用watch -n 1 -d nvidia-smi# 查看磁盘剩余空间df -hl# 查看当前目录下各个文件/文件夹的大小du -h –max-depth=1 *# 查看当前目录下所有文件大小的总和du -sh# 查看当前文件个数, 使用 ^d 是统计文件夹的个数ls -l | grep &quot;^-&quot; | wc -l# 查找文件，后面跟的是正则表达式find . -name &quot;*.tar&quot; 文件的上传以及下载传输数据集的时候可以使用以下命令 1234567891011# 可以递归地创建文件夹mkdir -p /path/to/...# 复制文件夹cp -r sour_dir dest_dir# 从远程服务器下载文件 SCPscp username@servername:/path/filename /tmp/local_destination# 需要下载文件夹 则加上 -r 参数scp -r username@servername:/path/filename /tmp/local_destination# 上传文件则把两边的位置调换过来scp -r /tmp/local_dir username@servername:remote_dir 文件压缩与解压 1234567# 打包一个文件夹为一个zip压缩文件# -r 参数为递归地在文件夹中寻找文件压缩zip -r file_name.zip /path/to/dir# 解压一个zip压缩文件# -d 参数可以指定解压后文件的保存目录unzip file.zip -d /path/to/extract/ 硬盘操作添加新硬盘，格式化硬盘 1234567891011121314151617# 查看新硬盘是否已经被成功安装, 同时该命令还可以查看新的硬盘所挂载到的设备号，例如 sda,sdb,以及硬盘中已经存在的分区，分区的挂载信息等lsblk# 加上 -f参数可以查看分区的UUID，UUID在自动挂载时会使用lsblk -f# 创建分区, 该工具提供了基于命令行的简易分区工具，很好用cfdisk /dev/sda# 如果有分区的大小大于2T，则需要先将硬盘格式转换为GPT格式parted /dev/sda# 执行下面的命令, 根据提示完成转换即可mklabel gpt# 退出parted，使用 cfdisk进行分区q# 使用 cfdisk 分区完成后还需要将分区格式化为 ext4 格式mkfs -t ext4 /dev/sda1 下一步就是需要将已经分好区的硬盘挂载到相应的目录，这里假设需要挂载的硬盘号为 /dev/sda1,需要挂载到目录是 /home/user/exdisk1 1234# 创建目录，这步可以跳过mkdir -p /home/user/exdisk1# 临时挂载mount /dev/sda1 /home/user/exdisk1 如果只是临时使用该分区（例如挂载一个U盘），使用上面的命令也就足够了，如果需要挂载的是一个需要长期使用的U盘，则需要修改/etc/fstab文件。 第一步是使用 lsblk -f命令查看分区的UUID，每个磁盘分区的UUID在系统中都是唯一的，即使重启后也不会改变，如下图 框出来的就是此次需要挂载分区的UUID 注意：如果没有挂载，后面的挂载点的内容是空的 第二步是修改/etc/fstab文件，添加上一行，内容可以看文件上面的注释 12# &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;UUID=af931fd6-b0f5-455b-8e3a-6260b18fde24 /home/dilib5/ex_disk1 ext4 defaults 0 2 将/etc/fstab修改完成后，执行全部挂载命令验证所添加的内容是否正确，如果不正确可能会导致系统无法启动！ 1sudo mount -a 最后重启系统就可以看到硬盘已经成功挂载了，（用的是同一张图, 哈哈哈哈，逃）","link":"/2022/08/09/Linux%E7%82%BC%E4%B8%B9%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"title":"MLP的BP推导与实现-上","text":"内容包括梯度下降基本原理，矩阵求导基础。 前置知识在推导之前先复习一下一些基础知识。 一阶导数定义$$f{‘}(x) = \\displaystyle{\\lim_{\\Delta x \\to 0}} \\frac{\\Delta y}{\\Delta x} = \\frac{f(\\Delta x +x) - f(x)}{\\Delta x}$$ 多元函数偏导数定义$$f_{x1}(x1, x2,…)=\\lim _{\\Delta x \\to 0} \\frac{f(x1+\\Delta x, x2, x3, …)-f(x1, x2, x3,…)}{\\Delta x}$$ 方向导数的定义偏导数定义只是沿着某个坐标轴方向的导数，多元函数的自变量在某点可以沿无数个方向运动，多元函数沿着某个方向上的变换率称为 ==方向导数== ,它的推导过程如图所示（2个变元的情况） $$ \\begin{array}{l} \\lim _{t \\to 0^{+}} \\frac{f\\left(x_{0}+t \\cos \\alpha, y_{0}+t \\sin \\alpha\\right)-f\\left(x_{0}, y_{0}\\right)}{t} \\\\\\\\ =\\lim _{t \\to 0^{+}}\\left[\\frac{f\\left(x_{0}+t \\cos \\alpha, y_{0}+t \\sin \\alpha\\right)-f\\left(x_{0}, y_{0}+t \\sin \\alpha\\right)}{t}+\\frac{f\\left(x_{0}, y_{0}+t \\sin \\alpha\\right)-f\\left(x_{0}, y_{0}\\right)}{t}\\right] \\\\\\\\ =\\lim _{t \\to 0}\\left[\\frac{f_{x}\\left(\\xi_{x}, y_{0}+t \\sin \\alpha\\right) t \\cos \\alpha}{t}+\\frac{f_{y}\\left(x_{0}, \\xi_{y}\\right) t \\sin \\alpha}{t}\\right], \\xi_{x} \\in\\left(x_{0}, x_{0}+t \\cos \\alpha\\right), \\xi_{y} \\in\\left(y_{0}, y_{0}+t \\sin \\alpha\\right) \\\\\\\\ =f_x (x_0,y_0 )cos⁡\\alpha +f_y (x_0,y_0 )sin⁡\\alpha \\end{array} $$ 梯度的定义多元函数在某一点的梯度是一个非常特殊的向量，其由多元函数对每个变量的偏导数组成,（这即是为什么求梯度的时候需要对各个变量求偏导的原因），其方向为函数在该点增加最快的方向，大小（向量的模长）为函数在该点的最大变化率。 将上面的方向导数写成两个向量相乘的格式，就得到了： $$ \\begin{equation} f_x (x_0,y_0 )cos⁡\\alpha +f_y (x_0,y_0 )sin⁡\\alpha =\\left( \\begin{array}{cc} f_x (x_0,y_0 ) & f_y (x_0,y_0 ) \\end{array} \\right) \\left( \\begin{array}{c} cos⁡\\alpha \\\\ sin⁡\\alpha \\end{array} \\right) \\end{equation} $$ 设有两个变量 $g = (f_x (x_0,y_0 ) \\quad f_y (x_0,y_0 ))$和$e_l = (cos⁡\\alpha \\quad sin \\alpha)$ $$ g \\cdot e_l = |g||e_l|cos \\theta = |g|cos\\theta $$ $\\theta$ 为两个向量之间的夹角，所以该向量点乘结果（也就是方向导数） 在$\\theta = 0$的情况下。此时函数的变化率最大，函数呈上升趋势 在$\\theta = \\pi$的情况下函数的变化率最大，函数呈下降趋势 梯度下降原理因为梯度指示了函数变化率最大的地方，因此只要每次沿着梯度指示方向的反方向更新当前网络的参数并一直迭代，就可以将$loss$函数优化到最低点。$$w = w_j - \\alpha \\nabla J(W_j)$$ 矩阵求导由于在机器学习中，我们使用最多的数据一般都是向量或者矩阵形式的，很少有标量的情况，因此我们还需要学习矩阵求导的相关知识。 矩阵求导和函数求导还是不太一样的，具体学习可以参考下面这两个链接。矩阵求导的本质就是 一个函数 $function$的每一个$f$对变元中的每个元素逐个求偏导。但是在神经网络中一般涉及到的形式一般是输入一组矩阵或者向量，最后输出的$loss$值一般为一个标量用于衡量网络的性能。所这里就只考虑$f$是一个矩阵变元的实值标量函数，我们需要使用梯度下降优化这个函数的参数，使该函数的输出值最小。 这里推荐两篇文章，这里只是对这两篇文章的一些总结，更详细的内容可以直接看原文。 矩阵求导术 矩阵求导 矩阵求导布局 分子布局：求导的 $f$ 是列向量的形式，分子$X$是行向量的形式 分母布局：求导的 $f$是行向量的形式，分子$X$是列向量的形式 分子布局和分母布局互为转置。 矩阵求导常用的四个法则以及公式矩阵求导的四个法则跟一元函数求导的法则是一致的，可以直接借鉴过来 $$ \\begin{align} &\\frac{\\partial C}{\\partial X} = 0 \\\\\\\\ &\\frac{\\partial\\left[c_{1} f(x)+c_{2} g(x)\\right]}{\\partial z}=c_{1} \\frac{\\partial f(x)}{\\partial z}+c_{2} \\frac{\\partial g(x)}{\\partial z} \\\\\\\\ &\\frac{\\partial[f(x) g(x)]}{\\partial z}=\\frac{\\partial f(x)}{\\partial z} g(x)+f(z) \\frac{\\partial g(z)}{\\partial z} \\\\\\\\ &\\frac{\\partial\\left[\\frac{f(x)}{g(x)}\\right]}{\\partial z}=\\frac{1}{g^{2}(x)}\\left[\\frac{\\partial f(x)}{\\partial x} g(z)-f(z) \\frac{\\partial g(x)}{\\partial x}\\right] \\end{align} $$ 一些补充公式 $$ \\begin{align} &\\frac{\\partial\\left(x^{T} a\\right)}{\\partial x}=\\frac{\\partial\\left(a^{T} x\\right)}{\\partial x}=a \\\\\\\\ &\\frac{\\partial\\left(x^{T} x\\right)}{\\partial z}=2 x \\\\\\\\ &\\frac{\\partial\\left(x^{T} A x\\right)}{\\partial x}=A x+A^{T} x \\\\\\\\ \\end{align} $$ 矩阵求导的进阶技巧上面写都是矩阵求导的基本法则，类似于使用定义法求一元函数的导数，使用的场合不多，更为常用的方法是使用迹技巧去求解。 首先来看迹的定义：$$tr(A) = a_{11} + a_{22} + \\cdots + a_{nn} = \\sum_{i=1}^{n}a_{i}$$一些常见的迹的公式 $$ \\begin{align} &tr(c) = c \\newline &tr(c_1A + c_2B) = c_1tr(A) + c_2tr(B) \\newline &tr(A) = tr(A^T) \\newline &\\underline{tr(ABC) = tr(CAB) = tr(BCA)}, \\quad A_{m\\times n}, B_{n \\times p}, C_{p \\times m} \\newline &tr(AB^T) = tr(B^TA) = tr(A^TB) = tr(BA^T) \\newline &tr(|A|) = |A| tr(A^{-1}dA) = tr(|A|A^{-1}dA) \\newline &tr(A^T (B \\odot C)) = tr((A \\odot B)^T C) \\end{align} $$ 注意上面画横线的那个公式的意思是两个矩阵相乘的迹，可以将后 一个的矩阵提到前面去，结果不改变。 矩阵乘积的迹，（注意这里迹的表示，这对理解为什么可以利用迹来求导至关重要） 设有两个矩阵，$A_{2\\times3}$和$B_{3\\times2}$ $$ A = \\left( \\begin{array}{ccc} a_{11} & a_{12} & a_{13}\\\\ a_{21} & a_{22} & a_{23}\\\\ \\end{array} \\right) \\quad B = \\left( \\begin{array}{cc} b_{11} & b_{12}\\\\ b_{21} & b_{22}\\\\ b_{31} & b_{32}\\\\ \\end{array} \\right)\\\\ $$ $$ AB = \\left( \\begin{array}{ccc} a_{11}b_{11}+a_{12}b_{21}+a_{13}b_{31} & a_{11}b_{12}+a_{12}b_{22}+a_{13}b_{32}\\\\ a_{21}b_{11}+a_{22}b_{21}+a_{23}b_{31} & a_{21}b_{12}+a_{22}b_{22}+a_{23}b_{32}\\\\ \\end{array} \\right) \\newline tr(AB) = a_{11}b_{11}+a_{12}b_{21}+a_{13}b_{31}+a_{21}b_{12}+a_{22}b_{22}+a_{23}b_{32} $$ 如果有$A = B^T$，则两个矩阵相乘的迹等于对应位置的元素相乘并相加，可以理解为向量的点积在矩阵上的推广。 设有标量函数 $f(X), X_{m \\times n}$，求$df(X)$ $$ \\begin{aligned} \\mathrm{d} f(\\boldsymbol{X}) &=\\frac{\\partial f}{\\partial x_{11}} \\mathrm{~d} x_{11}+\\frac{\\partial f}{\\partial x_{12}} \\mathrm{~d} x_{12}+\\cdots+\\frac{\\partial f}{\\partial x_{1 n}} \\mathrm{~d} x_{1 n} \\\\ &+\\frac{\\partial f}{\\partial x_{21}} \\mathrm{~d} x_{21}+\\frac{\\partial f}{\\partial x_{22}} \\mathrm{~d} x_{22}+\\cdots+\\frac{\\partial f}{\\partial x_{2 n}} \\mathrm{~d} x_{2 n} \\\\ &+\\cdots \\\\ &+\\frac{\\partial f}{\\partial x_{m 1}} \\mathrm{~d} x_{m 1}+\\frac{\\partial f}{\\partial x_{m 2}} \\mathrm{~d} x_{m 2}+\\cdots+\\frac{\\partial f}{\\partial x_{m n}} \\mathrm{~d} x_{m n} \\end{aligned} $$ 可以发现，$df(X)$的结果其实就是两个矩阵$(\\frac{\\partial f}{\\partial X_{ij}})_{i=1,j=1}^{m,n}$和$(dX_{ij})_{i=1,j=1}^{m,n}$对应位置相乘并相加，所以该式就可以写为迹的形式： $$ \\begin{aligned} \\mathrm{d} f(\\boldsymbol{X}) &=\\frac{\\partial f}{\\partial x_{11}} \\mathrm{~d} x_{11}+\\frac{\\partial f}{\\partial x_{12}} \\mathrm{~d} x_{12}+\\cdots+\\frac{\\partial f}{\\partial x_{1 n}} \\mathrm{~d} x_{1 n} \\\\ &+\\frac{\\partial f}{\\partial x_{21}} \\mathrm{~d} x_{21}+\\frac{\\partial f}{\\partial x_{22}} \\mathrm{~d} x_{22}+\\cdots+\\frac{\\partial f}{\\partial x_{2 n}} \\mathrm{~d} x_{2 n} \\\\ &+\\cdots \\\\ &+\\frac{\\partial f}{\\partial x_{m 1}} \\mathrm{~d} x_{m 1}+\\frac{\\partial f}{\\partial x_{m 2}} \\mathrm{~d} x_{m 2}+\\cdots+\\frac{\\partial f}{\\partial x_{m n}} \\mathrm{~d} x_{m n} \\\\ &=\\operatorname{tr}\\left(\\left[\\begin{array}{cccc} \\frac{\\partial f}{\\partial x_{11}} & \\frac{\\partial f}{\\partial x_{21}} & \\cdots & \\frac{\\partial f}{\\partial x_{m 1}} \\\\ \\frac{\\partial f}{\\partial x_{12}} & \\frac{\\partial f}{\\partial x_{22}} & \\cdots & \\frac{\\partial f}{\\partial x_{m 2}} \\\\ \\vdots & \\vdots & \\vdots & \\vdots \\\\ \\frac{\\partial f}{\\partial x_{1 n}} & \\frac{\\partial f}{\\partial x_{2 n}} & \\cdots & \\frac{\\partial f}{\\partial x_{m n}} \\end{array}\\right]_{n \\times m}\\left[\\begin{array}{cccc} \\mathrm{d} x_{11} & \\mathrm{~d} x_{12} & \\cdots & \\mathrm{d} x_{1 n} \\\\ \\mathrm{~d} x_{21} & \\mathrm{~d} x_{22} & \\cdots & \\mathrm{d} x_{2 n} \\\\ \\vdots & \\vdots & \\vdots & \\vdots \\\\ \\mathrm{d} x_{m 1} & \\mathrm{~d} x_{m 2} & \\cdots & \\mathrm{d} x_{m n} \\end{array}\\right]_{m \\times n}\\right) \\end{aligned} $$ 所以就可以得出结论：$df(X)= tr(\\frac{\\partial f(X)}{\\partial X^T} dX)$ 如何使用矩阵微分求导对于实值标量函数$f(X)$，$tr(f(X)) = f(X)$， $df(X) = tr(df(X))$ ，所以有$$df(X) = d(tr(f(X))) = tr(df(X))$$上面的公式表明，迹和求微分是可以交换的 下面计算一个简单的例题：证明正面下面结论。 $$ \\begin{align*} &\\frac{\\partial{tr(X^TX)}}{\\partial{X}} = 2X \\\\ &\\Rightarrow d(tr(X^TX)) = tr(dX^TX)\\\\ &=tr(dX^TX + X^TdX)\\\\ &=tr(dX^T X) + tr(X^TdX)\\\\ &=tr(XdX^T) + tr(X^TdX) = tr(X^TdX)+tr(X^TdX)\\\\ &=tr(2X^TdX)\\\\ &\\Rightarrow \\frac{\\partial{tr(X^TX)}}{\\partial{X}}=2X \\\\ &\\Rightarrow \\frac{\\partial{tr(X^TX)}}{\\partial{X^T}}=2X^T \\end{align*} $$","link":"/2022/03/11/MLP%E7%9A%84BP%E6%8E%A8%E5%AF%BC%E4%B8%8E%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/"},{"title":"Gnome 创建快捷方式","text":"Linux Gnome桌面环境创建快捷方式图标的方法。 快捷方式格式 新建以*.desktop结尾的文件，例如，需要创立 vitis 程序的桌面快捷方式的内容如下： 程序执行的路径为:/tools/Xilinx/Vitis/2022.2/bin/vitis 图标的路径为: /tools/Xilinx/Vitis/2022.2/doc/images/ide_icon.png 12345678910[Desktop Entry]Version=1.0Name=vitisComment=vitisGenericName=vitisType=ApplicationExec=/tools/Xilinx/Vitis/2022.2/bin/vitis %u Icon=/tools/Xilinx/Vitis/2022.2/doc/images/ide_icon.pngTerminal=falseCategories=GNOME;Application 编辑完成之后 右键点击该文件，设为可执行 添加到Gnome 启动台编辑完成后可以将该文件复制到/usr/share/applications路径下面，就可以在启动台看到该应用程序了。","link":"/2022/04/28/Linux%E5%88%9B%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"},{"title":"Matplotlib笔记","text":"系统学习matplotlib的一些常见用法，节省需要用到的时候的搜索时间 框架结构，Matplotlib的架构分为三层，也就对应了几种代码画图风格。三个层分别为 backend layer （最底层，没人使用） artist layer （中层，灵活度很高，基本满足一切绘图要求） scripting layer （高层，模仿Matlab 进行构建，但是不够灵活） 常见的画图的代码通常包括两种风格： 123456789import matplotlib.pyplot as pltplt.figure(1) plt.subplot(211) plt.plot(x0,y0)plt.subplot(212) plt.plot(x1,y1)plt.show() 123fig, ax = plt.subplots(2,1,figsize=(14,7)) ax[0].plot(x0,y0)ax[1].plot(x1,y2) 这两种画图风格就分别对应了scripting layer 和 artist layer两个不同封装层次的API。第二种画图风格是 Matplotlib官方所推荐的OOP 的画图方式。 主要元素 axesaxes并不是字面意义上的标轴，整个图像所能操作的区域都可以归为 axes。 Matplotlib uses Axes to refer to the drawing area that contains data, x- and y-axis, ticks, labels, title, etc.","link":"/2022/10/17/Matplotlib%E7%AC%94%E8%AE%B0/"},{"title":"MLP的BP推导与实现(下)","text":"上一篇文章学习矩阵求导的方法，这篇文章以上一篇文章为基础，推导一个三层的MLP的反向传播算法并给出它的代码实现。 前言进行推导前需要先列出几个后面需要使用的函数 首先是大名的鼎鼎的交叉熵（Cross Entropy）函数，它的定义如下，其中 $y$ 是独热码编码后的类别，$softmax$的函数输出可以衡量输出是每个类别的概率大小。 $$ L = -y^T log(softmax(x))\\\\\\\\ softmax(\\vec {x}) = \\frac{e^{x_i}}{\\sum_{j=1}^{K}e^{x_j}} \\\\\\\\ L^{'}(x) = softmax(\\vec{x}) - \\vec{y} $$ 我们后面的激活函数采用比较常见的$\\sigma$函数，它的定义和导数是 $$ \\begin{align} \\sigma(x) &= \\frac{1}{1 + exp(x)} \\\\\\\\ \\sigma(x)^{'} &= \\sigma(x)(1-\\sigma(x)) \\end{align} $$ 当然，后面的推导也不会使用$\\sigma$函数求导的完整结果（因为太长了），而是用$\\sigma^{‘}$表示，如果要更换$ReLu$或者别的激活函数，如只需要将求导结果带进去就可以了。 符号定义假设我们的网络有 $n$层，$w_i$和$b_i$分别表示第$i$层的参数(wight)和偏置(bias)，使用$a_i$表示第$i$层还没有经过激活函数的结果，使用 $h_i$表示第$i$层的输出同时也是第$i+1$层的输入，也就是相当于$h_i = \\sigma(a_i)$， $\\sigma$函数作为激活函数。整个网络的前向传播的$Loss$表达式可以写成下面的这种形式。 $$ \\begin{align} L &= -y^T log(softmax(h_3)) \\\\\\\\ h_3 &= h_2w_3 + b_3 \\\\\\\\ a_2 &= h_1w_2 + b_2 \\quad h_2 = \\sigma(a_2) \\\\\\\\ a_1 &= h_0w_1 + b_1 \\quad h_1 = \\sigma(a_1) \\\\\\\\ h_0 &= x \\end{align} $$ 这里假设输入的向量$x$和输出向量$y$都是列向量 当然，如果不定义符号进行替换的话就可以写成下面的这种比较长的形式。 $$ L = -y^T log(softmax( \\sigma(\\sigma(xw_1 + b_1)w_2 + b_2)w_3 + b_3 )) $$ 可以看到，MLP的本质其实就是我们最常见的复合函数的形式，只是我们的输入的变量$x$是一个向量或者矩阵的形式。我们的任务就是借助上一篇文章中所提到的矩阵求导的手段求出 $L$ 对每个$w_i$和$b_i$的偏导表达式。 第三层推导根据前言部分$log(softmax(x))$函数的求导，可以直接求得$h_3$的偏导数 $$ \\frac{\\partial L }{\\partial h_3} = softmax(h_3) -y $$ 将 $dL$ 写成迹的形式 $$ \\begin{align} tr(dL) &= tr((\\frac{\\partial L}{\\partial h_3})^T dh_3) \\\\ &=tr((\\frac{\\partial L}{\\partial h_3})^T d(h_2w_3 + b_3)) \\\\ &= \\color{blue}{tr((\\frac{\\partial L}{\\partial h_3})^T d(h_2w_3))} + \\color{red}{tr((\\frac{\\partial L}{\\partial h_3})^T d(b_3))}\\\\ \\end{align} $$ 通过红色的部分就得到了我们可以看到$L$关于$b_3$的微分形式，通过这个式子就可以写出$L$关于$b_3$的偏导数： $$ \\frac{\\partial L}{\\partial b_3} = ((\\frac{\\partial L }{\\partial h_3})^T)^T = \\frac{\\partial L }{\\partial h_3} $$ 将前面蓝色的部分单独写下来，继续经过变形 $$ \\begin{align*} &\\quad tr((\\frac{\\partial L}{\\partial h_3})^T d(h_2w_3)) \\\\ &=tr((\\frac{\\partial L}{\\partial h_3})^T d(h_2)w_3) + tr((\\frac{\\partial L}{\\partial h_3})^T h_2d(w_3)) \\\\ &=\\color{blue}{tr(w_3(\\frac{\\partial L}{\\partial h_3})^T d(h_2))} + \\color{red}{tr((\\frac{\\partial L}{\\partial h_3})^T h_2d(w_3))} \\\\ \\end{align*} $$ 同样的由红色部分，我们可以得到$L$关于$w_3$的偏导，蓝色的部分我们后续的推导需要用。 $$ \\frac{\\partial L}{\\partial w_3} = (\\frac{\\partial L}{\\partial h_3})^T h_2)^T = h_2^T \\frac{\\partial L}{\\partial h_3} $$ 到这里，我们第三层的所有参数 $w_3$和$b_3$的梯度我们都算出来了。 第二层推导接着把第三层推导剩下的蓝色部分单独提出来 $$ \\begin{align*} & \\quad tr(w_3(\\frac{\\partial L}{\\partial h_3})^T d(h_2))\\\\ & = tr(w_3(\\frac{\\partial L}{\\partial h_3})^T d(\\sigma(a_2))) \\\\ & = tr(w_3(\\frac{\\partial L}{\\partial h_3})^T \\sigma^{'}(a_2) \\odot d(a_2)) \\\\ \\end{align*} $$ 根据上篇文章提到的$tr(A^T (B \\odot C)) = tr((A \\odot B)^T C)$可以化简为 $$ \\begin{align*} & \\quad tr(w_3(\\frac{\\partial L}{\\partial h_3})^T \\sigma^{'}(a_2) \\odot d(a_2)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T)^T \\sigma^{'}(a_2) \\odot d(a_2)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d(a_2)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d(h_1w_2 + b_2)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d(h_1w_2)) + \\color{red}{tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d( b_2))}\\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d(h_1)w_2) \\\\ \\quad &+ \\color{blue}{tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T h_1d(w_2))} + \\color{red}{tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d( b_2))}\\\\ \\end{align*} $$ 可以得到 $$ \\frac{\\partial L}{\\partial w_2} = ((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T h_1)^T = h_1^T (\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)) $$ $$ \\frac{\\partial L}{\\partial b_2} =\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2) $$ 第一层推导经过前两节的推导，我们得到了第二和第三层的表达式，但是他们的规律还不是非常的明显，我们继续推导第一层的偏导数。 $$ \\begin{align*} &\\quad tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d(h_1)w_2) \\\\ & = tr(w_2 (\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T d(\\sigma(a1)) \\\\ & = tr(w_2 (\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2))^T \\sigma ^{'}(a1)\\odot d(a1)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T )^T \\sigma ^{'}(a1)\\odot d(a1)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T d(h_0w_1 + b_1)) \\\\ & = tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T d(h_0w_1)) + tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T d(b_1)) \\\\ & = \\color{blue}{tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T h_0d(w_1))} + \\color{red}{tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T d(b_1))} \\\\ &+ tr((\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T d(h_0)w_1)\\\\ \\end{align*} $$ 可以得出 $$ \\begin{align} \\frac{\\partial L}{\\partial w_1} &= (\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1))^T h_0)^T \\\\ & = h_0^T(\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1)) \\end{align} $$ $$ \\frac{\\partial L}{\\partial b_2} =\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1) $$ 总结规律将分别将 $w_1, w_2, w_3$的偏导表达式写出来 $$ \\begin{align} \\frac{\\partial L}{\\partial w_1} &= h_0^T(\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1)) \\\\\\\\ \\frac{\\partial L}{\\partial w_2} &= h_1^T (\\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)) \\\\\\\\ \\frac{\\partial L}{\\partial w_3} &= h_2^T \\frac{\\partial L}{\\partial h_3} \\end{align} $$ 假设网络有 $n$层，编号依次为 1, 2 …，损失函数关于网络最终输出的偏导为$\\frac{\\partial L}{\\partial out}$，可以比较明显地发现以下规律： $$ \\frac{\\partial L}{\\partial w_{i}} = h_{i-1}^T\\left[\\frac{\\partial L}{\\partial out} \\prod_{k=n}^{k=i+1}(w_{k}^T \\odot \\sigma^{'}(a_{k-1}))\\right] $$ 注意:这里的连乘是倒序的 $b_1,b_2,b_3$的表达式为 $$ \\begin{align} \\frac{\\partial L}{\\partial b_1} &= \\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2)w_2^T \\odot \\sigma ^{'}(a1) \\\\\\\\ \\frac{\\partial L}{\\partial b_2} &= \\frac{\\partial L}{\\partial h_3} w_3^T\\odot \\sigma^{'}(a_2) \\\\\\\\ \\frac{\\partial L}{\\partial b_3} &= \\frac{\\partial L}{\\partial h_3} \\end{align} $$ 跟$w_i$类似，写出关于$b_i$的偏导数，其实就是$w_i$的偏导数去掉前面的$h_{i-1}$ $$ \\frac{\\partial L}{\\partial w_{i}} = \\frac{\\partial L}{\\partial out} \\prod_{k=n}^{k=i+1}(w_{k}^T \\odot \\sigma^{'}(a_{k-1})) $$ 注意:这里的连乘是倒序的 代码实现有了前面的推导过程，接下来就是代码的实现，代码将包含3个部分。 数据准备 模型类实现 全连接层实现 测试和训练数据生成在开始实现之前，我们需要先准备一些数据用于验证我们的模型工作是否正常。这里就直接实用sklearn库所提供的make_classification函数生成测试用的数据 12345N_CLASS = 3from sklearn.datasets import make_classificationx, y = make_classification(n_samples=2000, n_features=5, n_classes=N_CLASS, n_informative=5, n_repeated=0, n_redundant=0, n_clusters_per_class=1)sns.scatterplot(x=x[:,0], y=x[:,1], hue=y) 测试用的数据将包含5个特征，也就是说输入的向量维度是5，总共有 3个类别","link":"/2022/04/05/MLP%E7%9A%84BP%E6%8E%A8%E5%AF%BC%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%8B/"},{"title":"FPGA时序约束","text":"（实习准备）学习如何使用 Modelsim 进行仿真。 基本仿真流程指令可以将需要执行的 指令放到一个 *.do文件中就执行后就直接可以进行仿真了。 可以直接拖拽 整个 module到波形窗口 1234567891011121314# 改变工作目录cd /dir# 新建仿真库文件vlib work# 编译源文件vlog *.v# 执行仿真vsim -novopt work.&lt;testbench&gt;# 执行仿真run 100ns 执行一个脚本的命令是 1do test.do 常用的使用 GUI 的仿真流程 改变工作目录 新建工程 添加或者编写文件 编译文件 创建 Simulation Configration modelsim 中不同的符号会有不同的含义（后面补充） Code CoverageModelSim 的这功能可检查 经过仿真过后有多少的 代码是执行过，有多少是没有执行的。 如果需要做代码覆盖度检查，需要在编译的时候的命令需要改为 123vopt +cover=becsxf test_sm -o test_sm_optvsim -coverage test_sm_optrun 1 ms 可以选择 compile prospereties 在 Converage下面进行设置 Data FlowDebug 完成后通过右键选择信号添加到 Data Flow 窗口就可以看到 暂时不知道有什么用 波形对比可以对比输出的波形是否符合测试条件 生成基准波形的示例代码 12345678vlib workvlog *.vvopt +acc test_sm -o opt_test_gold# 生成基准波形vsim -wlf gold.wlf opt_test_goldadd wave *run 750 nsquit -sim 在需要对比波形的 仿真结束后选择 tools -&gt; Waveform Compare-&gt; Start Comprison 选择完基准波形后就可以显示不一样的模型了。 原理图生成1vsim -debugdb work.&lt;test_bench&gt; 执行完成会自动进入 仿真界面，选择view-&gt;schematic 选择后点击展开视图就可以查看原理图了 设置VSCode 为默认编辑器新建一个$HOME/.mentor/perf.tcl文件，然后添加下面的内容 12proc external_editor {filename linenumber} { exec &quot;code&quot; -g $filename:$linenumber}set PrefSource(altEditor) external_editor 在 ~/.zshrc或者 ~/.bashrc里面添加环境变量，这样就可以在开启软件的时候自动更换外部编辑器了。 1export MODELSIM_TCL=&quot;$HOME/.mentor/perf.tcl&quot;","link":"/2023/03/22/Modelsim%E4%BB%BF%E7%9C%9F/"},{"title":"Python Logging 使用总结","text":"在程序调试以及运行过程中 Log 都是分析程序运行的重要部分。本文记录了python的logging库的使用方法。 前言logging提供了方便的日志输出接口，可以指定将日志输出到控制台或者保存到文件，并提供了5种不同的输出日志输出等级：DEBUG&lt;INFO&lt;WARNING&lt;ERROR&lt;CRITICAL，可以为不同的输出方式（文件、控制台）等指定不同的输出等级，只有大于等于输出等级的日志才会被显示出来。 Logging中包含了4个重要的对象 Logger log操作的主要对象 Handler 日志保存到地方（可以是控制台或者一个文件），一个 logger可以包括多个Handler Filter 过滤日志的方法 Formatter 指定日志输出的格式，可以为每个Handler单独指定不同的Formatter 常见使用方法123456789101112131415161718import sys, logger# 获取一个logger对象，可以指定logger 的名字，这个名字可以用来区分不同的logger输出logger = logging.Logger('AmazeballsLogger')# 设置log控制台的输出，指定为sys.stdout，默认值是sys.stderrsh = logging.StreamHandler(sys.stdout)# 添加控制台输出Handler到Loggerlogger.addHandler(sh)# 设置log输出到一个文件fh = logging.FileHandler(&quot;/path/to/file.log&quot;, 'w+')# 添加文件输出Handler到Loggerlogger.addHandler(sh)# 指定全局输出的格式formatter = logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(message)s&quot;)logger.handler.setFormatter(formatter) Logger初始化完毕后就可以使用logger提供的接口输出日志信息了，具体的使用方法为： 12345logger.critical(&quot;critical&quot;)logger.error(&quot;error&quot;)logger.warning(&quot;warning&quot;)logger.info(&quot;info&quot;)logger.debug(&quot;debug&quot;) 指定输出等级当我们有一些信息只想保存在log文件但是不想显示在控制台中时，可以设置不同输出Handler的Level属性达到目的。 12345678910# 先设置全局的输出等级为最低，否则默认全局的最低输出等级是 WARNING,后面的设置都不会生效logger.setLevel(logging.DEBUG)# 设置控制台的日志输出等级，只有大于 WARNING 等级的日志会被输出到控制台sh.setLevel(logging.WARNING)logger.addHandler(sh)# 设置文件的日志输出等级，只有大于 DEBUG 等级的日志会被保存到文件fh.setLevel(logging.DEBUG)logger.addHandler(fh) 设置完成后执行 12345logger.critical(&quot;critical&quot;)logger.error(&quot;error&quot;)logger.warning(&quot;warning&quot;)logger.info(&quot;info&quot;)logger.debug(&quot;debug&quot;) 控制台输出 1232020-04-13 17:52:57,729 - CRITICAL - critical2020-04-13 17:52:57,731 - ERROR - error2020-04-13 17:52:57,734 - WARNING - warning 文件输出 123452020-04-13 17:52:57,729 - CRITICAL - critical2020-04-13 17:52:57,731 - ERROR - error2020-04-13 17:52:57,734 - WARNING - warning2020-04-13 17:52:57,734 - INFO - info2020-04-13 17:52:57,734 - DEBUG - debug 设置输出格式可以使用不同的占位符设置log的显示日志 123456789101112# %(asctime)s 输出时间，String# %(filename)s 输出日志的源文件文件名，String# %(lineno)d 输出日志的源文件所在文件的行数, Decimal# %(levelname)s 输出等级, String# %(message)s&quot; 输出信息内容 String# 可以使用formatter = logging.Formatter(&quot;[%(asctime)s][%(filename)s][line:%(lineno)d][%(levelname)s] %(message)s&quot;)logger.handler.setFormatter(formatter)# 单独指定不同 Handler 的输出格式fh.setFormatter(logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;))","link":"/2022/08/31/Python%20Log%20output/"},{"title":"docker搭建深度学习环境","text":"记录Docker的常见用法，主要是用在机器学习上。 Docker基础12345678910111213141516171819202122232425# 拉取镜像$ docker pull &lt;image_name&gt;# 删除镜像$ docker rmi &lt;image_id&gt;# 查看本地已经下载的镜像$ docker images ls# 基本运行$ docker run &lt;image_name&gt;:tag &lt;commands&gt;$ docker run ubuntu:leatest /bin/echo &quot;hello world&quot;# 以后台模式运行(detach mode)$ docker run -d &lt;image_name&gt; &lt;commands&gt;# 查看运行中的container，可以查看Container id 和 name$ docker ps# 停止和重启container$ docker stop &lt;container_name&gt;$ docker restart &lt;container_name&gt;# detach/ escape in a iteractive containner&lt;C-p&gt;+&lt;C+q&gt;# attach to a container$ docker attach &lt;container_name&gt;/&lt;container_id&gt; 高级运行可以在执行 run命令的时候添加各种参数设置 container的各种参数 1234567$ docker run &lt;parameters&gt; &lt;image_name&gt; &lt;commands&gt;&lt;parameter list&gt;-it # 交互模式运行--name &lt;container_name&gt; # 指定container运行名字-v &lt;host_folder&gt;:&lt;container_folder&gt; # 映射宿主机文件夹到container，也就是 volume-p &lt;host_port&gt;:&lt;container_port&gt; # 映射container端口到宿主机 给Container挂载GPU，在运行的时候添加参数 123--gpus all# or--runtime=nvidia 最终运行例子，这里以运行 Pytorch 环境为例子。 12345678docker run --gpus all \\--ipc=host-it \\--name pytorch_yjm \\-v /home/jiaming:/workspace \\-p 8022:22 \\pytorch/pytorch:1.9.0-cuda10.2-cudnn7-devel \\/bin/bash 深度学习工具配置 配置SSH 123apt install updateapt install -y openssh-server vimvim \\etc\\ssh\\sshd_config # 配置ssh 添加如下内容 12Port 22PermitRootLogin yes 修改 root 密码，并重启ssh服务 12service ssh restartpasswd root 炼丹专用库的安装 123conda install -y numpy seaborn opencv pandas# 如果需要使用 jupyter 的话conda install -y jupyter Save container to an image我们以交互方式配置完环境后，为了不用每次都重新配置，可以将Container 保存为image。 这样每次只用Run一下这个镜像就可以了。自定镜像的方法有 通过dockerfile编译生成 和 通过 commit 的方式。这里展示 commit 的方式， 12$ docker commit -a &quot;author_name&quot; -m &quot;messages&quot; &lt;container_id&gt; &lt;save_image_name&gt;:&lt;tag&gt;$ docker commit -a &quot;jiaming&quot; -m &quot;pytorch&quot; a404c6c174a2 mytorch:v1","link":"/2022/03/13/docker%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"},{"title":"verilog语法基础","text":"学习Verilog的基本语法. 电路的描述方式verilog是描述电路的语言。为了实现系统的逻辑功能，在设计系统时可以采用多种描述方式进行建模。verilog通常使用三种不同的风格描述电路。在设计电路的时候可以任意使用一种或混合使用多种描述方式来描述电路。经过综合工具综合后的结果一般都是门级结构描述。 结构描述方式：调用其他已经定义好的低层模块对整个电路功能进行描述，或者直接调用verilog内部基本的门级元件描述电路的结构。 数据流描述方式：设计者从数据在各存储单元之间进行流动和运算的角度对电路的功能进行描述。设计者可以使用verilog提供的高层次运算符，例如 +等直接对数据进行高层次的数学逻辑运算建模，而不用关心具体的门级电路结构。 行为描述方式：直接根据电路的外部行为进行建模，与具体的硬件电路无关。 信号声明方式数字表示方法整形数字的定义格式为 1[-][&lt;位宽&gt;]'&lt;进制&gt;&lt;数值&gt; 其中进制的标识符分别为：二进制（b或B）、八进制（o或O）十进制（d或D）、十六进制（h或H）。若省略进制则默认为十进制。 负号的标识需要在位宽的前面 数值还可以使用符号表示不定态 x（X）表示未知状态 z（Z，？）表示高阻态 一个 x或z可以分别表示十六进制中的四位，八进制中的三位，二进制的一位 变量数据类型verlog中的常量有三种类型 parameter wire reg parameter类型 parameter用于定义在不变的值，例如状态机中的状态、数学运算中的常数等。常量的类型包括三种： 整数型常量 （可逻辑综合） 实数型常量 （用于逻辑仿真） 字符串型常量 （用于逻辑仿真） 声明方式如下： 123parameter a=4'b10x0 // 4位二进制，第二位为不定值parameter b=12'dz // 12位十进制，全位为高阻态parameter c=8'h4x // 8位十六进制，低4位为不定值 wire类型 线网类型代表各个模块之间的物理连线，不能存储逻辑值，它的值由它的驱动元件决定，线网类型的默认值为高阻态z。verilog中所有的输入输出信号类型默认均为wire类型。 123456wire [位宽] 线网名称;// 声明例子wire a; // 定义一个 1位 的wirewire [7:0] b; // 定义一个8 位的wirewire [4:1] c, d; // 定义一个4 位的wire reg类型 寄存器类型表示一个抽象的数据存储单元，它具有状态保存作用。寄存器类型只能在initial和always内部被赋值。在赋值前默认值为x。对于reg类型，赋值语句的作用就像改变一组触发器的存储单元的值。可以用各种构造控制改变值的时机，如上升沿、下降沿等。单个reg类型的声明格式如下，其中的 n 代表寄存器的位宽。 123reg [位宽] 寄存器名称;reg [3:0] a; // 声明一个 4 位的寄存器reg [4:1] b; // 声明一个 4 位的寄存器 $ git config –global init.defaultBranch main$ git branch -M main # 如果是已经新建了的仓库，修改当前的分支名称为 mainshell 1reg[msb:lsb] name; 上面的msb和lsb分别代表向量的最高有效位和最低有效位。msb和lsb必须为常数、常数表达式或者parameter参数。 变量数组线网和变量都可以声明为一个数组，数组中的每个元素可以是标量也可以是向量。数组的定义格式为： 1234数据类型 [位宽] 变量名称[地址范围]// 例子wire bus[5:0]; //声明 6个位宽为 1 的wire 类型数组reg [7:0] data[3:0]; // 声明4个位宽为7 的reg 类型数组 通过使用下标可以访问数组中特定的单元 12data[2] = 0;data[3] = 8'hff; 助记： 位宽写在wire或者reg关键字后面则表示位宽，变量名后面则表示数组大小。如果位宽不写，则默认为1。 运算符verilog中支持的运算符与c语言中的运算符基本一致，但是由于verilog支持不定值的赋值方式，所以某些运算符的运算结果可能会不太一样。而且还有verilog中的所特有的运算符这里也会列出来。 算术运算 在进程整数除法运算时，结果要略去小数的部分只取整数部分。 在进行取模运算时结果的符号位与第一个操作数的符号位一致。 注意：当所运算的操作数中含有不确定的值x或者z时算数运算的结果也是不确定的 逻辑运算 ! &amp;&amp; ||这三个逻辑运算符只有作用于 全 0 的操作数时才认为该操作数具有逻辑零的值，操作数中有任意多个1则认为该操作数为1，当操作数中含有x时则返回结果仍然为 x。 判断逻辑相等和不相等分为两种 ,逻辑相等== !=和逻辑全等=== !==，当进行相等运算时，两个操作数必须逐位相等，比较结果才为1（真），如果任意一个操作数含有不定态（X）或高祖态（Z），其相等比较的结果就会是不定值。进行全等运算时，对不定或高阻状态也进行比较，当两个操作数完全一致时，其结果才为1，否则为0. 位运算 在使用~ &amp; | ^ ^~等位运算符时，若两个操作数的位宽不相等，则会自动将操作数在右端对齐，位数少的操作数相应的高位会使用0进行填充。 移位操作，移位操作分为两种，移位运算符 &gt;&gt;，&lt;&lt;，算术移位运算符&lt;&lt;&lt;,&gt;&gt;&gt;。 对于左移操作中出现的空位，都使用 0 开进行填充，在进行右移操作时，算术移位会使用符号位进行填充。 需要注意&gt;&gt;&gt;作用于有符号数，左边会补符号位；&lt;&lt;&lt;作用于有符号数，右边补0，符号位也被移走； 注意事项： 左移会导致位宽增加，右移位宽不变。 拼接与缩位下面列举verilog中所特有的运算符。 拼接运算符：可以将两个或多个信号的某些为进行拼接表示一个整体信号。 123456// 例子{a, b[3:0], w, 3'b101};// 将信号复制再进行拼接{4{w}} // 等同于 {w, w, w, w}; 缩位运算符：缩位运算符的符号与位运算符的符号一样，但缩位运算符是针对当个操作数的，对当个操作数从左到右按照位的顺序两两进行相应的运算。 12345a = 4'b0101;&amp;a // 0|a // 1^a // 0 程序的基本结构结构化描述123456789101112131415// 这里演示全加器的实现// 可以按照以下格式声明端口// 输入输出方向 信号类型[位宽] 信号名;module fadder( i_A, i_B, i_Cin, o_S, o_C); input i_A, i_B, i_Cin; // 输入端口 output o_S, o_C; // 输出端口 parameter s_delay=1, c_delay=1; // 定义两个参数，参数也可以代表常量 assign #s_delay o_S = i_A ^ i_B ^ i_Cin; // 延时s_delay assign #c_delay o_C = (i_A ^ i_B) &amp; i_Cin | (i_A &amp; i_B) // 延时c_delay endmodule 当需要调用已经写好的模块或者IP时（类似于函数调用），需要例化模块，并传递信号。 例化模块的基本语法如下： 1模块名 实例名 (.端口名1(连线1), .端口名2(连线2), ...)； 注意事项： 在顶层文件使用被调用模块的端口时，如果端口声明为input，则向该端口传递的信号可以是wire或者reg类型。如果端口声明为output，则向该端口传递的信号必须是wire类型。 一个完整地例化模块调用过程： 123456789101112131415161718module fadder_delay_1( i_A, i_B, i_Cin, o_S, o_C) // 实例化一个模块并设置其中的参数 // 第一种方式 fadder fadder_delay_1_ins(.i_A(i_A), .i_B(i_B), .i_Cin(i_Cin), .o_S(o_S), o_C(o_C)); defparam fadder_delay_1_ins.s_delay=2, fadder_delay_1_ins.c_delay=3; // 第二种方式 fadder #(2,3) fadder_delay_1_ins(.i_A(i_A), .i_B(i_B), .i_Cin(i_Cin), .o_S(o_S), o_C(o_C)); //第三种方式 fadder #(.s_delay(2),.c_delay(3)) fadder_delay_1_ins(.i_A(i_A), .i_B(i_B), .i_Cin(i_Cin), .o_S(o_S), o_C(o_C));endmodule 数据流描述在使用数据流描述电路时通常使用连续赋值语句实现。连续赋值语句必须以 assign开头，出现在和门单元实例化相同的代码层次，它的结构为 1assign [delay] wire_type_var=expression; 使用数据流的方式描述一个4位的加法器 123456module adder( input [3:0] a, input [3:0] b, input cin, output [3:0] sum, output cout;) assign {cout,sum} = a+b+cin;endmodule 在进行逻辑综合时，综合器会自动优化综合出来的门电路。 行为描述行为描述一般使用initial和always过程块结构。 initial过程块 主要用于仿真测试，用来对变量进行初始化或者产生激励波形，过程块中的内容只会被执行一次，一个module可以有多个initial块结构，各个initial过程块之间并行运行。若块中的语句没有添加延时控制，则可以延时指定的时钟周期后再执行后续指令。 initial过程块不能进行逻辑综合 123456789101112131415initialbegin #延时数 行为语句; #延时数 行为语句; ..end// 例子reg[3:0] a;initial begin a=4'b0000; // 缺省为在0时刻执行该代码#5 a=4'b0001 // 经过5个时间单位后执行赋值#5 a=4'b0010 // 经过 10 个时间单位后执行赋值end always 过程块，always 过程块会一致被重复执行，多个always过程块并行执行，与书写顺序无关。 @中包含的敏感信号可为电平触发或者逻辑变量触发，使用电平触发时可以使用 posedge和negedge表示上升沿和下降沿。 在always过程块中执行的赋值语句，等号左边必须为reg类型。 1234567891011always @ (敏感信号列表) // always @(*) 代表任意信号变化(电平变化)时都会发生的操作begin 行为语句1; 行为语句2; ...end// 例子always @ (posedge clk) // 只在上升沿触发执行always @ (posedge clk or negedge clk) // 在上升沿和下降沿都执行 赋值方式由于verilog程序所描述的是电路结构，具有天然的并行特性，因此对变量的赋值于软件编程语言存在非常大的不同。 使用准则： 在描述组合逻辑的 always 块中使用阻塞赋值 =, 综合成组合逻辑电路结构，这种电路的输出结果只和输入的电平变化有关。 在描述时序逻辑的 always块中使用非阻塞赋值 &lt;=, 综合成时序逻辑电路结构，这种电路的结构往往和触发沿有关，当触发沿满足条件时才发生变化。 注意事项： 在同一个 always 块中不能混用阻塞赋值和非阻塞赋值 不允许在多个 always 块中对同一个变量进行赋值 下面通过两个例子帮助理解两种赋值方式的不同。 阻塞赋值所谓阻塞的概念是指，在同一个always块中，后面的赋值语句是在前一句赋值语句结束后才开始赋值的。例如下面的示例 123456789101112131415always @(posedge CLK_i or negedge RSTn_i) begin if(!RSTn_i) begin a = 1; b = 2; c = 3; end else begin a = 0; b = a; c = b; end end 在复位结束后，有 a = 1; b = 2; c = 3; 第一个上升沿到来的时候，有a = 0; b = 0; c = 0;，而后的结果就不会再发生变化了。 非阻塞赋值所谓非阻塞的概念是指，在计算非阻塞赋值的RHS以及更新LHS期间，允许其他的非阻塞赋值语句同时计算RHS和更新LHS。 右边表达式是同一时间计算出来的，并同时更新左边的表达式， 即右边表达式通过组合逻辑计算出来后，马上所存到DFF中 备注： RHS - &gt; 右边的表达式； LHS - &gt; 左边的表达式； always开始时，先计算右边表达式的值 always结束后才更新左边表达式的值，只能下次always执行时才能感知到变量的变化 将阻塞赋值的例子修改为： 123456789101112131415always @(posedge CLK_i or negedge RSTn_i) begin if(!RSTn_i) begin a &lt;= 1; b &lt;= 2; c &lt;= 3; end else begin a &lt;= 0; b &lt;= a; c &lt;= b; end end 复位结束后，值与阻塞赋值相同，有 a = 1; b = 2; c = 3; 当第一个上升沿到达时，有a = 0; b = 1; c = 2; 当第二个上升沿到达时，有a = 0; b = 0; c = 1; 当第三个上升沿到达时，有a = 0; b = 0; c = 0;，而后的结果就不会再发生变化了。 可以看到，当使用非阻塞赋值时，右侧的表达式的值是在同一时刻确定的，而阻塞赋值则存在一个先后次序关系。 条件判断条件判断语句属于过程描述语句，不能单独用来描述组合逻辑电路，if和case语句只能出现在always语句内，如果需要使用条件判断语句描述组合逻辑电路，可以在always @(*)中进行书写，在综合时会生成多路选择器。 123456789101112always @(*) begin if (w1) // expression else // expression case (w2) a1: //... a2: // ... endcase end 如果只含有一个判断变量可以使用三元表达式进行描述，在综合的时候会生成 一个 2选1 的多路选择器。 1assign w1 = (c1) ? a1 : a2; // c1 为真则选择 a1 输出，否则选择 a2 注意（避免生成Latch）： 使用条件判断语句描述组合逻辑电路时需要对所有可能的情况都要进行描述描述，因为verilog对于没有指定条件的输出采用的”维持输出不变“的原则，此时就需要电路具有状态保持功能，但是组合逻辑电路中并没有”记忆原件“，因此就会在综合的时候为组合逻辑电路加上锁存器（Latch）以”记住“此时的状态。 单分支逻辑判断使用if () ... else if () ... else 语句表示。具体的语法和c 语言的差不多，这是在书写多条语句的时候需要使用 begin ... end括起来。 12345678910111213141516if (condition) expression;if (condistion1) expression1;else expression2;if (condistion1) expression1;else if (condistion2) expression2;...else expression3; 多分支多条件判断时可以使用 case 语句，它的使用格式是 1234567891011121314151617181920always @(*) begin case (var) condition1: expression1; condition2: expression2; defualt: defualt_expression; endcase end// 支持不定态的casexalways @(*) begin casex (in) 4'bxxx1: pos &lt;= 2'd0; 4'bxx10: pos &lt;= 2'd1; 4'bx100: pos &lt;= 2'd2; 4'b1000: pos &lt;= 2'd3; default: pos &lt;= 2'd0; endcase end 尽量避免使用 casex语句，可以使用casez语句。 注意： 分支表达式的值互不相同 所有表达式的位宽必须相等，不3能使用 ‘bx 代替 n’bx 当不需要考虑 x 和 高阻时 使用 casex ... endcase 当不需要考虑 高阻时 使用 casez ... endcase 0 != x or z 循环语句软件开发的高级语言大多提供了for或while等循环流程控制语句。verilog中也提供了for语句，但是在HDL语言中，循环执行的操作一般通过时序逻辑电路完成，for语句一般只用在testbench 中进行数据生成，在RTL编程中很少进行使用。 主要原因就是for循环会被综合器做并行展开，每个变量独立占用寄存器资源，如果不能很好地考虑运行逻辑，会造成资源的极大浪费。 常见使用格式如下： 12345678reg [3:0] counter ;initial begin counter = 'b0 ; while (counter&lt;=10) begin #10 ; counter = counter + 1'b1 ; endend 生成语句 批量生成语句 2001标准中新加入的generate语句可以批量例化多个模块，并设置其中的连线。genvar声明了generatate块中使用的变量名。 具体格式如下： 1234567genvar i; // 标识变量generate for(init; condistion; next)begin:module_name // expression endendgenerate 可以看到for中的表达式和C语言中时一样的，只是关键字begin后面需要跟一个module_name，该名称指明了generate所生成模块的名称，可以通过module_name[index]的方式的访问实例化生成的模块。 例如: 1234567genvar i; generate for (i = 1; i &lt;= 510; i=i+1) begin :ut relu110 u(.l(q[i+1]), .c(q[i]), .r(q[i-1]), .n(q_next[i])); endendgenerate 注意：不能将generate for语句放在 always语句中 条件生成语句 条件生成语句包括 generate if 和generate case两种。 generate if语句的格式 1234567generate if (condition) begin: Name1 //expression end else begin: Name2 //expression endendgenerate case 语句的格式 12345678910111213generate case (&lt;constant_expression&gt;) &lt;value&gt;: begin: &lt;label_1&gt; &lt;code&gt; end &lt;value&gt;: begin: &lt;label_2&gt; &lt;code&gt; end default: begin: &lt;label_3&gt; &lt;code&gt; end endcaseendgenerate 注意： 这段表达是在编译时生效的，因此 condition 应该满足以下几个条件 条件表达式必须是参数或宏定义。 条件表达式必须在编译时求值。 生成语句的嵌套 generate for 语句中可以嵌套if和case语句用于判断，这样可以提升生成语句的灵活性。例如： 123456789101112genvar i;generate for (i = 0; i &lt;= 511; i=i+1) begin :ut if (i == 0) relu110 u(.l(q[i+1]), .c(q[i]), .r(1'b0), .n(q_next[i])); else if (i == 511) relu110 u(.l(1'b0), .c(q[i]), .r(q[i-1]), .n(q_next[i])); else relu110 u(.l(q[i+1]), .c(q[i]), .r(q[i-1]), .n(q_next[i])); endendgenerate 属性语法属性语法不直接影响模块的逻辑行为，但它们可以提供有关模块和其实例的信息，以帮助综合工具和其他工具正确处理设计。 12345// 告诉综合工具保留指定的信号或模块，即使它们似乎没有被使用, 方便进行调试查看(* KEEP=&quot;TRUE&quot;*)// 告诉综合工具不要修改指定的信号或模块，并且不要尝试进行优化。(* DONT_TOUCH=&quot;TRUE&quot;*) 函数12345678function integer func1(integer pa) begin // expresion // 这是返回值 func1 = //expression; endendfunction 常见技巧 变量索引与部分选择 part-select 即引用数组中一个元素的某几位。 例：reg [9:0] a[9:0] 引用第0个元素的后四位：a[0][0+:4] 或 a[0][3-:4]，其中 -:和+: 左边可以是常数或者变量，右边必须是常数。(这个会很有用，可以省很多时间写部分索引) 1’sb1表示 -1，1’sb0 表示 0 单纯的十进制数为 32bit interger 有符号数 ±运算赋值运算 所有操作数是有符号数，那么结果才是有符号数。 编程规范：总结verilog的编程规范，一共10条。 不要太多的 if—else 嵌套 不要编写过于庞大的状态机 复杂的状态机，可以采用 2 段式以上的实现 尽量使用时序逻辑完成编程 使用组合逻辑不要过于庞大 复杂代码拆分简单模块 复杂计算，增加流水设计 高速模块和低速模块搭配使用 case 语句一定有 default 组合逻辑有 if 必须有 else 防止产生锁存器，锁存器所以出毛刺","link":"/2022/03/17/Verilog%E5%9F%BA%E7%A1%80/"},{"title":"linux shell脚本基础","text":"备课😳，复习（预习）一下shell脚本的基本语法。 shell基本语法 shell脚本可以将完成一个任务的所有命令按照执行的先后顺序，自上而下地写入到一个文件，并给予执行权限。 脚本运行方法 赋予运行权限 使用bash执行 12345chmod +x demo.sh./demo.sh# 或者 bash demo1.sh shell常用符号12345678910111213141516~: # home 目录!: # 执行历史命令，!! 执行上一条命令$: # 变量取内容符，$USER+ - * / % # 加减乘除&amp;: # 后台运行*: # 通配符，匹配所有?: # 通配符，匹配除回车外的一个字符;: # 一行执行多个指令的时候用作分割|: # 管道符，将上一个命令的输出作为下一个命令的输入\\: # 转义字符``: # 反引号，在命令中执行命令，可类比于python中的exec()函数': # 单引号，shell中的字符串需要使用 单引号括起来，与双引号不同的是单引号不解释变量 '$USER'&quot;: # 双引号，脚本中出现的字符可以使用双引号括起来 &quot;$USER&quot; 会解释变量&gt;: # 输出重定向符 只用一个 &gt; 会覆盖文件 ，用两个 &gt;&gt; 会追加文件&lt;: # 输出重定向符，只用一个 就是只输入一次，两个 &lt;&lt; 就是追加输入（可以用于交互式的命令输入例如fdosk），使用 &lt;&lt;EOF表示结束书输入$?: # 通过上一个命令的 exit code判断上一条命令是否执行成功，为0则代表执行成功，否则为执行失败。expr 1 + 1 &amp;&gt;/dev/null; echo $?可以用分号分隔上一个命令，从而达到判断执行是否成功的作用 shell 数学运算shell中完成数学运算的方式有很多种 expr表达式 let表达式。 (())表达式 注意1：expr 表达式中运算符的前后必须要有空格 注意2：expr 表达式中使用乘运算符 * 时需要使用转义符 注意3：let 表达式中=前后不能有空格 1234567891011# expr 表达式expr 1 + 1expr 1 - 1expr 3 \\* 4expr 9 / 3expr 10 % 3# `let`可以完成同样的功能，但必须要一个变量缓存计算结果let sum=1+2# (()) 中对表达式没有要求,使用乘法时也不需要转义echo $((1+1))echo $((100 * 3)) 当运算中需要使用小数时，可以使用管道运算符|配合bc命令完成 （bc可能需要单独安装 ） bc中使用scale=n制定保留小数的位数 12345echo &quot;scale=2;100/3&quot;|bc# 上面的输出为 33.33echo &quot;当前内存占用为: `echo &quot;scale=2;100/3&quot;|bc`%&quot;# 当前内存占用为 33.33% shell退出exit code 的范围为8位，即0-255 123exit 0 # 表示正常退出echo $? # 查看上一条指令是否正常执行并退出 shell 输入输出read命令可以从终端读入内容 12345read acc # 将输出内容保存到 变量acc中read -s passwd # 输出内容保存到 passwd中，且输入的时候输入内容不回显,一般用于密码输入read -p &quot;这里是提示:&quot; abc #-p 指定输入时的提示read -n6 abc # 输入的长度只能为6read -t5 abc # 只能在 5s 内输入，超过时间后执行下一行 echo命令的作用是在显示器中输出一段提示文字。常用用法和参数如下 1234echo &quot;hello world!&quot; # 普通输出，输出后换行echo -n &quot;hello world!&quot; # 输出后不换行echo -e &quot;\\t abc&quot; # 输出字符串中包含有特殊的转义字符时使用 shell的变量变量的分类与定义语法shell中变量类型分为三种，其中本地和全局变量都属于环境变量。 本地变量：用户私有变量，只有本用户读取或修改，保存在.bash_profile和.bashrc文件中 全局变量：所有用户都可以使用，保存在/etc/profile和/etc/.bashrc中 用户自定义变量：用户自定变量，例如在脚本中定义的变量 变量名在定义时不需要加$，但是在使用的时候需要加$符号。 定义变量的格式为：变量名=值。将变量设置成全局变量的时候需要加上前缀 export 注意：变量名和等号之间不能有空格 12345678# 定义一个临时变量，在终端关闭或者重启之后该变量会被清除VAR1=1AGE=18# 手动清除一个变量unset VAR1# 定义一个全局变量export GENDER='MALE' 变量名最好全部写成大写以示区分 数组变量数组可以将一系列的内容保存到同一个变量中，在访问时通过下标进行访问。 定义数组：数组名称=(元素1 元素2 元素3 ….) 各个元素之间通过空格隔开。 数组的访问 : ${数组[下标]}， 下标从0开始 注意: bash 默认下标从0开始，但是zsh的下标默认从1开始 123456789101112# 单个赋值arr0[0]='abc'arr0[1]='def'arr1=('tom' 'jack' 'rose') # 连续赋值arr1=(`cat /etc/passwd`) # 将文件的行读入作为一个数组echo ${arr1[@]} # @ 符号代表数组所有的成员echo ${#arr1[@]} # 获取数组的长度echo ${!arr1[@]} # 打印数组的索引，备注:zsh不支持echo ${arr1[@]:1} # 切片，从1开始的元素echo ${arr1[@]:1:2} # 切片，从1开始访问两个元素 shell中的关联数组可以类比字典类型，可以自定义索引访问 123456789declare -A r_arr# 连续赋值r_arr=([name]='tom' [age]='18')# 或者单独赋值r_arr=([gender]='male')# 访问关联数组echo &quot;${r_arr[name]}&quot; 流程控制 常见的运算符号shell中没有 &gt;=,&lt;= 之类的判断符号，整数数学的比较运算运算符有下面这些 123456789-eq 等于-gt 大于-lt 小于-ge 大于或等于-le 小于或等于-ne 不等于# 用法test 1 -q 1;echo $? 常见的文件的判断运算符 123456-d 检查文件是否存在且为目录-e 检查文件是否存在-f 检查文件是否存在且为文件-r 检查文件是否存在且可读-w 检查文件是否存在且可写-x 检查文件是否存在且可执行 常见的字符串比较运算 1234567== 等于!= 不等于-n 检查字符串长度是否大于0-z 检查字符串长度是否为0# 用法test -z &quot;&quot;; echo $?test 'abc'=='bcd';echo $? 逻辑运算 123! 取反&amp;&amp; 逻辑与|| 逻辑或 if 语句if语句的格式如下，condition中可以使用前面所提到的逻辑运算符将条件连接起来 12345678910111213141516171819202122if [ condition ]then commandsfiif [ condition ]then commandselse commandsfiif [ condition ]then commandselif [ ] commandselse commandsfi 用法举例 1234567# 可以使用 $1 ，$2 等变量获取传入的命令行参数if [ $1 -eq $2 ]then echo &quot;等于&quot;else echo &quot;不等于&quot;fi for 循环语句第一种for语句的语法 1234567891011121314151617181920212223242526for var in value1 value2do commandsdone#例子,seq 是一个shell 命令，可以生成指定范围内的数字序列# 1 直接赋值for x in 1 2 3 4 5 6 7 8 9 do echo ${x}done# 2 使用 shell 命令赋值for var in `seq 1 9`do echo ${var}done# seq 的用法# seq [start] [step] [end]# seq [start] [end]# 3 可以直接用字符串赋值，使用 空格分隔for var in hello peter, i\\'m Doctor Octopus do echo $vardone 第二种for语句的语法, 类似于 C语言的写法 123456789for ((i=1;i&lt;10;i++)) do echo ${i}done# 可以由多个条件，condition 两边记得加空格for (( a=1,b=1;a&lt;100;a++,b++ )) do echo &quot;${a},${b}&quot;done while 和 until 循环while语句 123456789101112while conditiondo commanddone# 例子int=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done until语句 123456789101112until conditiondo commanddone# 用法a=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done case 语句当有多个分支时除了可以使用if elif ...这种结构还可以使用 case语句进行分支选择 1234567891011121314151617181920212223242526272829case value inpattern1) commands;;pattern2) commands;;...*） commands;;esac# 例子echo '输入 1 到 4 之间的数字:'echo '你输入的数字为:'read aNumcase $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;;esac 循环控制流程控制一般包含有 continue和break语句用于控制循环的执行 123456789101112while # 不加任何条件语句则表示死循环 do read a if [ a -eq 0] then break elif [ a -eq 1 ] continue else echo &quot;your number is ${a}&quot; fidone shell函数 定义函数的语法有两种,分别为 123456789101112131415161718192021# 语法一func_name (){ commands return N}# 语法二function func_name (){ commands return N}# 函数参数例子function hell0_func (){ echo &quot;hello $1&quot; # $1 代表第一个函数参数，$0是当前的脚本文件名}$# # 函数的参数个数$? # 最后一个命令的退出状态，为 0 表示没有错误 调用函数的方法比较奇怪，不需要加(),需要传参的话直接写在后面就可以了 123456789101112131415# 函数传参的例子hello_func alex # 带返回值函数调用的例子funWithReturn(){ echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))}funWithReturnecho &quot;输入的两个数字之和为 $? !&quot;","link":"/2022/04/10/linux-shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"title":"makefile基础","text":"继续备课，复习makefile的基础知识 Makefile 是由 make 命令引用的文本文件，它描述了目标的构建方式，并包含诸如源文件级依赖关系以及构建顺序依赖关系之类的信息。 makefile基本结构makefile的基本结构包括三个部分 12target ... : prerequisites ... [TAB]command target 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label） prerequisites 生成该target所依赖的文件或target command 生成target需要执行的命令，一般为shell命令，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 注意：command前面的TAB是必须的 makefile基本示例首先在一个目录下新建,main.c,func1.c,func1.h三个文件。其中main.c文件依赖于func1.c文件中的func1函数。在目录中新建一个makefile，写入如下内容。 12345678all: main.o func1.o gcc -o main1 func1.o main.omain.o: main.c gcc -c main.cfunc1.o: func1.c func1.h gcc -c func1.cclean: rm -rf *.o 在终端cd进入目录之后，执行make命令就可以将直接编译出可执行文件main1。 也可以手动执行make all指令指定生成，当没有为make指定生成的target 时，则默认选择第一个target。 使用 make clean可以删除编译中生成的.o结尾的中间文件。 makefile中的变量可以看到虽然上一节中使用makefile简化了编译所输入的命令，但是所编写的 makefile中含有很多 .o结尾的prerequisites，当所依赖的文件过多时，makefile就会变的非常复杂，为了进一步简化书写，可以使用变量简化makefile。 123456789101112objects = main.o kbd.o command.o all : $(objects) gcc -o edit $(objects)main.o : main.c defs.h gcc -c main.ckbd.o : kbd.c defs.h command.h gcc -c kbd.ccommand.o : command.c defs.h command.h gcc -c command.cclean : rm edit $(objects)","link":"/2022/04/11/makefile%E5%9F%BA%E7%A1%80/"},{"title":"pandas教程","text":"这是很久之前在Kaggle上学的，写了一些笔记，但还少一篇比较全面的总结，这篇文章相当于补上了。 DataFrameDataFrame是pandas里面最基本的数据结构和操作单元，pandas所有的操作都是围绕它来进行的。DataFrame可以理解为一个类似于Excel的多维的数据表，可以存储并操作表格型的数据。 df.index代表的是行编号 df.columns代表的是列编号 新建DataFrame新建 DataFrame的方式一般有以下几种： 通过一维的list或者numpy.ndarrys创建 123456# 一维data = [1,2,3,4,5]df = pd.DataFrame(data) #输出是一列# 二维data = [['Alex',10],['Bob',12],['Clarke',13]]df = pd.DataFrame(data,columns=['Name','Age']) #可以指定列名 通过字典创建 12345# 两列元素的长度需要相同data = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]} df = pd.DataFrame(data) # 这里默认的 index 就是 range(n)，n 是列表的长度# 可以指定行的名称df = pd.DataFrame(data, index=['rank1','rank2','rank3','rank4']) 通过Series pd.Series 可以表示 dataframe中的一列，可以将pd.Series组成一个字典或者列表再初始化得到一个dataframe 1234d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}# one 列的最后一行会补全为 NaNdf = pd.DataFrame(d) 常用属性dataframe有很多非常有用的属性，可以快速地分析一个表格数据，这里分别列举出来 12345df1.describe() # 计算数据中的数值型的一些常见统计信息(以列为单位)df1.index # 返回 行索引df1.columns # 返回列索引df1.values # 返回所有的值，以array的形式df1.T #返回 转置结果 常用方法使用panda提供的方法可以非常快速地对表格进行操作 假设我们有这样一个表格 12date_index=pd.date_range('20211020', periods=5)df1 = pd.DataFrame(np.random.randn(5, 3), index=date_index, columns=['a', 'b', 'c']) 按照列方向进行排序 1df1.sort_index(axis=1, ascending=False) 按照某个列的值进行排序 1df1.sort_values(by='a', ascending=False) 数据访问对表中的某个元素进行访问也是一个常用的操作，pandas提供了多种方式完成这个操作 df.loc以标签的形式访问 df.iloc使用整数索引进行访问","link":"/2022/03/29/pandas%E6%95%99%E7%A8%8B/"},{"title":"pthread并行程序开发基础","text":"备课，复习 pthread 的使用，内容包括pthread 的基础知识以及并发所需要的PV操作 前言POSIX Threads（Portable Operating System Interface）, commonly known as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API. 是一种独立于编程语言的程序并行运行模型 控制程序的并行工作流（线程） 准备工作在编写pthread程序的第一步就是导入头文件 123#include &lt;pthread.h&gt; // pthread api#include &lt;unistd.h&gt; // posix system 中通用的api#include &lt;semaphore.h&gt; // 信号量操作相关 使用 gcc 编译的时候需要加上 -lpthread参数 1gcc demo1.c -lpthread -o demo1 进程创建进程创建可以使用以下函数 1int pthread_create (pthread_t *thread_id,pthread_attr_t *attr,void *(*start_routine)(void *),void *arg) thread_id是进程的唯一标识符 attr_t 设置进程的属性，可以设置想进程的调度策略，堆栈相关信息，可以设置为默认值 NULL start_routine是线程开始运行的函数指针，函数指针的原型包括一个void类型的形参指针 arg设置线程运行时传递的参数，可以在线程开始运行时传递用户自定义参数 在进程运行过程中可以使用pthread_self获取当前线程的标识符。 1pthread_t tid = pthread_self(); 结束进程当一个进程可以通过return 或者 pthread_exit()方式结束自身的运行。 一个线程结束，只是说它结束了运行状态，但是并不意味着它的所有信息都已经消失。 可以通过 调用 pthread_cancel函数结束其他进程，但前提是需要获得需要结束进程的进程标识符。 1pthread_cancel(pthread_t) 进程同步进程同步算是OS 里面比较重要的内容了，pthread提供了很多 API 供我们使用。 pthread_join(pthread_t tid, void* revalue)可以阻塞当前线程并等待一个线程运行完毕再重新运行该进程。revalue是进程运行结束所返回的结果。 mutex为了解决多个线程同时访问同一个内存问题，常用的mutex互斥锁方式可以通过定义一个pthread_mutex_t变量解决，它的使用方式如下。 1234567891011121314151617181920212223242526pthread_mutex_t buff_mutex;int count = 0;void* thread1(void* arg){ pthread_mutex_lock(&amp;buff_mutex); // 访问内存 buff_count++; pthread_mutex_unlock(&amp;buff_mutex);}void* thread2(void* arg){ pthread_mutex_lock(&amp;buff_mutex); // 访问内存 buff_count--; pthread_mutex_unlock(&amp;buff_mutex);}void main(void){ pthread_mutex_init(&amp;buff_mutex, NULL); pthread_mutex_destroy(&amp;buff_mutex); pthread_mutex_destroy(&amp;buff_mutex); // 使用完成后需要销毁 return 0;} 在使用之前需要先调用 pthread_mutex_init初始化，当某个线程需要访问临界区时，使用 pthread_mutex_lock(&amp;count_mutex);进入临界区，结束访问临界区后使用 pthread_mutex_unlock(&amp;count_mutex)退出临界区访问。mutex使用完成后需要调用 pthread_mutex_destroy将mutex销毁。 semaphore理论上mutex 可以当做一个 semaphore=1的信号量使用，在一定程度上两者是等价的,Mutex管理的是资源的访问，而Semaphore管理的是资源的数量。 信号量可以根据资源的数量控制进程的访问。例如著名的生产者消费者问题，假设缓冲区数量为N 当缓冲区中的资源数目小于N，生产者就可以不断生产，但当生产的资源数等于N，生产者就要停止生产，并等待消费者进行消费。 当缓冲区中资源的数目大于N，消费者就可以不断消费直到资源的数目等于0，消费者就要阻塞直到生产者生产出货物。 Linux中可以使用semaphore.h头文件中提供的API 完成PV线程同步操作。下面的代码就是实现生产者消费者问题的代码。其中sem_t定义了一个信号量，定义信号量后调用 sem_init()初始化信号量的值。 sem_wait()相当于 P操作，sem_post()相当于V操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//生产者消费者问题#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;pthread_mutex_t buff_mutex; // 创建一个互斥锁int buff_count = 0;int buff[10];sem_t empty, full; // 声明信号量// 消费者线程void *consumer(void* arg){ for (;;) { sem_wait(&amp;full); // P(full) pthread_mutex_lock(&amp;buff_mutex); buff[buff_count] = 0; buff_count--; printf(&quot;[consumer thread] buffer count %d&quot;, buff_count); // 打印当前的缓冲区信息 pthread_mutex_unlock(&amp;buff_mutex); sem_post(&amp;empty); // V(empty) sleep(2); //假设每次消费需要 2 秒 } return 0; }// 生产者线程void *producer(void* arg){ for (;;) { sem_wait(&amp;empty); // P(empty) pthread_mutex_lock(&amp;buff_mutex); // 进入临界区 buff[buff_count] = 1; buff_count++; printf(&quot;[consumer thread] buffer count %d&quot;, buff_count); // 打印当前的缓冲区信息 pthread_mutex_unlock(&amp;buff_mutex); // 退出临界区 sem_post(&amp;full); //v(full) sleep(3); // 假设每次生成需要 3 秒 } return 0;}int main(void){ pthread_t p_id, c_id; pthread_mutex_init(&amp;buff_mutex, NULL); // 初始化互斥锁 sem_init(&amp;empty, 0, 10); // 初始化，第三个参数为信号量初值 sem_init(&amp;full, 0, 0); pthread_create(&amp;p_id, NULL, producer, NULL); // 创建生产者和消费者线程 pthread_create(&amp;c_id, NULL, consumer, NULL); pthread_join(p_id, NULL); // 阻塞当前线程，等待生产者和消费者线程执行完毕 pthread_join(c_id, NULL); pthread_mutex_destroy(&amp;buff_mutex); // 使用完后需要销毁 sem_destroy(&amp;empty); //销毁信号量 sem_destroy(&amp;full); return 0;}","link":"/2022/04/23/pthread%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"title":"pytorch的张量扩展机制","text":"复现华为2020年的论文AdderNet,在编码过程中涉及到了pytorch中张量的扩展机制，这里记录一下踩到的坑。 张量扩展机制Pytorch中的大部分算术操作都是支持维度扩展的：即使两个张量的维度不相等，但只要两个张量的维度满足一定的条件，在进行运算时python会自动对这两个张量的数据进行扩展，使它们的维度相等，扩展后再进行加减操作。例如： 123a=torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]]) # size= 1 x 2 x3b=torch.tensor([[1.0,2.0,3.0]]) # size= 1 x 3a - b 得出的结果是 123tensor([[[0., 0., 0.], [3., 3., 3.]]]) # size= 1 x 2 x 3 两个张量需要满足的条件为： 每个张量至少含有一个维度 在对张量进行迭代运算时，会从最末尾的维度对齐后开始迭代，迭代到某一个维度时，两个张量此时的维度必须以下的三个条件之一： 相等 有一个维度为1 有一个张量此时的维度不存在 例如： 123456789101112131415161718x=torch.randn(5,3,4,1)y=torch.randn( 3,1,1)# 1 =&gt; 1 满足条件# 4 =&gt; 1 满足条件# 3 =&gt; 3 满足条件# 5 =&gt; None 满足条件# 此时就可以执行z = x - y# 反例x=torch.empty(5,2,4,1)y=torch.empty( 3,1,1)# 1 =&gt; 1 满足条件# 4 =&gt; 1 满足条件# 2 =&gt; 3 不满足条件# 5 =&gt; None 满足条件# 此时执行下面的代码就会报错z = x - y 张量扩展后的运算规则如果两个张量满足了维度扩展的条件(broadcastable)，通过运算得到的结果的尺寸为 如果x和y的维数不相等，在维数较少的张量的维数上预加1，使其长度相等 （对应第三种情况） 对于每个维度的大小，所产生的维度大小是沿该维度的x和y的大小的最大值。","link":"/2022/09/13/pytorch%E7%9A%84%E5%BC%A0%E9%87%8F%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"},{"title":"tmux使用总结","text":"tmux（终端复用器）是连接SSH远程连接服务器时比较常用的工具。本文记录它的常用使用方法。 前言tmux is an open-source terminal multiplexer for Unix-like operating systems. It allows multiple terminal sessions to be accessed simultaneously in a single window. It is useful for running more than one command-line program at the same time. It can also be used to detach processes from their controlling terminals, allowing remote sessions to remain active without being visible. tmux具有的特点有： 可以在一个窗口同时访问多个终端对话 每个会话都可以detach在后台运行 tmux的控制层次分为三个部分，从上到下为依次包含的关系。 sessions windows panel 一个session可以包含多个window一个window可以切分成若干个panel。这里盗用一张图 安装完tmux之后，直接在终端里面输入 tmux就可以出现上面这个界面了 基本用法session的相关操作， 1234567891011121314151617181920# 直接输入 tmux 默认创建一个 新的 sessiontmux# 创建一个指定名字的session，注意这里的 session_name 不需要双引号tmux new -s session_name# detach session 将当前会话转到后台运行，或者使用 快捷键 &lt;CTRL&gt;+B dtmux detach # 恢复连接一个会话tmux a -t session_name# 查看当前tmux 的所有会话tmux ls # 退出一个 sessiontmux kill-session -t session_name# 退出服务/ 关闭所有 sessiontmux kill-server 如果当前处在一个 session 中可以使用快捷键 &lt;CTRL&gt;+B s 进入会话选择界面，通过方向键或者hjkl选择需要进入的会话，按下ENTER进入。 session操作快捷键总结： tmux中所有的命令都需要前缀按键，即&lt;CTRL&gt;-B，命令基本就下面这两个就够用了。 快捷键 命令描述 s 显示当前的会话列表，用于选择切换 d 将当前会话转到后台运行 window操作快捷键总结： 快捷键 命令描述 w 显示所有会话中的窗口列表 c 在当前会话中新建一个窗口 &amp; 删除当前窗口,需要 y/n 确认 p 切换到上一个窗口 n 切换到下一个窗口 panel操作快捷键总结 panel就是第一个图那里，将一个window划分为多个区域，每个区域就称为一个panel 快捷键 命令描述 % 横向等分当前区域为两个panel “ 纵向等分当前区域为两个panel x 关闭当前面板,需要 y/n确认 方向键 切换当前panel 的交点 Alt+方向键 调整当前Panel的长宽等 q 显示当前面板的编号，通过按下数字键完成切换 z 将当前面包最大化，再进行一个则恢复原样 如果划分了很多panel, 希望panel 可以水平或者垂直均匀分布，可以使用以下快捷键 快捷键 命令描述 Alt + 1 将所有panel 水平均匀分布 Alt + 2 将所有panel 垂直均匀分布","link":"/2022/04/28/tmux%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"tqdm常用方法总结","text":"tqdm可以非常方便地在控制台或者jupyter notebook上面显示一个进度条,通过进度条我们可以很方便地观察当前运行任务的进度，处理速度等信息。 基本使用如果任务是需要遍历一个List或者其他的一些可以迭代的对象，可以直接将tqdm()包裹到可迭代对象上面上再通过for循环就可以在控制台显示出当前循环进行的进度条了。 123456789101112from tqdm import tqdmfor char in tqdm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]): text = text + char for i in tqdm(range(100)) print(i) # 如果只是需要range，还可以直接使用trange()函数直接代替rangefor i in trange(100): print(i) 自定义显示信息因为tqdm中实现了__enter__()和__exit__()两个方法，所以可以直接使用with表达式获取到 tqdm对象 12345from tqdm import tqdm # 可以在初始化的时候设置进度条相应的参数with tqdm(total, ncols=100, position=0) as pbar: pbar.set_description(f&quot;description&quot;) # 也可以在 with 范围内 使用 set_xxxx 实时设置进度条的参数 如果不想用 with多嵌套一层代码，特别是想显示多个进度条，使用多个with就会显得很不优雅，其实with主要是为了控制变量的作用范围，tqdm本身是可以直接当做对象进行初始化的。 12345678910111213_tqdm = tqdm(total=100, ncols=100, position=0, leave=False,colour='red') # 设置进度条显示到第0行_tqdm1 = tqdm(total=1000, ncols=100, position=1, colour='green') # 设置进度条显示到第1行，保证两个进度条错开for x in range(100): _tqdm.set_description(f&quot;epoch {x}&quot;) # 进度条前面显示的东西 _tqdm.update(1) # 这里控制每次增加 1 _tqdm.set_postfix(epoch=f&quot;{x}&quot;) # 进度条后面显示的信息输入参数是字典 for y in range(1000): _tqdm1.update(1) _tqdm1.set_postfix(epoch=f&quot;{y}&quot;) sleep(0.01) _tqdm1.n = 0 # 直接设置当前进度条的值 _tqdm1.refresh() # 更新完 n 后记得 refresh一下显示 tqdm的常见属性为: 属性 使用方法 n 可以直接设置当前进度条的进度，pbar.n = 80，设置完之后 需要调用*pbar.refrash()*刷新显示 total 进度条的总长度， n &lt;= total ncols 进度条显示的宽度，应该是以字符长度为单位 description 进度条前面显示的信息 postfix 进度条后面显示的信息 colour 设置进度条显示的颜色，可以使用pbar.colour = ‘green’ position 进度条显示在第几行 leave 如果设置为False或者None则最运行完成后，进度条显示为 0，否则进度条就会隐藏 tqdm与print混用问题如果在显示进度条的同时还需要调用print打印一些调试信息，直接混用的话，进度条的显示会分为多行显示，打印的信息也会显得很混乱。就类似于下面这样 为了解决这个问题，这里参照了这篇帖子，可以使用tqdm.write()代替print输出信息。最后的效果这样 注意：tqdm.write()只能接受 字符串类型的数据输出","link":"/2022/04/27/tqdm%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"verilog编程规范","text":"参考华为内部的verilog编程规范，总结自己的代码风格。 设计风格内容包括变量（信号）命名规范，模块命名规范等 信号与常量 对低电平有效的信号，信号名后缀“_n” 使用降序排列的定义向量有效位顺序，最低为是0 使用大写字母定义parameter,使用小写字母定义 input，reg，output等信号的命名 时钟信号统一使用前缀 “clk”，复位信号统一使用前缀 “rst” 模块 模块的命名全部小写 到其他模块的信号声明顺序按照 : 输入、（双向）、输出 每个模块只包含一个模块，模块名称与文件名保持一致 在调用模块时，使用name_based的方式进行调用而不是order_based的方式进行调用 模块例化统一使用 “U_name_i”，进行命名，如果多次例化，则i使用数字编号 可靠性在模块设计时遵守以下原则： 同步时序逻辑块always块中有且只有一个使用信号，并且在同一个沿做出动作 不要在时钟信号路径上添加任何buffer 不要采取向量的方式定义一组时钟信号 一个always语句中只能有一个事件列表 时序逻辑电路中统一使用非阻塞赋值方式 组合逻辑电路中统一使用阻塞赋值方式","link":"/2022/09/19/verilog-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"title":"verilog代码模板","text":"从培训机构学习的关于Verilog编程的一些规范。 计数器代码计数器代码设计规则： 计数器逐一考虑三要素：初值、加1条件、结束值 计数初值必须为0 使用某一计数值，必须同时满足加1条件 结束条件必须满足加1条件，且结束值必须是 $x -1$的形式 当取某个数时，assign形式必须为：（加1条件） &amp;&amp; (cnt == 计数值 -1) 计数器计数结束后必须回到 0 设置限定范围使用 $&gt;=$和$&lt;$两种符号 设计步骤是：先写计数器的always段，条件用名字判断；用 assign写出 加1条件；最后用 assign 写出结束条件 加1条件必须与计数器严格对其，其他信号一律向计数器对齐 计数器的命名规范：加1条件的前缀必须以 add_开头，结束计数条件必须以end_开头 123456789101112131415161718reg[7:0] cnt;wire add_cnt, end_cnt; // 加1条件和结束条件always @(posedge clk or negedge reset_n) begin if (!reset_n) begin cnt &lt;= 8'd0; end else if (add_cnt) begin if (end_cnt) cnt &lt;= 8'd0; else cnt &lt;= cnt + 8'd1; endendassign add_cnt = a == 2; // 开始计数的条件assign end_cnt = add_cnt &amp;&amp; cnt == 10 - 1;","link":"/2023/03/13/verilog%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"},{"title":"verilog状态机基础","text":"学习verilog状态机的的几种常见写法。 有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。有限状态机被用于描述电路的状态变化。 状态机概览状态机可分为两类： Mealy 状态机： 状态机的输出和当前状态和输入相关 Moore状态机： 状态机的输出只和当前状态相关。 状态机的4个要素现态、条件、动作、次态。其中“现态”和“条件”作为产生”次态“和”动作“的原因。 现态：是指当前所处的状态 条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移 动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。 次态：条件满足后要迁往的新状态。次态一旦被激活，就会转变成现态。 在实现过程中需要注意的问题： 区分”状态“与”动作“：动作时改变后所做出的动作，一般动作执行结束后不会一致保持，但是状态会一直保持，直到下一个状态的改变。 状态机的描述方法分为3种： 一段式状态机 二段式状态机 三段式状态机 四段式状态机 一段式状态机在描述比较简单的逻辑转换关系时可以直接使用一段式状态机，一段式状态机的特征是只有一个always的时序逻辑块，状态转移，以及输出的变化都在该always块中进行更改。一段式状态机在软件开发中使用的比较多的，但是在硬件描述中则不是非常推荐。 注意： 在声明状态常量时使用localparam关键字进行声明而不是 parameter，这样可以避免Vivado的综合工具报警告 1234567891011121314151617181920212223242526272829303132333435363738394041424344module m1( input clk_i, input rst_n_i; output out_o); reg[1:0] state; // 表示状态的常量声明，在实际工程中需要对状态名称进行更准确的描述。 localparam [1:0] S0 = 2'b00; localparam [1:0] S1 = 2'b01; localparam [1:0] S2 = 2'b10; localparam [1:0] S3 = 2'b11; always @(posedge clk_i) begin if (!rst_i) begin state &lt;= 2'd0; out_o &lt;= 1'b0; end else begin // 使用 case 语句描述状态的变化以及输出的变换 case (state) s0: begin out_r &lt;=1'b0; state &lt;= S1; end S2: begin out_r &lt;=1'b1; state &lt;= S3; end S3: begin out_r &lt;=1'b0; state &lt;= S4; end S4: begin out_r &lt;=1'b1; state &lt;= S3; end endcase end end assign out_o = out_r; endmodule 二段式状态机两段式状态机的特征是采用两个 always 模块实现状态机的功能，其中一个 always 采用同步时序逻辑描述状态转移，另一个 always 采用组合逻辑来判断状态条件转移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546module m1( input clk_i, input rst_n_i; output out_o); reg[1:0] current_state; reg[1:0] next_state; // 表示状态的常量声明，在实际工程中需要对状态名称进行更准确的描述。 localparam [1:0] S0 = 2'b00; localparam [1:0] S1 = 2'b01; localparam [1:0] S2 = 2'b10; localparam [1:0] S3 = 2'b11; // 描述状态的转换 always @(posedge clk_i) begin if(!rst_n_i) Current_state&lt;=0; else Current_state&lt;=next_state; end // 描述下一个状态的转换以及输出的变换 always @(*) begin case (state) s0: begin out_r =1'b0; next_state = S1; end S2: begin out_r =1'b1; next_state = S3; end S3: begin out_r =1'b0; next_state = S4; end S4: begin out_r =1'b1; next_state = S3; end endcase end assign out_o = out_r; endmodule 三段式状态机三段式状态机的特征是在第一个 always 模块采用同步时序逻辑方式描述状态转移，第二个 always 采用组合逻辑方式描述状态转移规律，第三个 always 采用组合逻辑方式描述电路的输出。这种状态机的组合逻辑与时序逻辑完全独立。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module m1( input clk_i, input rst_n_i; output out_o); reg[1:0] current_state; reg[1:0] next_state; // 表示状态的常量声明，在实际工程中需要对状态名称进行更准确的描述。 localparam [1:0] S0 = 2'b00; localparam [1:0] S1 = 2'b01; localparam [1:0] S2 = 2'b10; localparam [1:0] S3 = 2'b11; // 改变当前电路的状态, 这一段一般不用变化 always @(posedge clk_i) begin if(!rst_n_i) Current_state&lt;=0; else Current_state&lt;=next_state; end // 描述状态的转换 always @(*) begin case (Current_state) s0: begin next_state = S1; end S2: begin next_state = S3; end S3: begin next_state = S4; end S4: begin next_state = S3; end default : next_state = S0; endcase end // 描述电路输出 always @(*) begin case (Current_state) S0, S1, S2: out_r = 1'b1; S3, S4: out_r = 1'b0; default: out_r=out_r; endcase end assign out_o = out_r; endmodule 四段式状态机四段式状态机是在三段式状态机的基础上进行的修改，可以更加清晰地分离状态变化以及输出，并且可以避免写出 state_c &lt;= state_c之类的代码，避免生成锁存器，它包含四个部分： 状态信息的声明： 1234localparam IDLE = 4'd0;localparam S1 = 4'd1;localparam S2 = 4'd2;localparam S3 = 4'd3; 时序逻辑部分，该部分的内容在所有代码中都不需要改变，格式化地描述现态和次态的转换。 123456789reg[3:0] state_c; // 当前的状态寄存器reg[3:0] state_n; // 下一个状态always @(posedge clk_sys or negedge rst_n) begin if (!rst_n) state_c &lt;= IDLE; else state_c &lt;= state_n;end 组合逻辑部分，该部分代码描述状态转移的条件： 1234567891011121314151617181920212223242526272829always @(*) begin case (state_c) IDLE: begin if (c_idle_s1) state_n = S1; else state_n = state_c; // 避免生成锁存器 end S1: begin if (c_s1_s2) state_n = S2; else state_n = state_c; end S2: begin if (c_s2_s3) state_n = S3; else state_n = state_c; end IDLE: begin if (c_s3_idle) state_n = IDLE; else state_n = state_c; end endcase end 组合逻辑部分，定义状态转移的信号。注意条件命名规范： c_现态_次态。 1234assign c_idle_d1 = state_c == IDLE &amp;&amp; 转移条件;assign c_s1_s2 = state_c == S1 &amp;&amp; 转移条件;assign c_s2_s3 = state_c == S2 &amp;&amp; 转移条件;assign c_s3_idle = state_c == S3 &amp;&amp; 转移条件; 设计输出信号，此部分不限于使用时序逻辑还是组合逻辑进行描述，只需要清晰就可以了。 一般一个 always 语句只控制一个信号，有多少个输出信号就有多少个always 块 123456789101112always @(posedge clk_sys or negedge rst_n) begin if (!rst_n) out1 &lt;= 1'b0; else begin case (state_c) IDLE, S1, S2: out1 &lt;= 1'b0; S3 : out1 &lt;= 1'b1; default : out1 &lt;= 1'b0; endcase end end 使用组合逻辑的分支判断的时候，每个分支只能造成一个变量发生改变，且保证每个分支中都在改变这个变量，否则，就会综合出锁存器电路。 其他除了可以使用 localparam 定义参数外还可以使用 typedef定义状态的名称 123456// 状态定义typedef enum { STATE_IDLE, STATE_A, STATE_B} state_t;","link":"/2022/09/10/verilog%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"title":"vim高效编辑","text":"复习编辑器之神Vim, 顺便立个Flag，以后的verilog都使用Vim进行编写。 🙌 选择与替换选择块内容：如果使用的是GVim，可以直接使用 鼠标进行拖动，GVim会自动进入Visual Mode。如果在拖动鼠标的同时按住键盘的Alt键，Vim就会进入Visual-Block模式，在这个模式下可以进行块选择。 1234567&quot; 快速选择段落内容vip&quot; 选择 { ( [ 的内容vi(&quot; 选取上一次选择的区域, 正常模式下gv 在Visual-Mode中选择需要的内容后就可以使用d x y p等命令对选中的内容进行相关操作。 搜索关键字：当需要在Vim中搜索关键字时，在normal mode下使用/name 进行搜索。 搜索时可以连接标识符，指定搜索的范围，是否大小写敏感等。具体表示符如下： /g 表示在全局范围内进行操作 /c 表示在替换操作时需要进行确认 /I表示需要在搜索时对关键字的大小写敏感 指定搜索范围： :% 代表整个文件 : i, j搜索范围是 第 i 到 j行 :.,+x搜索范围是从当前行和接下来的两行 搜索关键字的一个重要作用就是在/前面加上s，就可以进行关键字的搜索替换，具体格式为:s/name/new_name 例如，在写testbench的时候需要从原模块中复制输入输出的定义后将input替换为reg，将output替换为wire类型。可以使用如下命令进行修改替换： 1234567891011121314&quot; 全局范围内进行搜索 input 替换为 reg，% 代表整个文件，g 代表全局范围内，c代表在替换时需要进行逐项确认:%s/input/reg/gc &quot; 在 i，j 行之间进行搜索替换:i,js/input/reg/gc&quot; 在选中的内容中进行搜索替换:&lt;,'&gt;s/input/reg&quot; 从当前行开始，向下两行的范围内进行搜索替换，点代表当前行:.,+2/s/input/reg&quot; 在全局范围内对已经选择（搜索）到的关键字进行替换:%s//new_name/gc 在搜索完成后可以使用noh取消搜索结果的高亮显示。 批量操作在多行添加内容：在例化代码模块时，可以快速从源文件中将模块复制过来并将参数名统一添加.和括号()。 在列选择模式下选择第一列，按下 I，输入需要插入的内容后，按下&lt;ESC&gt;键后就可以完成批量添加。下面就是将module改为例化模块的方法。 宏功能宏功能可以将需要重复执行的动作记录下来，然后批量执行。 命令 模式 说明 qx Normal Mode 录制宏 到 x，x可以是 abcde…等等 q Normal Mode 停止录制 @x Normal Mode 运行宏，可以在按之前输出数字指定重复执行的次数 快速对齐使用Vim-Plug安装Easy-Align插件，并在.vimrc里面加上 12xmap ga &lt;Plug&gt;(EasyAlign)nmap ga &lt;Plug&gt;(EasyAlign) 配置好后再Visual-Mode下选择需要对齐的代码，按下 ga+ 标识符就可以快速对齐代码了。 例如需要对齐一些localparam的声明，再使用鼠标选择之后，按下ga+ ** + &lt;SPACE&gt;就可以快速以空格为中心将代码进行对齐。 可以在输入对齐字符之前按下&lt;Left&gt; 或者&lt;Right&gt;选择左对齐或者右对齐。 快速移动单词之间的移动在Vim中使用光标移动到一个单词后，在Normal Mode下按下*，Vim就会自动高亮所有匹配的单词，再次按下*，指针就会跳转到下一个一样的单词，按下#可以跳转到上一个单词。 使用~~可以跳转到上一个编辑的位置。 ! 注意：这里是~~，~代表对的单词的大小写进行替换。 配对括号之间的跳转在一个括号上按下 %可以快速跳转到它匹配的另一半的位置。 文件内跳转123456&quot; n 为行数:n&quot; 跳转到文件头gg&quot; 跳转到文件尾G 行内的跳转12345678910111213&quot; 下一个单词的第一个字母w &quot; 上一个单词的第一个字母b&quot; 当前单词的最后一个字母，如果已经在最后一个字母，则会跳转到下一个单词的最后一个字母e&quot; 上一个单词的最后一个字母ge&quot; 跳转到行首0&quot; 跳转到行尾$ Easy-Motion插件使用Vim-Plug安装Easy-Motion插件，并在.vimrc里面加上 1nmap s &lt;Plug&gt;(easymotion-overwin-f2) 在Normal-Mode中按下s并输入想要跳转到地方的头两个单词，并按下屏幕中提示的字符就可以将指针快速地移动到指定为位置。 例如我当前的光标再else的位置，我想快速跳转到 clk_baud位置处。在Normal Mode下按下 scl，并根据提示按下s键，光标就跳转到了指定的位置。 代码折叠可以设置折叠的模式，这里直接设置为marker模式，且折叠标记设置为//BEGIN和//END。 12:set foldmethod=marker:set foldmarker=//BEGIN,//END 命令 模式 说明 zc Normal Mode 折叠当前块 zo Normal Mode 展开当前块 zC Normal Mode 折叠所有可以折叠的块 zO Normal Mode 展开所有可以折叠的块 不常用操作 命令 模式 说明 CTRL-O Normal Mode 打开上一个最近打开的文件 CTRL-I Normal Mode 打开下一个最近打开的文件 Ctrl-u Normal Mode 向下移动半个屏幕 Ctrl-d Normal Mode 向上移动半个屏幕 分屏操作 命令 模式 说明 :vs Normal Mode 横向拆分窗口 :sp Normal Mode 纵向拆分窗口 C-w w h j k l Normal Mode 切换当前窗口，w 是循环切换 C-w q Normal Mode 关闭当前窗口 Buffer操作 命令 模式 说明 :ls Normal Mode 列出当前所有打开的文件 :bn Normal Mode 跳转到下一个编辑文件 :bp Normal Mode 跳转到上一个打开的编辑文件 其他使用--cmd 可以在shell里面调用vim的命令，从而和shell 进行结合并自动化完成某些操作 1vim --cmd PluginInstall","link":"/2022/09/23/vim%E9%AB%98%E6%95%88%E7%BC%96%E8%BE%91/"},{"title":"使用Github Actions 自动化部署 Hexo","text":"用hexo搭建个人博客并使用github action自动进行部署 前言之前立的每天写点东西的Flag感觉都差不多遗忘了，注册的博客园感觉也不好玩，默认的界面太丑了，写东西都没感觉（好吧，这是借口）。觉得还是搭建自己的博客比较Geek 一点，自己DIY也比较方便（就是想折腾）。 准备工作 新建一个&lt;username&gt;.github.io的Github仓库。 新建一个Blog 的私有仓库用于保存Blog 源代码 在本地安装 Node.js 本地初始化Hexo安装完Node.js后 1234567# 安装 hexo$ npm install hexo-cli -g # hexo 初始化$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install Hexo 的配置因为 Github的限制，所以在访问仓库时需要设置 Taken。 Token 获取步骤 ：依次选择，下面的选项，创建一个Token。 Account -&gt; settings -&gt; Developer settings -&gt; Personal access tokens ==创建时记得勾选全部权限== 1234567891011121314title: Jiaming's Blogsubtitle: '写点啥'description: '希望坚持每天都写点啥'# 设置主题theme: keep# 设置推送选项deploy: type: git repo: github: url: git@github.com:jiamingyy/jiamingyy.github.io.git branch: master taken: &lt;personel access token&gt; 设置完 deploy 之后，就可以通过hexo d 命令发布网页到github了。 Hexo 的常用操作如下。 12345678$ hexo g # 编译生成发布文件$ hexo s # 开启本地服务器预览$ hexo new &lt;post&gt; &quot;title&quot; # 新建一个文章# 新建一个页面，类似于 About me 的功能，新建之后可以在相应的主题config中进行开启$ hexo new page &quot;title&quot; $ hexo d # 部署 使用Github Actions 自动部署为了可以在多台设备上随时进行写作和同步，我们可以利用 Github 提供的Actions 服务自动化对博客进行部署。也可以省去我们在本地配置环境的时间，专注于写作。当我们写了新的文章，只需要将Blog 的源代码推送到Github 的 Blog 仓库，Github actions 就可以在直接云端执行 hexo g、hexo d这些操作，自动帮我们部署到page中。 在开始配置之前需要确定以下事情： 本地Blog部署生成和部署正常 Blog 仓库已经创建完毕 在所有事情完成后，第一步，先在本地创建访问RSA密匙，使用命令： 1$ ssh-keygen -t rsa -C &quot;这里面可以随便写&quot; 创建完成后可以得到 id_rsa 和 id_rsa.pub两个文件，分别为私钥和公钥文件。 将id_rsa.pub的内容复制到 &lt;username&gt;.github.io的Settings中的 Deploy keys. Keys的名称可以随便写。 接下来配置 Blog仓库，也就是存放我们Blog 源代码的仓库。在Settings -&gt; Secrets -&gt; Actions 中点击 New repository secret , 将id_rsa文件中的内容复制到里面。==注意名称命名为 DEPLOY_KEY== 在配置完Secret Key 之后点击进入 Blog 的 Actions 界面。选择New workflow。添加如下内容。==注意参数中的deploy_key = $==这个也就是我们刚刚设置的Secret Key 的名称。代码更新的内容可参照hexo actions。 123456789101112131415161718192021222324252627282930313233343536373839404142# This is a basic workflow to help you get started with Actionsname: Deploy Hexo Blog# Controls when the workflow will runon: # Triggers the workflow on push or pull request events but only for the main branch push: branches: [ main ]jobs: build: runs-on: ubuntu-latest name: A job to deploy blog. steps: - name: Checkout uses: actions/checkout@v3.0.0 with: submodules: true # Checkout private submodules(themes or something else). # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - name: Install Dependencies if: steps.cache.outputs.cache-hit != 'true' run: npm ci # Deploy hexo blog website. - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} user_name: your github username # (or delete this input setting to use bot account) user_email: your github useremail # (or delete this input setting to use bot account) commit_msg: ${{ github.event.head_commit.message }} # (or delete this input setting to use hexo default settings) # Use the output from the `deploy` step(use for test action) - name: Get the output run: | echo &quot;${{ steps.deploy.outputs.notify }}&quot; 更新测试在设置两个仓库后就可以向Blog 仓库中commit 代码了。 123456789$ cd Blog # 进入Blog 目录$ git init # 初始化仓库$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;email@email.com&quot;$ git remote add origin &lt;github repository address&gt;# add 之前记得先添加 .gitignore 文件$ git add .$ git push 完成推送之后就可以在Actions 那里查看是否正常编译部署。部署完成再等一会儿，就可以打开&lt;username&gt;.github.io查看部署是否完成了。 注意事项 在自动部署中，配置的主题需要使用 submodule 的形式引入，如果没有以该种形式引入的话，最终生成的index.html会为一个空的文件，Actions的生成 logs 也会产生Warning。 1$ git submodule add https://github.com/litten/hexo-theme-yilia.git themes/yilia #以yilia 主题为例 为了访问 Fork 的主题，需要在Blog源代码仓库的Settings 中给 Actions 设置访问Fork仓库的权限，否则会Checkout 失败。 因为 BLM 运动，GitHub 把默认主分支的名字改成了Main，但本地的git 默认的分支名称还是 master，所以最好把git默认的分支名称也改成 main 12$ git config --global init.defaultBranch main$ git branch -M main # 如果是已经新建了的仓库，修改当前的分支名称为 main","link":"/2022/03/11/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-Hexo/"},{"title":"基础神经网络架构总结","text":"总结常用的神经网络结构。 全连接(FC)全连接层(FC层)MLP（Multilayer Perceptron）多层感知机的基本结构，本质上为权重矩阵与输入矩阵简单相乘并叠加非线性激活函数的运算形式。当前的神经网络机构的运算范式的基础。下面就是它的公式：其中$W^T$代表该层的参数，$X$表示输入，这个输入必须是2维的（加上$Batch$的话是3维）。全连接层一般会组成一个前馈网络用作最后一层。 $$ y = \\sigma(W^TX + B) $$ 卷积卷积可以可以看做是FC层在二维上的扩展。卷积层的输入是一个三维的数据$C \\times H \\times W$（不包括$Batch$）。相当于将全连接层权重进行了二维排布，组成一个卷积核。 且卷积神经网络拥有的权值共享的特性。也就是说对于单个通道是共用的（大白话就是使用一个卷积核卷积一整个图像）。 卷积的输出大小计算公式是：$N$表示输出的宽度，$W$表示图像的宽度，$F$表示卷积核的宽度，$P$表示填充的大小（一般为1），$S$表示卷积的步长 $$ N= \\lfloor x (W-F+2P)/S \\rfloor + 1 $$ RNN普通RNNRNN 相比与FCN的区别在于，RNN会保存当前一次的输出状态，并将该输出状态作为下一次的输入和新的数据输入一起参与新一轮的计算。它的公式为: $H_t$表示的是当前时刻的输出，$[ ]$表示的是拼接运算。初始时刻的$H_{t-1}$可以为0。RNN的本质上与FCN是一样的，只不过多了将上一个时刻的输出作为一部分输入输入到了神经网络。 $$ H_t = \\sigma (W^T[X_{t-1}, H_{t-1}] + B) $$ LSTM普通RNN存在的缺点是当输入的时间序列信息特别长的时候由于不相关的信息太多会造成网络非常难以训练。LSTM （ Long Short-Term Memory）的提出就是为了解决这样的问题，LSTM通过引入更多的计算部件控制当前时刻的输入以及上一个时刻输入对于输出结果的影响。它的计算则相对更加复杂一点。计算分为三个门： 其中$W_f, W_i, W_o, W_c$均为可学习的参数矩阵，$B_f, B_i, B_o, B_c$为可学习的偏置参数。 遗忘门： $$ F_t = \\sigma(W_f^T [H_{t-1}, X_t] + B_f) $$ 输入门： $$ I_t = \\sigma(W_i^T [H_{t-1}, X_t] + B_i) $$ 输出门： $$ O_t = \\sigma(W_o^T [H_{t-1}, X_t] + B_o) $$ 除了$H_t$需要记录，LSTM还需要维护多一个细胞状态作为下一次计算的输入：$\\odot$表示Element-Wise 的相乘。 $$ \\tilde{C}_{t}&=\\tanh(W_c^T[H_{t-1}, X_t]+B_c) \\\\ C_t &=F_t \\odot \\tilde{C}_{t-1} + I_t \\odot \\tilde{C}_{t} $$ $\\tanh$ 的函数图像为如下图，输出的范围为$(-1,1)$ 最终的输出为： $$ H_t = O_t \\odot \\tanh(C_t) $$ GRUGRU（Gated Recurrent Unit）可以视为简化版的LSTM。GRU只使用了两个门控单元： 更新门: $$ Z_t = \\sigma(W_z^T [H_{t-1}, X_t] + B_z) $$ 重置门: $$ R_t = \\sigma(W_r^T [H_{t-1}, X_t] + B_r) $$ 最终输出： $$ \\tilde{H}_t = \\tanh(W_h^T(R_t\\odot[H_{t-1}, X_t])+B_h) \\newline H_t = (1 - Z_t) \\odot H_{t-1} + Z_t \\odot \\tilde{H}_t $$ AttentionScaled Dot-Product Attention注意力机制(Attention)相对于本质普通的神经网络还是有比较大的区别。它的计算过程设计得非常精细，对于长序列数据的处理能力相比RNN更加强大（主观判断）。它的输入为一排 向量，输出也是一排向量，输出的向量是综合了序列中所有信息之后得到的表达。 首先需要先根据输入计算三个矩阵$QKV$， 分别对应Query、Key和Value，它们都是输入$X \\in \\mathbb{R}^{d \\times L}$，$X$是一个由$L$个维度为$d$的向量组成的输入矩阵。计算三个矩阵的过程为： $$ Q & = W_QX \\newline K & = W_KX \\newline V & = W_VX $$ 其中, $W_Q, W_K, W_V \\in \\mathbb{R}^{d \\times d}$均为可学习的参数矩阵。 $K$和$V$会组合在一起运算得到注意力分数Attention Score 矩阵$A \\in \\mathbb{R}^{L \\times L}$，它表示了其中第$(i,j)$个元素表示位置$i$与位置$j$之间的相关性得分，计算公式为: $$ A_{ij} = softmax(\\frac{Q_i^TK_j}{\\sqrt{d}}) $$ 其中 $\\frac{1}{\\sqrt{d}}$是为了环节是为了缓解点积得分可能较大的问题，同时可以使梯度更加稳定。$A$矩阵的每一列对应的就是输出的 $Attention Score$ ，因为过了$softmax$所以有 $$ \\sum A_{j} = \\sum_i A_{ij} = 1 $$ 使用矩阵$A$对Value矩阵$V$进行加权求和j就得到了输出矩阵 $\\tilde{O} \\in \\mathbb{R} ^{d \\times L}$。这个输出再经过一个线性变换就得到了最终的输出$O$。 $$ \\tilde{O} &= VA \\newline O &= W_O\\tilde{O} $$ Multi-head self-attentionGOOGLE关于Transformer的原始论文中使用的是多头注意力机制。多头注意力机制是单头注意力机制的改良版本，可以允许模型同时关注在不同位置的表达子空间上的不同信息。 它的公式是，$h$表示头的个数： $$ MultiHead(Q,K,V)=Concat(head_1, head_2,...,head_h) $$ 每个头的$QKV$计算和普通自注意力计算是一样，只是在还需要再经过没个头专属的线性映射矩阵后再进行每个头的注意力机制的计算： $$ head_i = Attention(W_Q^iQ,W_K^iK,W_V^iV) $$ 最终的输出为 $$ O = W_O \\times MultiHead(Q,K,V)=W_O \\times Concat(head_1, head_2,...,head_h) $$ 因为 $Concat$得到的矩阵大小为$hd \\times L$，$W_O$的大小为$d \\times hd$。所以最终输出的$O$仍然是$d \\times L$。","link":"/2023/04/09/%E5%9F%BA%E7%A1%80%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"},{"title":"定点数量化","text":"FPGA 部署中常常使用的是定点数量化推理，而之前研究的是关于整数量化推理的内容，定点数量化后的网络可以直接进行前向推理而不需要进行复杂的rescale来保证网络层和层之间运算的正确性。 定点数量化定点数地表示： 定点数有两个参数$WL,FL$，$WL$表示一个数所占用的总比特数，$FL$表示一个数小数部分所占用的比特数。例如，$WL=8, FL = 4$， 假设有一个无符号定点数为$0b1101.1010$，其表示的数可以记为： $$ 1\\times8+1\\times4+0\\times2+1\\times1+0.5\\times1+0\\times0.25+1\\times0.125+0\\times0.0625=13.625 $$ 等价于 $$ 218 \\times 0.0625 = 13.625 $$ 此时一个无符号整数所能表示的范围为：$[0, 15.9425]$，表示精度为$0.0625$。 无符号定点数量化 $$ fix\\_quant = \\frac{1}{2^{FL}}round(clip(x \\cdot 2^{FL}, 0, 2^{WL} - 1)) $$ 有符号整数量化 $$ fix\\_quant = \\frac{1}{2^{FL}}round(clip(x \\cdot 2^{FL}, -2^{WL -1} + 1, 2^{WL -1} - 1)) $$ Global Scale Factor$$fix_quant = \\frac{G_s}{2^{FL}}round(clip(\\frac{x}{G_s} \\cdot 2^{FL}, -2^{WL -1} + 1, 2^{WL -1} - 1))$$ 当每个层的$FL$确定之后就可以很容易 因为采用了所有层都采用了 整数量化常见的整数量化过程如下面的公式所示，其中$q$代表量化后的值，$r$代表全精度的值。 $$ q = round(\\frac{r}{S})\\\\ r = S(q - Z) \\\\ S = (r_{max} - r_{min})/(2^{WL} - 1) $$ 带0点的量化推理计算过程： $$ q_{c}^{(i, k)}=Z_{c}+P \\sum_{j=1}^{N}\\left(\\left(q_{a}^{(i, j)}-Z_{a}\\right)\\left(q_{b}^{(j, k)}-Z_{b}\\right)\\right) \\\\ q_{c}^{(i, k)}=Z_{c}+P\\left(N Z_{a} Z_{b}-Z_{a} M_{b}^{(k)}-Z_{b} M_{a}^{(i)}+\\sum_{j=1}^{N} q_{a}^{(i, j)} q_{b}^{(j, k)}\\right)\\\\ P = \\frac{S_aS_b}{S_c} \\\\ M_{b}^{(k)}=\\sum_{j=1}^{N} q_{b}^{(j, k)}, M_{a}^{(i)}=\\sum_{j=1}^{N} q_{a}^{(i, j)} $$ 如果采用对称量化，即量化后的零点和量化前的值的零点是对齐的，所有的$Z=0$，公式就可以简化为 $$ q_{c}^{(i, k)}=P \\sum_{j=1}^{N}\\left(q_{a}^{(i, j)}q_{b}^{(j, k)}\\right) \\\\ P = \\frac{S_aS_b}{S_c} $$ 可以看到，公式中的$M_b, M_a$都是都是可以提前计算出来的，在推理过程中需要计算的就只有$P\\cdot\\sum_{j=1}^{N} q_{a}^{(i, j)} q_{b}^{(j, k)}$这一项了。该部分的相乘累加是在整数上进行的。 定点数量化 vs 整数量化：定点数量化可以当作整数量化的特殊情况，当$FL$确定之后，相当于整数量化中固定$S = \\frac{1}{2^{FL}}$，同时截断范围为$clip(0,2^{FL} \\cdot (2^{WL} - 1)$。如果网络所有层采用同样的量化形式（即所有层的$WL, FL$的值均相等），在这种情况下网络间的运算就可以直接跳过 $P$参数的计算 思路： $S = \\frac{1}{2^{FL}}$不是最优的，但是具有计算上的优势，可以完全避免Rescale的额外计算，其本质上就是整个网络共享一个Scale 结合自适应的Scale训练方法，使整个网络共享一个Scale,这样就可以结合定点量化以及整数量化的优点 Overflow问题 饱和赋值 接纳溢出，并加以利用","link":"/2022/10/12/%E5%AE%9A%E7%82%B9%E6%95%B0%E9%87%8F%E5%8C%96/"},{"title":"开发板PS部分配置信息","text":"记录手上几块开发板PS部分的配置信息，方便查阅 ALINX-ZYNQ-7020创建工程芯片型号： xc7z020clg400-2 外设： 外设名称 引脚占用 其他 UART1 MIO 48 - 49 QSPI MIO 1-6 Single Port EHT0 MIO 16-27 需要在MIO配置中设置使用的 电平标准为HSTL 1.8V, Speed : Fast SD0 MIO 40-45 SD0-Card Detection MIO 47 DDR3 默认 MT41J256M16 RE-125 PS Clock 默认 输入33.3333 MHz，工作时钟 666.666MHz FCLK_CLK0 默认 给 PL 端提供的时钟 MLK-MZU07AEV创建工程芯片型号： xczu7ev-ffvc1156-2-i 外设： Bank0 IO Voltage为LVCMOS1.8V Bank1 IO Voltage为LVCMOS1.8VBank2 IO Voltage为LVCMOS1.8V Bank3 IO Voltage为LVCMOS1.8V 外设名称 引脚占用 其他 QSPI MIO 0-12 Dual Parallel， Data Mode ： SD0 MIO13-16 ,21, 22, 24 SD0-Card Detection MIO 24 UART0 MIO 34-35 IIC0 MIO18-MIO19","link":"/2022/10/08/%E5%BC%80%E5%8F%91%E6%9D%BFPS%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"},{"title":"数字电路基础 - 基础知识","text":"复习基本的数字电路知识。包括基本的编码方式、基本门电路的符号、逻辑代数化简方法、常见的组合逻辑设计方法。 常见编码我们比较常用的编码有8421码，其他的码感觉用的不多。 这里着重学习以下 格雷码，格雷码又叫循环二进制码或反射二进制码。格雷码相邻的两个码之间仅有一个位不一样，其与8421码可通过以下步骤互转： 8421 转格雷码（编码）：从==右往左==的第 N 位和 第 N+1 位进行异或，最后一位两个码相同。 格雷码转 8421（译码）: 从==右往左==的第 N 位和 第 N+1 位进行异或，最后一位两个码相同。 两个步骤是一样的。一个数异或同一个数两次得到的结果不变。 基本门电路这部分比较简单，记住下面这个表就可以了。 记住常见的门电路符号 可以根据电路图写出逻辑代数表达式 逻辑表达式化简在使用逻辑代数表达式描述完之后功能之后还需要对表达式进行化简，化简的表达式所转化得到的电路具有更少的元件，使电路图可以更加直观，同时也可以节省成本。化简的方法有下面两种。 公式法化简 （这个得看熟练程度） 卡诺图化简方法 （这个要实用一点，但需要列的表比较多）将所有的输入变量构成最小项，并将最小项根据格雷码的顺序写成表格，保证相邻的两项只有一个输入变量变化，如由 A, B 构成的最小项包括 AB, A’B, AB’, A’B’，就可以构成下图这种两变量 卡诺图 A/B 0 1 0 m0 m1 1 m2 m3 卡诺图利用 $\\bar{A}B + AB = (\\bar{A} + A)B = B$进行化简，在卡诺图中画的圆圈跨过两个格子则说明所跨过的变量可以消去。 卡诺图的化简步骤需要遵循: 所有的标1方格都需要被圈覆盖 每个圈中包含的相邻小方格数必须为2的整数次幂 圈需要尽可能大，圈和圈之间可以重叠 每个圈中至少有一个标1的方格未被其他圈所覆盖 组合逻辑电路设计过程 根据需求确定功能 根据功能列出真值表 根据真值表写出逻辑表达式 将逻辑表达式化简 逻辑表达式转化为逻辑电路图 编码器实现译码器的作用就是按照输入的类似并行的数据格式转换为BCD码，常用的集成芯片是74LS148。它的真值表如下图。$\\bar{EI}$的作用是作为输入使能端口，$\\bar{GS}$ 是编码器的工作标志位低电平有效，$EO$扩展端口可以用于多个芯片进行互联。 因此可以根据它的真值表写出输出的表达式为（这里写的是最基本的编码器的逻辑代数表达式，跟上图对比需要再取反）$$\\begin{array}{I}A_0 = I_6 + I_4 + I_2 + I_0 \\\\A_1 = I_5 + I_4 + I_1 + I_0 \\\\A_2 = I_0 + I_1 + I_2 + I_3 \\\\\\end{array}$$ 译码器实现译码器的作用与编码器相反，作用是将BCD码转换为对应序号的端口输出，这里是常用译码器74138的真值表。七段式数码管显示电路也可以借用这个思想进行设计。 同样是需要写出它的逻辑表达式。$$\\begin{array}{l}I_0 = \\bar{A_2}\\bar{A_1}\\bar{A_0},I_4 = {A_2}\\bar{A_1}\\bar{A_0} \\\\I_1 = \\bar{A_2}\\bar{A_1}{A_5}, I_5 = {A_2}\\bar{A_1}{A_0} \\\\I_2 = \\bar{A_2}{A_1}\\bar{A_0},I_6 = {A_2}{A_1}\\bar{A_0} \\\\I_3 = \\bar{A_2}{A_1}{A_0},I_7 = {A_2}{A_1}{A_0} \\\\\\end{array}$$ 加法器实现加法器是现代计算机中最基础的一个运算单元。加法器分为半加器和全加器，半加器不考虑进位，结构比较简单，只能计算一位二进制加法。因为半加器比较简单，所以这里直接给出它的逻辑表达式。半加器逻辑表达式为$$S = A \\oplus B = \\bar{A}B + A\\bar{B} \\\\C = A \\times B$$全加器因为需要考虑到进位信息，所以稍微复杂一些，下面的就是全加器的真值表 通过化简可以得出全加器的逻辑表达式为，这里只涉及一个全加器。$$S=\\bar{A}\\bar{B}C + \\bar{A}B\\bar{C} + A\\bar{B}\\bar{C}=A \\oplus B \\oplus C \\\\C=AB + BC + AC$$**行波进位加法器(Ripple-Carry Adder，RCA)**，如果要实现多位二进制数进行相加，可以通过将多个全加器进行级联，$c_{n - 1}$和下一个全加器的$c_{n}$相连就可以实现多个位的相加。 全加器的位数等于相加数的个数，最低位的 $c_{-1}$应接0，串行进位加法器电路比较简单，当时缺点是第N个全加器的输出必须要等到第N-1个全加器运算完成。 电路的门延迟为，其中T是每个门电路的输出延迟。$$ST = (2N + 1)T$$RLA的改进版称为超前进位加法器（Carry-lookhead Adder CLA），具体原理如下。 先对C的表达式进行化简, 其中$G_{i}$称为生成信号，$P_{i}$称为传播信号，$C_{i+1}$可以写为如下形式。$$C_{i+1} = A_{i}B_{i} + (A_{i} + B_{i})C_{i} \\\\G_{i} = A_{i}B_{i} \\\\P_{i} = (A_{i} + B_{i}) \\\\C_{i+1} = G_{i} + P_{i}C_{i}$$按照形式，各级门电路的进位表达式可以写为:$$C_1 = G_0+P_0C_0 \\\\C_2 = G_1+P_1C_1=G_1 + P_1G_0+P_1P_0C_0 \\\\C_3 = G_2+P_2G_1+P_2P_1G_0 + P_2P_1P_0C_0$$规律也挺明显的，$C_{n+1}$ 等于 $C_{n}$ 乘一个 $P_n$ 再加 $G_n$（废话）。 CLA相较与RCA的计算延迟时间固定为三级门延迟，且延迟和加法器的位数无关，但是如果进一步扩宽加法器的位宽，则电路会变得非常复杂。","link":"/2022/03/16/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%20-%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"数字电路基础 - 时序逻辑","text":"学习触发器，边缘触发器的基础知识。 可以参照D触发器的进化之路这篇文章，讲的比较清楚。 《编码》— 触发器可以保持信息，可以记住最近一次是哪个开关先闭合的。 RS触发器使用两个或非门或者与非门就可以构成最基本的RS锁存器。 这个电路的状态表如下图： R S Q(n+1) 1 0 1 0 1 0 1 1 Q(n) 0 0 不稳，该种情况需要避免出现 这种电路的缺点是： 能控制存储的对象，但是有非法态 整个系统不受控，一直处在工作状态 在输入端加入时钟控制功能，RS锁存器就变成了RS触发器。 使用两个或门的输出作为RS触发器的输入，当中间的引脚为1，则自动屏蔽输入，（或门有一个1则输出肯定为1，此时的RS触发器处于保持状态） 中间的引脚可以作为时钟信号的输入，插入时钟控制信号就可以避免刚刚说到的第二个缺点。 PS: 在上面那个或门的输出那里再插入一个或门，引出一个额外的输出端口作为清零端口。 D触发器由于RS触发器拥有两个输入端口（R/S）,为了避免这种情况，直接使用一个非门保证RS触发器的输入肯定是合法的。 将上面的电路进行封装，就变成了常见的电平触发的D触发器也称为DFF（D Filp-Flop）。在时钟信号为低电平时可以通过控制端口D改变保存的值，时钟信号为高电平时则进入所存状态。 将两个DFF串联，时钟信号通过一个非门相连，就构成了电平触发的D触发器。 第一个传输数据的时候，第二个D触发器保持 第二个传输数据的时候，第一个触发器保持， 最后的结果就是，只在边沿触发的那一刻传输数据！ 分频器将DFF的$\\bar{Q}$接到D，就可以实现对CLK 的分频 输出的模型如下，可以看到Q的输出频率为输入Clk 的 $\\frac{1}{2}$。 倍频器DFF和与非门配合就可以实现2倍频电路。 行波计数器通过将DFF进行串联, 除了组成分频器外，因为串联一个DFF输出的频率就是原来频率的 1/2。不同分频器当前的输出作为一个二进制数的数的一位，这个二进制数就代表了CLK 脉冲产生的个数 该电路的波形如下，将波形所代表的电平转化为十进制数就得到了Clk时钟的脉冲计数。","link":"/2022/03/17/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%20-%20%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/"},{"title":"浮点数运算","text":"浮点数在内存中的表达 浮点数的表示（IEEE754）组成部分 浮点数在内存中分为3个部分进行表示： Sign (符号位) Exponents (指数部分) Matissa (尾数部分) 其中符号位固定占1个bit，指数部分和尾数部分根据不同的数据类型所占用的大小也不相同，具体情况见下面的表 num total bits precision exponent bits mantissa bits bias 64 bits double 11 52 1023 32 bits single 8 23 127 16 bits half 5 10 15 表示规则浮点数规定了三种表示类型：规格化数、非规格化数、特殊值。 规格化数就是比较常用的在计算机中表示小数的方式，其转化为","link":"/2022/08/25/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"},{"title":"论文写作结构总结","text":"总结写论文时候各个部分所对应的一些结构，感谢汤老师的耐心教学😊。 Abstract一般写6-7句话，但是要根据所投会议或者出版社的具体要求，有一些会议还会有单词数量的限制。 第1句：描述当前研究工作的意义，或者所研究问题的定义。 第2句：引出问题，结合自己所提出的方法描述当前方法的缺点 第3句：针对所提出的问题，我们提出了……的方法（方法的总结），结合当前领域所采用的一般步骤，详细概括一下方法 First, …. Second,….. Third,…. 实验证明了（所提出的方法）是有效的 Introduction一般分为4-5段。 第一段：详细描述一下，该领域研究的意义 第2-3段：总结当前所采用的一些方法以及他们存在的一些问题，和Related Works 的区别在于，这里一般讲的相对粗略一点，主要概述一些经典的方法或者第一个提出这个问题的文章。 第4段：讲述一下Motivation 第5段：详细描述一下 所做出的 Contribution（最好跟摘要的描述一一对应） Related Works一般可根据需要分为 3-5段，主要介绍一下当前领域中采用的一些比较新的研究内容跟以及它们所属的类别，按照类别分段进行阐述。 在叙述的时候最好根据领域发展的脉络，描述一下领域发展的过程 对于后面实验所对比的方法在这里可以相对详细地介绍一下 Methods这部分没有什么限制，但需要注意一些点： 公式尽量采用通用的符号 当论述中需要使用的公式符号比较多的时候可以单独开出Prelimition小节介绍相关的符号定义 在公式后面需要跟标点符号以及公式编号 如果可以，尽量画一个图进行描述 Experiments这部分也没什么限制，需要包括以下部分： 所采用的数据集的介绍 评价指标介绍（需要简要介绍一下，如果有公式可以放公式） 简单介绍一些实验采用的一些网络 实验的环境（可选） Implement Detail. 可以适当放一下超参体现以下真实性 实验结果（实验的对比） 对于实验结果的描述（可以写一些图表中已经比较清楚的废话） 实验总结（实验证明了所提出的方法是有效的） Conclusion再次按照以下顺序重复说明一下文章的工作： 摘要（缩减后） 所做出的贡献 采用的方法 最后一句写一下Future Works。 写作中常用的网站(持续更新) 名称 网址 作用 Overleaf https://www.overleaf.com 在线的Latex编辑器，可以多人协作 Latex 表格生成 https://www.tablesgenerator.com/ 生成Latex 表格 火龙果写作 https://www.mypitaya.com/ 英文润色，语法检查 秘塔写作猫 https://xiezuocat.com/ 英文润色，语法检查 writefull https://www.writefull.com/ 学术写作润色 dblp https://dblp.uni-trier.de/ 导出参考文献的 bibtex 格 hemingway https://hemingwayapp.com/ 检测英语流利程度","link":"/2022/07/29/%E8%AE%BA%E6%96%87%E7%BB%93%E6%9E%84/"},{"title":"贴片元件焊接方法","text":"贴片元件的焊接方法 虽然之前接触焊接的很多，但一直都没有认真的学习和练习，焊接是一个常见技能，需要多加练习来熟练掌握。 注意事项： 烙铁温度保持在350 度。 直插原件焊接 烙铁头贴近焊盘和原件，同时为两者加热 将锡丝贴近烙铁头，通过浸润作用使液态锡均匀分到焊盘上，将原件接脚包裹 焊点形成圆锥侧面形状与PCB 形成 45 度夹角最佳 注意事项： 减少焊接持续时间避免长时间的加热损坏原件 焊接完一个焊点之后，锡丝先离开后，焊头再离开 贴片原件焊接 准备一个镊子 准备一个刀头焊头 电容电阻焊接方法 先给一边上锡，要注意锡量，保证锡面光滑圆润 使用镊子夹起电阻/电容，使其紧贴PCB 表面 使用焊头融化刚刚上锡 的一侧，等待融化并将电容电阻的一头包裹 移开焊头，等待锡凝固，固定电容电阻 PCB 旋转 180度完成另外一面的焊接 注意事项 保证锡表面与PCB 和原件之间的夹角为45度角最佳 如果锡量太多，使用烙铁头轻轻抹一下焊点，就合适了 贴片 IC 焊接方法 先给2-3个 焊盘上锡 使用镊子夹取芯片靠近上锡的焊盘 使用焊头将锡重新融化后固定芯片 将IC 的一边管脚全部上锡，只需要关注新派你管脚和焊盘之间是否已经连上锡，不用关心管脚之间是否粘连 将焊头使用拖焊将管脚上的锡脱出，保证管脚和管脚之间没有锡的存在 注意事项 注意芯片的焊接方向和PCB 的丝印方向对应 使用左手拿镊子右手拿焊笔，需要做到左手拿镊子的稳定与精准需要长时间的练习","link":"/2022/05/07/%E8%B4%B4%E7%89%87%E5%85%83%E4%BB%B6%E7%9A%84%E7%84%8A%E6%8E%A5%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"数字电路","slug":"数字电路","link":"/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"Verilog","slug":"Verilog","link":"/tags/Verilog/"},{"name":"工具使用","slug":"工具使用","link":"/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Diffusion","slug":"Diffusion","link":"/tags/Diffusion/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"BP算法","slug":"BP算法","link":"/tags/BP%E7%AE%97%E6%B3%95/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"makefile","slug":"makefile","link":"/tags/makefile/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Pandas","slug":"Pandas","link":"/tags/Pandas/"},{"name":"pthread","slug":"pthread","link":"/tags/pthread/"},{"name":"Pytorch","slug":"Pytorch","link":"/tags/Pytorch/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"tqdm","slug":"tqdm","link":"/tags/tqdm/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"RNN","slug":"RNN","link":"/tags/RNN/"},{"name":"ATTENTION","slug":"ATTENTION","link":"/tags/ATTENTION/"},{"name":"Paper","slug":"Paper","link":"/tags/Paper/"},{"name":"Writing","slug":"Writing","link":"/tags/Writing/"},{"name":"Float","slug":"Float","link":"/tags/Float/"},{"name":"焊接方法","slug":"焊接方法","link":"/tags/%E7%84%8A%E6%8E%A5%E6%96%B9%E6%B3%95/"}],"categories":[{"name":"FPGA","slug":"FPGA","link":"/categories/FPGA/"},{"name":"Skills","slug":"Skills","link":"/categories/Skills/"},{"name":"Research","slug":"Research","link":"/categories/Research/"},{"name":"linux","slug":"linux","link":"/categories/linux/"}],"pages":[{"title":"about","text":"关于这个博客该博客创建与2022年3月11日。建立这个博客的初衷是为了记录研究学习生活中所学习到的东西，希望可以通过这种方式督促自己学习，持续的产出优质的内容。 关于我本科为通信工程，软件硬件（嵌入式）都会一点，目前在西南某985的计院搬砖。 研究方向定为 Model Compression， 具体研究内容为 Model Quantization，同时因为项目需要以及自己的兴趣也在研究 AI Hardware Accelerator Design.🤙","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}