<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AXI总线学习</title>
    <url>/2023/03/22/AXI%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>手撕 AXI 总线</p>
<span id="more"></span>

<h2 id="AXI-总线"><a href="#AXI-总线" class="headerlink" title="AXI 总线"></a>AXI 总线</h2><p>AXI（Advanced eXtensible Interface）是一种总线协议，该协议是ARM公司提出的AMBA（Advanced Microcontroller Bus Architecture）3.0协议中最重要的部分，是一种<strong>面向高性能、高带宽、低延迟的片内总线</strong>。</p>
<p>AMBA 总线包括三个部分</p>
<ol>
<li>APB</li>
<li>AHB</li>
<li>AXI: 向后兼容 AHB 和 APB</li>
</ol>
<p>AXI 的特点：</p>
<ol>
<li>突发传输，可以一直传输，效率高</li>
</ol>
<p>时序顺序，参考 IHI022E 文档</p>
<p><img src="https://i.imgur.com/cXZVhJK.png" alt="读数据过程"></p>
<p><img src="https://i.imgur.com/yVyAMVq.png" alt="写数据过程"></p>
<p>AXI 总线包含 5个通道，五个通道可以使读写数据过程分离。</p>
<ol>
<li>写地址通道，信号前缀（aw_）</li>
<li>写数据通道，信号前缀（w_）</li>
<li>写响应通道，信号前缀（b_）</li>
<li>读地址通道，信号前缀（ar_）</li>
<li>读数据通道，信号前缀（r_）</li>
</ol>
<p>前三个通道完成写数据的过程，后两个通道完成读数据的过程。</p>
<p>AXI 的时序，参考 XILINX 的代码，可以 使用 VIVADO自动生成的IP 进行仿真后查看时序</p>
<p>波形时序：</p>
<ol>
<li>VALID 和 READY 同时为高代表数据有效，其中VALID来自主机，READY 来自从机</li>
<li>先写地址，紧接着写数据，最后一个数据跟随LAST</li>
<li>先读地址，紧接着读数据，最后一个数据跟随LAST信号</li>
<li>写完数据，有一个响应信号。</li>
</ol>
<p>&#x3D;&#x3D;LAST信号仅仅存在于数据读写数据通道中，在读写地址通道中是不包含的&#x3D;&#x3D;</p>
<h2 id="AXI-实现步骤"><a href="#AXI-实现步骤" class="headerlink" title="AXI 实现步骤"></a>AXI 实现步骤</h2><p>突发传输的数据长度为 1 - 256 （2的n 次方）</p>
<p>写步骤</p>
<ol>
<li>写首地址 （写地址通道）</li>
<li>写完首地址，突发传输数据（写数据通道）</li>
<li>控制LAST 信号（写数据通道）</li>
<li>等待响应信号 （写响应通道）</li>
</ol>
<p>读步骤</p>
<ol>
<li>写首地址</li>
<li>等待从机传输的数据，当VALID和READY都为高时读取数据</li>
<li>接受LAST信号</li>
</ol>
<p>实现的功能：</p>
<ol>
<li>向从机的 0 地址写  1 - 10;</li>
<li>读从机的 0 地址</li>
</ol>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Access Github Without Password</title>
    <url>/2022/03/11/Access-Github-Without-Password/</url>
    <content><![CDATA[<p>为了更方便使用 Github，需要配置Github 的免密访问。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>两种场景下需要用到免密访问</p>
<ol>
<li>将 仓库push 到Github</li>
<li>使用 git@ 开头的地址Clone 仓库到本地</li>
</ol>
<h2 id="配置-Git-个人信息"><a href="#配置-Git-个人信息" class="headerlink" title="配置 Git 个人信息"></a>配置 Git 个人信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot; # 最好和GitHub的用户名保持一致</span><br><span class="line">git config --global user.email &quot;邮箱&quot;  # 最好和GitHub的邮箱保持一致</span><br><span class="line"></span><br><span class="line">git config --list # 查看配置是狗成功</span><br></pre></td></tr></table></figure>

<h2 id="生成RSA"><a href="#生成RSA" class="headerlink" title="生成RSA"></a>生成RSA</h2><p>执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;github注册邮箱&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>执行之后按两次回车，会在<code>~/.ssh/</code> 目录下生成一个 <code>id_rsa</code>和 <code>id_rsa.pub</code> 文件，分别对应私钥和公钥文件。</p>
<h2 id="设置Github访问公钥"><a href="#设置Github访问公钥" class="headerlink" title="设置Github访问公钥"></a>设置Github访问公钥</h2><p>依次进入 Accounts -&gt; Settings -&gt; SSH and GPG keys。点击New SSH key 将 <code>id_rsa.pub</code>文件的内容复制带Key里面，title 可以随便写。</p>
<p><img src="https://i.imgur.com/UqSMEjK.png" alt="image-20220312132811032"></p>
<h2 id="修改SSH-访问端口"><a href="#修改SSH-访问端口" class="headerlink" title="修改SSH 访问端口"></a>修改SSH 访问端口</h2><p>如果出现 <code>remote host close connection</code>错误。在<code>.ssh</code>文件夹下的<code>config</code>文件新增或者添加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">    <span class="string">HostName</span> <span class="string">ssh.github.com</span></span><br><span class="line">    <span class="string">User</span> <span class="string">git</span></span><br><span class="line">    <span class="string">Port</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>可以使用下面的命令测试是否可以正确访问 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>出现以下提示则说明可以成功访问了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi ***! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>不要修改 <code>id_rsa</code>和 <code>id_rsa.pub</code>文件的默认存放路径，git 会在每次上传的时候从<code>~/.ssh</code>文件夹中自动读取私钥并加密，这样就不用再输入密码了。</li>
</ol>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言函数指针</title>
    <url>/2022/10/25/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>C语言函数指针语法</p>
<span id="more"></span>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待用函数指针形参的函数声明</span></span><br><span class="line">UG_S16 <span class="title function_">UG_Init</span><span class="params">(UG_GUI* g, <span class="type">void</span> (*p)(UG_S16, UG_S16, UG_COLOR), UG_S16 x, UG_S16 y)</span>&#123;</span><br><span class="line">	<span class="comment">// 强制类型转换</span></span><br><span class="line">    p_temp = (<span class="type">void</span> (*)(UG_S16, UG_S16, UG_COLOR)) p;</span><br><span class="line">    <span class="comment">// 可以在内部直接调用</span></span><br><span class="line">    p(x, y, z);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数指针性变量声明方式</span></span><br><span class="line"><span class="type">void</span> (*global_key_callback)(uint8);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_key</span><span class="params">(<span class="type">void</span> (*key_callback)(uint8))</span>&#123;</span><br><span class="line">    <span class="comment">// 函数指针赋值</span></span><br><span class="line">	global_key_callback = key_callback;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA时序约束</title>
    <url>/2023/03/22/FPGA%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>（实习准备）学习 FPGA 中如何进行时序约束。</p>
<span id="more"></span>

<h2 id="问题建立"><a href="#问题建立" class="headerlink" title="问题建立"></a>问题建立</h2><p>为什么需要时序约束？</p>
<p>满足电路的建立时间和保持时间，但是我们设计的RTL代码时不包含时序信息的。</p>
<p>如何分析电路的时序？</p>
<p>时序电路：建立时间、保持时间</p>
<p>组合逻辑：恢复时间、撤销时间</p>
<p>以下面的电路为例：</p>
<p><img src="https://i.imgur.com/H1wtupL.png" alt="image-20230322203625779"></p>
<p>访问的时序图如下：</p>
<p><img src="https://i.imgur.com/8jCDWWw.png" alt="image-20230322203752758"></p>
<p>对于同步时钟连接到的两个触发器，由于布线的长短不同，时钟沿到达不同触发器的时间是有差异的。</p>
<p>符号定义 : 建立时间余量 $T{su_slack}$，保持时间余量$T_{hd_slack}$，时钟周期$T$， 建立时间$T_{su}$，保持时间$T_{hd}$，组合逻辑延迟$T_{delay}$，逻辑门传输延迟$T_{co}$，时钟偏斜1$T_{clk1}$，时钟偏斜2$T_{clk2}$。</p>
<p>建立时间余量计算为：</p>

$$
T_{su\_slack} = T + T_{clk2} - T_{su} 
- (T_{clk1} +T_{co} + T_{Delay})
$$

<p>保持时间余量为：</p>

$$
T_{hd\_slack} = T + T_{clk1} + T_{co} + T_{delay} - (T + T_{clk2} + T_{hd}) \\ =T_{clk1} + T_{co} + T_{delay} - T_{clk2} - T_{hd}
$$


<p><strong>建立时间余量$T{su_slack}$是和时钟周期有关的，保持时间余量$T_{hd_slack}$和时钟周期没有关系。</strong>也就是说时钟的频率会影响建立时间余量。</p>
<p>真正在设计中，我们能够影响的就是有组合逻辑延迟$T_{delay}$。</p>
<h2 id="VIVADO约束"><a href="#VIVADO约束" class="headerlink" title="VIVADO约束"></a>VIVADO约束</h2><p>时序约束并不会对电路产生任何实质性的作用，只是可以辅助设计出正确的电路。</p>
<p>约束类型：</p>
<ol>
<li>物理约束：I&#x2F;O约束</li>
<li>时钟约束</li>
</ol>
<p><strong>VIVADO在做时序分析时，的默认条件：</strong></p>
<ol>
<li>默认所有时钟都是有关系的，都是同步的，都做时序分析。如果有异步时钟，则需要进行异步时钟约束</li>
</ol>
<p>时钟类型的区分：如果使用到 DDR，PCI-E,GT接口，往往都需要多个时钟源</p>
<ol>
<li>同步时钟：是指频率和相位有一定关系的时钟。大部分情况下来自同一个 时钟源</li>
<li>异步时钟：与同步时钟定义相反的时钟，来自不同的时钟源</li>
</ol>
<p>在设计高速系统的时钟很容易发生时序违例（Timing Violation）。</p>
<blockquote>
<p>时序违例指的是FPGA设计中某些信号到达目标寄存器或逻辑单元的时间超过了其允许的最大延迟，从而导致电路功能异常或无法正常工作。在FPGA设计过程中，时序违例通常是由时钟频率过高、复杂逻辑路径、布线不当等因素引起的。为避免时序违例，需要进行时序分析、时序约束设置、合理的优化布局等措施。</p>
</blockquote>
<h3 id="时钟约束的类型以及创建步骤"><a href="#时钟约束的类型以及创建步骤" class="headerlink" title="时钟约束的类型以及创建步骤"></a>时钟约束的类型以及创建步骤</h3><ol>
<li><p>源时钟约束</p>
<p>告诉VIVADO当前的系统的输入时钟，以便VIVADO 进行建立时间和保持时间余量的分析。</p>
<p>创建源时钟约束步骤：</p>
<ul>
<li>综合并布局布线</li>
<li>点击 <code>IMPLEMENTATION</code>下面的<code>Edit timing Constraints</code>在Clock 中选择 <code>Create Clock</code></li>
<li>创建时钟，制定时钟的周期、上升沿时钟、下降沿时间</li>
<li>生成 时钟约束语句，并添加到<code>XDC</code>约束文件中</li>
</ul>
</li>
<li><p>衍生时钟约束</p>
<ol>
<li>自定义的时钟：例如自己写的倍频，分频，<strong>需要自己约束</strong>，选择创建时钟约束窗口中的<code>Create Generated Clock</code></li>
<li>自动生成的时钟：使用自带的PLL 或者 MMCM IP 自动生成的时钟，<strong>这种情况是不需要自己进行约束的</strong>，VIVADO 会自动处理生成约束。</li>
</ol>
</li>
<li><p>异步时钟约束</p>
<p>在VIVADO中声明那些是异步时钟，创建步骤：</p>
<ul>
<li>选择<code>Create Clock group</code></li>
<li>有多少个异步时钟就有多少个 组</li>
<li>选择 时钟的关系为 <code>asyncchronous</code></li>
</ul>
</li>
<li><p>互斥时钟</p>
<p>两个不会同时使用的时钟, 跟创建异步时钟步骤一致，只是时钟关系选择为 <code>Logic exclusive </code>或者 <code>physically exclusive</code></p>
</li>
</ol>
<h2 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h2><ol>
<li>CDC跨时钟域约束</li>
</ol>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffusion Model</title>
    <url>/2023/03/27/Diffusion%20Model/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Diffusion</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA跨时钟域处理</title>
    <url>/2023/03/21/FPGA%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>（实习准备）学习 FPGA 中跨时钟域通信问题的处理。</p>
<span id="more"></span>

<p>跨时钟域通信出现的问题：</p>
<h2 id="亚稳态问题："><a href="#亚稳态问题：" class="headerlink" title="亚稳态问题："></a>亚稳态问题：</h2><p>如下图所示，触发器的存储需要有一个建立时间 $T{st}$ 和保持时间$T_{hd}$。数据变化的时间需要在 $T{st}$之前，需要在上升沿发生后至少保持$T{hd}$时间才能进行所存。如果数据不满足建立时间和保持时间，则会出现亚稳态问题，此时触发器中保存的内容是不定态。</p>
<p><img src="https://i.imgur.com/a4M4522.png"></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li><p>电平同步器： 针对单bit</p>
</li>
<li><p>脉冲同步器： 针对单bit</p>
</li>
<li><p>FIFO, RAM ： 针对多bit</p>
</li>
</ol>
<h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><ol>
<li>复位处理模块</li>
<li>快到慢的同步器</li>
<li>慢到快的同步器</li>
<li>双边缘检测器</li>
</ol>
<p>“打两拍“ 同步的原理：异步赋值会产生亚稳态。概率数学上的处理的方式。每个触发器发生亚稳态的概率是独立的，多个触发器串联可以使 发生亚稳态的概率大大减小。“打三拍” 降低的概率和“打两拍”的差别不大。</p>
<p>同步复位代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码规范：</span></span><br><span class="line"><span class="comment">// 模块名为 功能+_module ,如果是驱动则以 _driver结尾</span></span><br><span class="line"><span class="comment">// 信号的名称 i_，o_ 分别表示 输入和输出的前缀</span></span><br><span class="line"><span class="comment">// 寄存器变量的声明 以 reg_ 进行开头</span></span><br><span class="line"><span class="keyword">module</span> sync_rst_module( </span><br><span class="line">	<span class="keyword">input</span> 		i_sysclk	,</span><br><span class="line">    <span class="keyword">input</span> 		i_rst		,</span><br><span class="line">    <span class="keyword">output</span>		o_sync_rst	</span><br><span class="line">)；</span><br><span class="line">    <span class="comment">// 告诉综合器，将这两个寄存器放在同一个 CLB 中</span></span><br><span class="line">    (* ANYNC_REG = <span class="string">&quot;TRUE&quot;</span>*)</span><br><span class="line">    <span class="keyword">reg</span> r_rst1, r_rst2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一般的规范要求一个always块中只能处理一个信号，但是这里的设计比较简单，这里就直接写在一起了</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_sysclk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (i_rst) <span class="keyword">begin</span></span><br><span class="line">        	r_rst1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            r_rst2 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        	r_rst1 &lt;= i_rst;</span><br><span class="line">            r_rst2 &lt;= r_rst1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> o_sync_rst = r_rst2;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>慢时钟域到快时钟域同步：设计上和同步复位的代码是差不多的</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> s2f_sync_module(</span><br><span class="line">	<span class="keyword">input</span> 		i_clk_slow		,</span><br><span class="line">    <span class="keyword">input</span> 		i_signal		,</span><br><span class="line">    <span class="keyword">input</span> 		i_clk_fast		,</span><br><span class="line">    <span class="keyword">output</span> 		o_sync_signal	</span><br><span class="line">)；</span><br><span class="line">    (* ANYNC_REG = <span class="string">&quot;TRUE&quot;</span>*)</span><br><span class="line">    <span class="keyword">reg</span> r_s1, r_s2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk_fast) <span class="keyword">begin</span></span><br><span class="line">        r_s1 &lt;= i_signal;</span><br><span class="line">        r_s2 &lt;= r_s1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> o_sync_signal = r_s2;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>快时钟域到慢时钟域同步：也叫<strong>脉冲同步器</strong>。</p>
<p>与慢到快不同的是需要进行脉冲周期延拓</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> f2s_sync_module(</span><br><span class="line">	<span class="keyword">input</span> 		i_clk_slow		,</span><br><span class="line">    <span class="keyword">input</span> 		i_signal		,</span><br><span class="line">    <span class="keyword">input</span> 		i_clk_fast		,</span><br><span class="line">    <span class="keyword">output</span> 		o_sync_signal	</span><br><span class="line">)；</span><br><span class="line">    <span class="keyword">reg</span> r_d1, r_d2;</span><br><span class="line">    <span class="comment">// 延拓用的寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> r_pos;</span><br><span class="line">    (* ANYNC_REG = <span class="string">&quot;TRUE&quot;</span>*)</span><br><span class="line">    <span class="keyword">reg</span> r_s1, r_s2;</span><br><span class="line">   	</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk_slow) <span class="keyword">begin</span></span><br><span class="line">        r_d1 &lt;= i_signal;</span><br><span class="line">        r_d2 &lt;= r_d1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号延拓 2个周期</span></span><br><span class="line">    <span class="keyword">assign</span> r_pos = i_signal | r_d1 | r_d2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打两拍用的寄存器</span></span><br><span class="line">    (* ANYNC_REG = <span class="string">&quot;TRUE&quot;</span>*)</span><br><span class="line">    <span class="keyword">reg</span> r_p1, r_p2;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk_slow) <span class="keyword">begin</span></span><br><span class="line">        r_p1 &lt;= r_pos;</span><br><span class="line">        r_p2 &lt;= r_p1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 同步输出</span></span><br><span class="line">    <span class="keyword">assign</span> o_sync_signal = r_p2;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h2 id="异步FIFO"><a href="#异步FIFO" class="headerlink" title="异步FIFO"></a>异步FIFO</h2><p>待补充， 参考 《Simulation and Synthesis Techniques for Asynchronous FIFO Design》</p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用基础</title>
    <url>/2022/08/16/Git%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>记录Git的常见用法。</p>
<span id="more"></span>

<h2 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h2><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="img"></p>
<p><code>Git</code>实现流程包括3个部分，工作区，暂存区(Stage)和版本库</p>
<ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<h2 id="Git-基础命令"><a href="#Git-基础命令" class="headerlink" title="Git 基础命令"></a>Git 基础命令</h2><p><code>git</code>中常用的操作包括以下几个部分：</p>
<ul>
<li>初始化<code>git</code>仓库</li>
<li>添加文件到版本控制</li>
<li>提交当前文件到版本管理仓库</li>
<li>回退版本</li>
</ul>
<h3 id="初始化仓库以及提交文件"><a href="#初始化仓库以及提交文件" class="headerlink" title="初始化仓库以及提交文件"></a>初始化仓库以及提交文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &lt;folder_name&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">初始化一个 Git 仓库，该命令会在目录中生成一个 .git 文件夹</span></span><br><span class="line">git init  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">添加需要版本控制的文件或者文件夹</span></span><br><span class="line">git add &lt;file_name&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">移除添加到stage中的一个文件(对工作区没有影响)</span></span><br><span class="line">git rm --cached &lt;file_name&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看当前状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>文件添加完成到Stage之后，可以使用 commit 命令提交到版本库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">文件添加完后可进行提交</span></span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看提交历史</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta"># </span><span class="language-bash">简洁版历史</span></span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>
<article class="message message-immersive is-primary">
<div class="message-body">
<i class="fas fa-exclamation-circle"></i>
不同类别的修改 (如：Bug修复和功能添加) 要尽量分开提交，以方便以后从历史记录里查找特定的修改内容。
</div>
</article>
<article class="message message-immersive is-warning">
<div class="message-body">
> commit 的内容遵循以下格式：
> 第1行：提交修改内容的摘要
> 第2行：空行
> 第3行以后：修改的理由
</div>
</article>


<h3 id="提交回退"><a href="#提交回退" class="headerlink" title="提交回退"></a>提交回退</h3><p>当修改的代码出现了问题，可以对代码文件进行回退，这也是代码版本控制的重要功能。<code>git</code>中的版本回退使用<code>reset</code>命令。<code>HEAD</code>代表当前所指向的代码版本，<code>HEAD^</code>表示上一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">回退到上2个版本</span></span><br><span class="line">git reset HEAD~2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">单独将一个文件回退一个版本</span></span><br><span class="line">git reset HEAD^ 1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">回退到指定的提交, 后面接提交历史的<span class="built_in">hash</span>值，可以通过 git <span class="built_in">log</span> 查看，并不需要输入完整的<span class="built_in">hash</span>值，只需要输入前几位就可以了</span></span><br><span class="line">git reset 023e</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以在后面接 --hard 强制丢弃当前的所有未暂存的内容</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一个dev分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">将 dev分支合并到 master分支(接上面的命令)</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除dev分支</span></span><br><span class="line">git checkout -d dev</span><br></pre></td></tr></table></figure>

<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看当前已经添加的submodule</span></span><br><span class="line">git submodule</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">对于刚刚<span class="built_in">clone</span> 下来的主仓库使用下面的命令进行初始化</span></span><br><span class="line">git submodule init</span><br><span class="line">git submodule update </span><br><span class="line"><span class="meta"># </span><span class="language-bash">或者</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除一个子模块。删除之前通过 git submodule 命令查看 submodule_name</span></span><br><span class="line">git deinit [sub_module_name]</span><br><span class="line">git rm --cached [submodule_name]</span><br><span class="line">git commit -m &quot;remove ...&quot;</span><br></pre></td></tr></table></figure>

<h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><ul>
<li><p>配置初始化用户信息</p>
<p>在使用 <code>git commit</code>之前，还需要指定默认作为提交的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">如果是单独为某个仓库指定用户名和邮箱，把 global 参数去掉就可以了</span></span><br><span class="line">git config --global user.name &#x27;user_name&#x27;</span><br><span class="line">git config --global user.email &#x27;email&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>正常显示中文<br><code>git</code>默认使用中文名称的时候是以 <code>\xxx</code>这种形式显示的，虽然不影响我们的操作结果，但是不利于我们观察文件的变动信息，设置正常显示中文文件名的命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux炼丹中常用命令总结</title>
    <url>/2022/08/09/Linux%E7%82%BC%E4%B8%B9%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结在服务器中跑深度学习的时候，常常需要使用的Linux 命令。</p>
<span id="more"></span>

<p>可搭配前面提到 <a href="/2022/03/13/docker%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/" title="docker搭建深度学习环境">docker搭建深度学习环境</a>和<a href="/2022/04/28/tmux%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" title="tmux使用总结">tmux使用总结</a>相关文章食用。</p>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看当前运行的所有进程</span></span><br><span class="line">ps -aux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">结束一个进程, PID 可通过进程查找指令查看</span></span><br><span class="line">kill -s 9 PID</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">结束所有python 进程（慎重使用）</span></span><br><span class="line">killall python</span><br></pre></td></tr></table></figure>

<h2 id="资源占用与文件查找"><a href="#资源占用与文件查找" class="headerlink" title="资源占用与文件查找"></a>资源占用与文件查找</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">实时交互式显示 当前系统资源占用情况</span></span><br><span class="line">htop</span><br><span class="line">top</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">实时监控 GPU 占用</span></span><br><span class="line">watch -n 1 -d nvidia-smi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看磁盘剩余空间</span></span><br><span class="line">df -hl</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看当前目录下各个文件/文件夹的大小</span></span><br><span class="line">du -h –max-depth=1 *</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看当前目录下所有文件大小的总和</span></span><br><span class="line">du -sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看当前文件个数, 使用 ^d 是统计文件夹的个数</span></span><br><span class="line">ls -l | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查找文件，后面跟的是正则表达式</span></span><br><span class="line">find . -name &quot;*.tar&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件的上传以及下载"><a href="#文件的上传以及下载" class="headerlink" title="文件的上传以及下载"></a>文件的上传以及下载</h2><p>传输数据集的时候可以使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">可以递归地创建文件夹</span></span><br><span class="line">mkdir -p /path/to/...</span><br><span class="line"><span class="meta"># </span><span class="language-bash">复制文件夹</span></span><br><span class="line">cp -r sour_dir dest_dir</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">从远程服务器下载文件 SCP</span></span><br><span class="line">scp username@servername:/path/filename /tmp/local_destination</span><br><span class="line"><span class="meta"># </span><span class="language-bash">需要下载文件夹 则加上 -r 参数</span></span><br><span class="line">scp -r username@servername:/path/filename /tmp/local_destination</span><br><span class="line"><span class="meta"># </span><span class="language-bash">上传文件则把两边的位置调换过来</span></span><br><span class="line">scp  -r /tmp/local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure>

<p>文件压缩与解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">打包一个文件夹为一个zip压缩文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">-r 参数为递归地在文件夹中寻找文件压缩</span></span><br><span class="line">zip -r file_name.zip /path/to/dir</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压一个zip压缩文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">-d 参数可以指定解压后文件的保存目录</span></span><br><span class="line">unzip file.zip -d /path/to/extract/</span><br></pre></td></tr></table></figure>

<h2 id="硬盘操作"><a href="#硬盘操作" class="headerlink" title="硬盘操作"></a>硬盘操作</h2><p>添加新硬盘，格式化硬盘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看新硬盘是否已经被成功安装, 同时该命令还可以查看新的硬盘所挂载到的设备号，例如 sda,sdb,以及硬盘中已经存在的分区，分区的挂载信息等</span></span><br><span class="line">lsblk</span><br><span class="line"><span class="meta"># </span><span class="language-bash">加上 -f参数可以查看分区的UUID，UUID在自动挂载时会使用</span></span><br><span class="line">lsblk -f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建分区, 该工具提供了基于命令行的简易分区工具，很好用</span></span><br><span class="line">cfdisk /dev/sda</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果有分区的大小大于2T，则需要先将硬盘格式转换为GPT格式</span></span><br><span class="line">parted /dev/sda</span><br><span class="line"><span class="meta"># </span><span class="language-bash">执行下面的命令, 根据提示完成转换即可</span></span><br><span class="line">mklabel gpt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">退出parted，使用 cfdisk进行分区</span></span><br><span class="line">q</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用 cfdisk 分区完成后还需要将分区格式化为 ext4 格式</span></span><br><span class="line">mkfs -t ext4 /dev/sda1</span><br></pre></td></tr></table></figure>

<p>下一步就是需要将已经分好区的硬盘挂载到相应的目录，这里假设需要挂载的硬盘号为 <code>/dev/sda1</code>,需要挂载到目录是 <code>/home/user/exdisk1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建目录，这步可以跳过</span></span><br><span class="line">mkdir -p /home/user/exdisk1</span><br><span class="line"><span class="meta"># </span><span class="language-bash">临时挂载</span></span><br><span class="line">mount /dev/sda1 /home/user/exdisk1</span><br></pre></td></tr></table></figure>

<p>如果只是临时使用该分区（例如挂载一个U盘），使用上面的命令也就足够了，如果需要挂载的是一个需要长期使用的U盘，则需要修改<code>/etc/fstab</code>文件。</p>
<p>第一步是使用 <code>lsblk -f</code>命令查看分区的<code>UUID</code>，每个磁盘分区的<code>UUID</code>在系统中都是唯一的，即使重启后也不会改变，如下图 框出来的就是此次需要挂载分区的<code>UUID</code></p>
<p><em>注意：如果没有挂载，后面的挂载点的内容是空的</em></p>
<p><img src="https://i.imgur.com/D7ekKuo.png" alt="image-20221004150518883"></p>
<p>第二步是修改<code>/etc/fstab</code>文件，添加上一行，内容可以看文件上面的注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">&lt;file system&gt; &lt;mount point&gt;   &lt;<span class="built_in">type</span>&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line">UUID=af931fd6-b0f5-455b-8e3a-6260b18fde24 	/home/dilib5/ex_disk1 	ext4 	defaults 	0 	2</span><br></pre></td></tr></table></figure>

<p>将<code>/etc/fstab</code>修改完成后，执行全部挂载命令验证所添加的内容是否正确，如果不正确可能会导致系统无法启动！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure>
<p>最后重启系统就可以看到硬盘已经成功挂载了，（用的是同一张图, 哈哈哈哈，逃）<br><img src="https://i.imgur.com/vhm6xqS.png" alt="image-20221004151512869"></p>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MLP的BP推导与实现-上</title>
    <url>/2022/03/11/MLP%E7%9A%84BP%E6%8E%A8%E5%AF%BC%E4%B8%8E%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/</url>
    <content><![CDATA[<p>内容包括梯度下降基本原理，矩阵求导基础。</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在推导之前先复习一下一些基础知识。</p>
<h3 id="一阶导数定义"><a href="#一阶导数定义" class="headerlink" title="一阶导数定义"></a>一阶导数定义</h3><p>$$<br>f{‘}(x) &#x3D; \displaystyle{\lim_{\Delta x \to 0}} \frac{\Delta y}{\Delta x} &#x3D; \frac{f(\Delta x +x) - f(x)}{\Delta x}<br>$$</p>
<h3 id="多元函数偏导数定义"><a href="#多元函数偏导数定义" class="headerlink" title="多元函数偏导数定义"></a>多元函数偏导数定义</h3><p>$$<br>f_{x1}(x1, x2,…)&#x3D;\lim _{\Delta x \to 0} \frac{f(x1+\Delta x, x2, x3, …)-f(x1, x2, x3,…)}{\Delta x}<br>$$</p>
<h3 id="方向导数的定义"><a href="#方向导数的定义" class="headerlink" title="方向导数的定义"></a>方向导数的定义</h3><p>偏导数定义只是沿着某个坐标轴方向的导数，多元函数的自变量在某点可以沿无数个方向运动，多元函数沿着某个方向上的变换率称为 &#x3D;&#x3D;方向导数&#x3D;&#x3D; ,它的推导过程如图所示（2个变元的情况）</p>

$$
\begin{array}{l}
\lim _{t \to 0^{+}} \frac{f\left(x_{0}+t \cos \alpha, y_{0}+t \sin \alpha\right)-f\left(x_{0}, y_{0}\right)}{t} \\\\
=\lim _{t \to 0^{+}}\left[\frac{f\left(x_{0}+t \cos \alpha, y_{0}+t \sin \alpha\right)-f\left(x_{0}, y_{0}+t \sin \alpha\right)}{t}+\frac{f\left(x_{0}, y_{0}+t \sin \alpha\right)-f\left(x_{0}, y_{0}\right)}{t}\right] \\\\
=\lim _{t \to 0}\left[\frac{f_{x}\left(\xi_{x}, y_{0}+t \sin \alpha\right) t \cos \alpha}{t}+\frac{f_{y}\left(x_{0}, \xi_{y}\right) t \sin \alpha}{t}\right], \xi_{x} \in\left(x_{0}, x_{0}+t \cos \alpha\right), \xi_{y} \in\left(y_{0}, y_{0}+t \sin \alpha\right) \\\\
=f_x (x_0,y_0 )cos⁡\alpha +f_y (x_0,y_0 )sin⁡\alpha
\end{array}
$$



<h2 id="梯度的定义"><a href="#梯度的定义" class="headerlink" title="梯度的定义"></a>梯度的定义</h2><p>多元函数在某一点的梯度是一个非常特殊的向量，其由多元函数对每个变量的偏导数组成,（这即是为什么求梯度的时候需要对各个变量求偏导的原因），其方向为函数在该点增加最快的方向，大小（向量的模长）为函数在该点的最大变化率。</p>
<p>将上面的方向导数写成两个向量相乘的格式，就得到了：</p>

$$
\begin{equation}
 f_x (x_0,y_0 )cos⁡\alpha +f_y (x_0,y_0 )sin⁡\alpha
  =\left(
  \begin{array}{cc}
          f_x (x_0,y_0 ) &
          f_y (x_0,y_0 )
  \end{array}
  \right)
  \left(
  \begin{array}{c}
          cos⁡\alpha \\
          
          sin⁡\alpha
 \end{array}
 \right)
\end{equation}
$$


设有两个变量 $g = (f_x (x_0,y_0 ) \quad f_y (x_0,y_0 ))$和$e_l = (cos⁡\alpha \quad sin \alpha)$
$$
g \cdot e_l = |g||e_l|cos \theta = |g|cos\theta
$$


<p>$\theta$ 为两个向量之间的夹角，所以该向量点乘结果（也就是方向导数）</p>
<ul>
<li><p>在$\theta &#x3D; 0$的情况下。此时函数的变化率最大，函数呈上升趋势</p>
</li>
<li><p>在$\theta &#x3D; \pi$的情况下函数的变化率最大，函数呈下降趋势</p>
</li>
</ul>
<h2 id="梯度下降原理"><a href="#梯度下降原理" class="headerlink" title="梯度下降原理"></a>梯度下降原理</h2><p>因为梯度指示了函数变化率最大的地方，因此只要每次沿着梯度指示方向的反方向更新当前网络的参数并一直迭代，就可以将$loss$函数优化到最低点。<br>$$<br>w &#x3D; w_j - \alpha \nabla J(W_j)<br>$$</p>
<h2 id="矩阵求导"><a href="#矩阵求导" class="headerlink" title="矩阵求导"></a>矩阵求导</h2><p>由于在机器学习中，我们使用最多的数据一般都是向量或者矩阵形式的，很少有标量的情况，因此我们还需要学习矩阵求导的相关知识。</p>
<p>矩阵求导和函数求导还是不太一样的，具体学习可以参考下面这两个链接。矩阵求导的本质就是 一个函数 $function$的每一个$f$对变元中的每个元素逐个求偏导。但是在神经网络中一般涉及到的形式一般是输入一组矩阵或者向量，最后输出的$loss$值一般为一个标量用于衡量网络的性能。所这里就只考虑$f$是一个矩阵变元的实值标量函数，我们需要使用梯度下降优化这个函数的参数，使该函数的输出值最小。</p>
<p>这里推荐两篇文章，这里只是对这两篇文章的一些总结，更详细的内容可以直接看原文。</p>
<p><a href="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/263777564">矩阵求导</a></p>
<h3 id="矩阵求导布局"><a href="#矩阵求导布局" class="headerlink" title="矩阵求导布局"></a>矩阵求导布局</h3><ol>
<li>分子布局：求导的 $f$ 是列向量的形式，分子$X$是行向量的形式</li>
<li>分母布局：求导的 $f$是行向量的形式，分子$X$是列向量的形式</li>
</ol>
<p>分子布局和分母布局互为转置。</p>
<h3 id="矩阵求导常用的四个法则以及公式"><a href="#矩阵求导常用的四个法则以及公式" class="headerlink" title="矩阵求导常用的四个法则以及公式"></a>矩阵求导常用的四个法则以及公式</h3><p>矩阵求导的四个法则跟一元函数求导的法则是一致的，可以直接借鉴过来</p>



$$
\begin{align}
&\frac{\partial C}{\partial X} = 0 \\\\
&\frac{\partial\left[c_{1} f(x)+c_{2} g(x)\right]}{\partial z}=c_{1} \frac{\partial f(x)}{\partial z}+c_{2} \frac{\partial g(x)}{\partial z} \\\\
&\frac{\partial[f(x) g(x)]}{\partial z}=\frac{\partial f(x)}{\partial z} g(x)+f(z) \frac{\partial g(z)}{\partial z} \\\\
&\frac{\partial\left[\frac{f(x)}{g(x)}\right]}{\partial z}=\frac{1}{g^{2}(x)}\left[\frac{\partial f(x)}{\partial x} g(z)-f(z) \frac{\partial g(x)}{\partial x}\right]
\end{align}
$$


<p>一些补充公式</p>

$$
\begin{align}
&\frac{\partial\left(x^{T} a\right)}{\partial x}=\frac{\partial\left(a^{T} x\right)}{\partial x}=a \\\\
&\frac{\partial\left(x^{T} x\right)}{\partial z}=2 x \\\\
&\frac{\partial\left(x^{T} A x\right)}{\partial x}=A x+A^{T} x \\\\
\end{align}
$$



<h3 id="矩阵求导的进阶技巧"><a href="#矩阵求导的进阶技巧" class="headerlink" title="矩阵求导的进阶技巧"></a>矩阵求导的进阶技巧</h3><p>上面写都是矩阵求导的基本法则，类似于使用定义法求一元函数的导数，使用的场合不多，更为常用的方法是使用<strong>迹技巧</strong>去求解。</p>
<p>首先来看迹的定义：<br>$$<br>tr(A) &#x3D; a_{11} + a_{22} + \cdots + a_{nn} &#x3D; \sum_{i&#x3D;1}^{n}a_{i}<br>$$<br>一些常见的迹的公式</p>

$$
\begin{align}
&tr(c) = c \newline
&tr(c_1A + c_2B) = c_1tr(A) + c_2tr(B) \newline
&tr(A) = tr(A^T) \newline
&\underline{tr(ABC) = tr(CAB) = tr(BCA)}, \quad A_{m\times n}, B_{n \times p}, C_{p \times m} \newline
&tr(AB^T) = tr(B^TA) = tr(A^TB) = tr(BA^T) \newline
&tr(|A|) = |A| tr(A^{-1}dA) = tr(|A|A^{-1}dA) \newline
&tr(A^T (B \odot C)) = tr((A \odot B)^T C)
\end{align}
$$


<p><em>注意上面画横线的那个公式的意思是两个矩阵相乘的迹，可以将后 一个的矩阵提到前面去，结果不改变。</em></p>
<p>矩阵乘积的迹，（注意这里迹的表示，这对理解为什么可以利用迹来求导至关重要）</p>
<p>设有两个矩阵，$A_{2\times3}$和$B_{3\times2}$</p>

$$
A = \left(
  \begin{array}{ccc}
    a_{11} & a_{12} & a_{13}\\ 
    a_{21} & a_{22} & a_{23}\\
  \end{array}
\right)
\quad B = \left(
  \begin{array}{cc}
    b_{11} & b_{12}\\ 
    b_{21} & b_{22}\\
    b_{31} & b_{32}\\
  \end{array}
\right)\\
$$

$$
AB = \left(
  \begin{array}{ccc}
    a_{11}b_{11}+a_{12}b_{21}+a_{13}b_{31} & a_{11}b_{12}+a_{12}b_{22}+a_{13}b_{32}\\ 
    a_{21}b_{11}+a_{22}b_{21}+a_{23}b_{31} & a_{21}b_{12}+a_{22}b_{22}+a_{23}b_{32}\\
  \end{array}
\right) \newline
tr(AB) = a_{11}b_{11}+a_{12}b_{21}+a_{13}b_{31}+a_{21}b_{12}+a_{22}b_{22}+a_{23}b_{32}
$$



<p>如果有$A &#x3D; B^T$，则两个矩阵相乘的迹等于<strong>对应位置的元素相乘并相加</strong>，可以理解为<strong>向量的点积</strong>在矩阵上的推广。</p>
<p>设有标量函数 $f(X), X_{m \times n}$，求$df(X)$</p>

$$
\begin{aligned}
\mathrm{d} f(\boldsymbol{X}) &=\frac{\partial f}{\partial x_{11}} \mathrm{~d} x_{11}+\frac{\partial f}{\partial x_{12}} \mathrm{~d} x_{12}+\cdots+\frac{\partial f}{\partial x_{1 n}} \mathrm{~d} x_{1 n} \\
&+\frac{\partial f}{\partial x_{21}} \mathrm{~d} x_{21}+\frac{\partial f}{\partial x_{22}} \mathrm{~d} x_{22}+\cdots+\frac{\partial f}{\partial x_{2 n}} \mathrm{~d} x_{2 n} \\
&+\cdots \\
&+\frac{\partial f}{\partial x_{m 1}} \mathrm{~d} x_{m 1}+\frac{\partial f}{\partial x_{m 2}} \mathrm{~d} x_{m 2}+\cdots+\frac{\partial f}{\partial x_{m n}} \mathrm{~d} x_{m n}
\end{aligned}
$$




可以发现，$df(X)$的结果其实就是两个矩阵$(\frac{\partial f}{\partial X_{ij}})_{i=1,j=1}^{m,n}$和$(dX_{ij})_{i=1,j=1}^{m,n}$对应位置相乘并相加，所以该式就可以写为迹的形式：




$$
\begin{aligned}
\mathrm{d} f(\boldsymbol{X}) &=\frac{\partial f}{\partial x_{11}} \mathrm{~d} x_{11}+\frac{\partial f}{\partial x_{12}} \mathrm{~d} x_{12}+\cdots+\frac{\partial f}{\partial x_{1 n}} \mathrm{~d} x_{1 n} \\
&+\frac{\partial f}{\partial x_{21}} \mathrm{~d} x_{21}+\frac{\partial f}{\partial x_{22}} \mathrm{~d} x_{22}+\cdots+\frac{\partial f}{\partial x_{2 n}} \mathrm{~d} x_{2 n} \\
&+\cdots \\
&+\frac{\partial f}{\partial x_{m 1}} \mathrm{~d} x_{m 1}+\frac{\partial f}{\partial x_{m 2}} \mathrm{~d} x_{m 2}+\cdots+\frac{\partial f}{\partial x_{m n}} \mathrm{~d} x_{m n} \\
&=\operatorname{tr}\left(\left[\begin{array}{cccc}
\frac{\partial f}{\partial x_{11}} & \frac{\partial f}{\partial x_{21}} & \cdots & \frac{\partial f}{\partial x_{m 1}} \\
\frac{\partial f}{\partial x_{12}} & \frac{\partial f}{\partial x_{22}} & \cdots & \frac{\partial f}{\partial x_{m 2}} \\
\vdots & \vdots & \vdots & \vdots \\
\frac{\partial f}{\partial x_{1 n}} & \frac{\partial f}{\partial x_{2 n}} & \cdots & \frac{\partial f}{\partial x_{m n}}
\end{array}\right]_{n \times m}\left[\begin{array}{cccc}
\mathrm{d} x_{11} & \mathrm{~d} x_{12} & \cdots & \mathrm{d} x_{1 n} \\
\mathrm{~d} x_{21} & \mathrm{~d} x_{22} & \cdots & \mathrm{d} x_{2 n} \\
\vdots & \vdots & \vdots & \vdots \\
\mathrm{d} x_{m 1} & \mathrm{~d} x_{m 2} & \cdots & \mathrm{d} x_{m n}
\end{array}\right]_{m \times n}\right)
\end{aligned}
$$


<p>所以就可以得出结论：$df(X)&#x3D; tr(\frac{\partial f(X)}{\partial X^T} dX)$</p>
<h3 id="如何使用矩阵微分求导"><a href="#如何使用矩阵微分求导" class="headerlink" title="如何使用矩阵微分求导"></a>如何使用矩阵微分求导</h3><p>对于实值标量函数$f(X)$，$tr(f(X)) &#x3D; f(X)$， $df(X) &#x3D; tr(df(X))$ ，所以有<br>$$<br>df(X) &#x3D; d(tr(f(X))) &#x3D; tr(df(X))<br>$$<br><em>上面的公式表明，迹和求微分是可以交换的</em></p>
<p>下面计算一个简单的例题：证明正面下面结论。</p>

$$
\begin{align*}
&\frac{\partial{tr(X^TX)}}{\partial{X}} = 2X \\
&\Rightarrow d(tr(X^TX)) = tr(dX^TX)\\
&=tr(dX^TX + X^TdX)\\
&=tr(dX^T X) + tr(X^TdX)\\
&=tr(XdX^T) + tr(X^TdX) = tr(X^TdX)+tr(X^TdX)\\
&=tr(2X^TdX)\\
&\Rightarrow \frac{\partial{tr(X^TX)}}{\partial{X}}=2X \\
&\Rightarrow \frac{\partial{tr(X^TX)}}{\partial{X^T}}=2X^T
\end{align*}
$$

]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>BP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Gnome 创建快捷方式</title>
    <url>/2022/04/28/Linux%E5%88%9B%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Linux Gnome桌面环境创建快捷方式图标的方法。</p>
<span id="more"></span>

<p>快捷方式格式</p>
<p>新建以<code>*.desktop</code>结尾的文件，例如，需要创立 <code>vitis</code> 程序的桌面快捷方式的内容如下：</p>
<p>程序执行的路径为:<code>/tools/Xilinx/Vitis/2022.2/bin/vitis</code></p>
<p>图标的路径为: <code>/tools/Xilinx/Vitis/2022.2/doc/images/ide_icon.png</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Desktop Entry]</span></span><br><span class="line"><span class="attr">Version</span>=<span class="number">1.0</span></span><br><span class="line"><span class="attr">Name</span>=vitis</span><br><span class="line"><span class="attr">Comment</span>=vitis</span><br><span class="line"><span class="attr">GenericName</span>=vitis</span><br><span class="line"><span class="attr">Type</span>=Application</span><br><span class="line"><span class="attr">Exec</span>=/tools/Xilinx/Vitis/<span class="number">2022.2</span>/bin/vitis   %u  </span><br><span class="line"><span class="attr">Icon</span>=/tools/Xilinx/Vitis/<span class="number">2022.2</span>/doc/images/ide_icon.png</span><br><span class="line"><span class="attr">Terminal</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">Categories</span>=GNOME<span class="comment">;Application</span></span><br></pre></td></tr></table></figure>

<p>编辑完成之后 右键点击该文件，<code>设为可执行</code></p>
<h2 id="添加到Gnome-启动台"><a href="#添加到Gnome-启动台" class="headerlink" title="添加到Gnome 启动台"></a>添加到Gnome 启动台</h2><p>编辑完成后可以将该文件复制到<code>/usr/share/applications</code>路径下面，就可以在启动台看到该应用程序了。</p>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib笔记</title>
    <url>/2022/10/17/Matplotlib%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>系统学习<code>matplotlib</code>的一些常见用法，节省需要用到的时候的搜索时间</p>
<span id="more"></span>

<p>框架结构，<code>Matplotlib</code>的架构分为三层，也就对应了几种代码画图风格。三个层分别为</p>
<ol>
<li>backend layer （最底层，没人使用）</li>
<li>artist layer （中层，灵活度很高，基本满足一切绘图要求）</li>
<li>scripting layer （高层，模仿Matlab 进行构建，但是不够灵活）</li>
</ol>
<p>常见的画图的代码通常包括两种风格：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)  </span><br><span class="line">plt.subplot(<span class="number">211</span>)   </span><br><span class="line">plt.plot(x0,y0)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)   </span><br><span class="line">plt.plot(x1,y1)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,figsize=(<span class="number">14</span>,<span class="number">7</span>))   </span><br><span class="line">ax[<span class="number">0</span>].plot(x0,y0)</span><br><span class="line">ax[<span class="number">1</span>].plot(x1,y2)</span><br></pre></td></tr></table></figure>

<p>这两种画图风格就分别对应了<code>scripting layer</code> 和 <code>artist layer</code>两个不同封装层次的API。第二种画图风格是 <code>Matplotlib</code>官方所推荐的OOP 的画图方式。</p>
<p>主要元素</p>
<p><img src="https://matplotlib.org/stable/_images/anatomy.png" alt="../../_images/anatomy.png"></p>
<h3 id="axes"><a href="#axes" class="headerlink" title="axes"></a>axes</h3><p><code>axes</code>并不是字面意义上的标轴，整个图像所能操作的区域都可以归为 <code>axes</code>。</p>
<p>Matplotlib uses <em>Axes</em> to refer to the drawing area that contains data, x- and y-axis, ticks, labels, title, etc.</p>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>MLP的BP推导与实现(下)</title>
    <url>/2022/04/05/MLP%E7%9A%84BP%E6%8E%A8%E5%AF%BC%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%8B/</url>
    <content><![CDATA[<p>上一篇文章学习矩阵求导的方法，这篇文章以上一篇文章为基础，推导一个三层的MLP的反向传播算法并给出它的代码实现。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进行推导前需要先列出几个后面需要使用的函数</p>
<p>首先是大名的鼎鼎的交叉熵（Cross Entropy）函数，它的定义如下，其中 $y$ 是独热码编码后的类别，$softmax$的函数输出可以衡量输出是每个类别的概率大小。</p>
<p><a name="pretext"></a></p>

$$
L = -y^T log(softmax(x))\\\\
softmax(\vec {x}) = \frac{e^{x_i}}{\sum_{j=1}^{K}e^{x_j}} \\\\
L^{'}(x) = softmax(\vec{x}) - \vec{y}
$$


<p>我们后面的激活函数采用比较常见的$\sigma$函数，它的定义和导数是</p>

$$
\begin{align}
\sigma(x) &= \frac{1}{1 + exp(x)} \\\\
\sigma(x)^{'} &= \sigma(x)(1-\sigma(x))
\end{align}
$$


<p>当然，后面的推导也不会使用$\sigma$函数求导的完整结果（因为太长了），而是用$\sigma^{‘}$表示，如果要更换$ReLu$或者别的激活函数，如只需要将求导结果带进去就可以了。</p>
<h2 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h2><p>假设我们的网络有 $n$层，$w_i$和$b_i$分别表示第$i$层的参数(wight)和偏置(bias)，使用$a_i$表示第$i$层还没有经过激活函数的结果，使用 $h_i$表示第$i$层的输出同时也是第$i+1$层的输入，也就是相当于$h_i &#x3D; \sigma(a_i)$， $\sigma$函数作为激活函数。整个网络的前向传播的$Loss$表达式可以写成下面的这种形式。</p>

$$
\begin{align}
L &= -y^T log(softmax(h_3)) \\\\

h_3 &= h_2w_3 + b_3 \\\\
a_2 &= h_1w_2 + b_2 \quad h_2 = \sigma(a_2) \\\\
a_1 &= h_0w_1 + b_1 \quad h_1 = \sigma(a_1) \\\\
h_0 &= x
\end{align}
$$


<p><strong>这里假设输入的向量$x$和输出向量$y$都是列向量</strong></p>
<p>当然，如果不定义符号进行替换的话就可以写成下面的这种比较长的形式。</p>

$$
L = -y^T log(softmax( \sigma(\sigma(xw_1 + b_1)w_2 + b_2)w_3 + b_3 ))
$$


<p>可以看到，MLP的本质其实就是我们最常见的复合函数的形式，只是我们的输入的变量$x$是一个向量或者矩阵的形式。我们的任务就是借助上一篇文章中所提到的矩阵求导的手段求出 $L$ 对每个$w_i$和$b_i$的偏导表达式。</p>
<h2 id="第三层推导"><a href="#第三层推导" class="headerlink" title="第三层推导"></a>第三层推导</h2><p>根据<a href="#pretext">前言</a>部分$log(softmax(x))$函数的求导，可以直接求得$h_3$的偏导数</p>

$$
\frac{\partial L }{\partial h_3} = softmax(h_3) -y
$$


<p>将 $dL$ 写成迹的形式</p>

$$
\begin{align}
tr(dL) &= tr((\frac{\partial L}{\partial h_3})^T dh_3) \\
&=tr((\frac{\partial L}{\partial h_3})^T d(h_2w_3 + b_3)) \\ 
&= \color{blue}{tr((\frac{\partial L}{\partial h_3})^T d(h_2w_3))} + \color{red}{tr((\frac{\partial L}{\partial h_3})^T d(b_3))}\\ 
\end{align}
$$



<p>通过红色的部分就得到了我们可以看到$L$关于$b_3$的微分形式，通过这个式子就可以写出$L$关于$b_3$的偏导数：</p>

$$
\frac{\partial L}{\partial b_3} = ((\frac{\partial L }{\partial h_3})^T)^T = \frac{\partial L }{\partial h_3}
$$


<p>将前面蓝色的部分单独写下来，继续经过变形</p>

$$
\begin{align*}
&\quad tr((\frac{\partial L}{\partial h_3})^T d(h_2w_3)) \\
&=tr((\frac{\partial L}{\partial h_3})^T d(h_2)w_3) + tr((\frac{\partial L}{\partial h_3})^T h_2d(w_3)) \\
&=\color{blue}{tr(w_3(\frac{\partial L}{\partial h_3})^T d(h_2))} + \color{red}{tr((\frac{\partial L}{\partial h_3})^T h_2d(w_3))} \\
\end{align*}
$$


<p>同样的由红色部分，我们可以得到$L$关于$w_3$的偏导，蓝色的部分我们后续的推导需要用。</p>

$$
\frac{\partial L}{\partial w_3} = (\frac{\partial L}{\partial h_3})^T h_2)^T = h_2^T \frac{\partial L}{\partial h_3}
$$


<p>到这里，我们第三层的所有参数 $w_3$和$b_3$的梯度我们都算出来了。</p>
<h2 id="第二层推导"><a href="#第二层推导" class="headerlink" title="第二层推导"></a>第二层推导</h2><p>接着把第三层推导剩下的蓝色部分单独提出来</p>

$$
\begin{align*}
& \quad tr(w_3(\frac{\partial L}{\partial h_3})^T d(h_2))\\
& = tr(w_3(\frac{\partial L}{\partial h_3})^T d(\sigma(a_2))) \\ 
& = tr(w_3(\frac{\partial L}{\partial h_3})^T \sigma^{'}(a_2) \odot d(a_2)) \\
\end{align*}
$$


<p>根据上篇文章提到的$tr(A^T (B \odot C)) &#x3D; tr((A \odot B)^T C)$可以化简为</p>

$$
\begin{align*}
& \quad tr(w_3(\frac{\partial L}{\partial h_3})^T \sigma^{'}(a_2) \odot d(a_2)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T)^T \sigma^{'}(a_2) \odot d(a_2)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d(a_2)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d(h_1w_2 + b_2)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d(h_1w_2)) + \color{red}{tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d( b_2))}\\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d(h_1)w_2) \\
\quad &+ \color{blue}{tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T h_1d(w_2))} + \color{red}{tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d( b_2))}\\
\end{align*}
$$


<p>可以得到</p>

$$
\frac{\partial L}{\partial w_2} = ((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T h_1)^T = h_1^T (\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))
$$

$$
\frac{\partial L}{\partial b_2} =\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)
$$



<h2 id="第一层推导"><a href="#第一层推导" class="headerlink" title="第一层推导"></a>第一层推导</h2><p>经过前两节的推导，我们得到了第二和第三层的表达式，但是他们的规律还不是非常的明显，我们继续推导第一层的偏导数。</p>

$$
\begin{align*}
&\quad  tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d(h_1)w_2) \\
& = tr(w_2 (\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T d(\sigma(a1)) \\
& = tr(w_2 (\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2))^T \sigma ^{'}(a1)\odot d(a1)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T )^T \sigma ^{'}(a1)\odot d(a1)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T d(h_0w_1 + b_1)) \\
& = tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T d(h_0w_1)) + tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T d(b_1)) \\
& = \color{blue}{tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T h_0d(w_1))} + \color{red}{tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T d(b_1))} \\
&+ tr((\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T d(h_0)w_1)\\
\end{align*}
$$


<p>可以得出</p>

$$
\begin{align}

\frac{\partial L}{\partial w_1} &= (\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))^T h_0)^T \\
& = h_0^T(\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1))
\end{align}
$$

$$
\frac{\partial L}{\partial b_2} =\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1)
$$



<h2 id="总结规律"><a href="#总结规律" class="headerlink" title="总结规律"></a>总结规律</h2><p>将分别将 $w_1, w_2, w_3$的偏导表达式写出来</p>

$$
\begin{align}
\frac{\partial L}{\partial w_1} &= h_0^T(\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1)) \\\\
\frac{\partial L}{\partial w_2} &= h_1^T (\frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)) \\\\
\frac{\partial L}{\partial w_3} &= h_2^T \frac{\partial L}{\partial h_3}
\end{align}
$$


<p>假设网络有 $n$层，编号依次为 1, 2 …，损失函数关于网络最终输出的偏导为$\frac{\partial L}{\partial out}$，可以比较明显地发现以下规律：</p>

$$
\frac{\partial L}{\partial w_{i}} = h_{i-1}^T\left[\frac{\partial L}{\partial out} \prod_{k=n}^{k=i+1}(w_{k}^T \odot \sigma^{'}(a_{k-1}))\right]
$$




<p><strong>注意:这里的连乘是倒序的</strong></p>
<p>$b_1,b_2,b_3$的表达式为</p>

$$
\begin{align}
\frac{\partial L}{\partial b_1} &= \frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2)w_2^T \odot  \sigma ^{'}(a1) \\\\
\frac{\partial L}{\partial b_2} &= \frac{\partial L}{\partial h_3} w_3^T\odot \sigma^{'}(a_2) \\\\
\frac{\partial L}{\partial b_3} &= \frac{\partial L}{\partial h_3}
\end{align}
$$


<p>跟$w_i$类似，写出关于$b_i$的偏导数，其实就是$w_i$的偏导数去掉前面的$h_{i-1}$</p>

$$
\frac{\partial L}{\partial w_{i}} = \frac{\partial L}{\partial out} \prod_{k=n}^{k=i+1}(w_{k}^T \odot \sigma^{'}(a_{k-1}))
$$


<p><strong>注意:这里的连乘是倒序的</strong></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>有了前面的推导过程，接下来就是代码的实现，代码将包含3个部分。</p>
<ul>
<li>数据准备</li>
<li>模型类实现</li>
<li>全连接层实现</li>
</ul>
<h3 id="测试和训练数据生成"><a href="#测试和训练数据生成" class="headerlink" title="测试和训练数据生成"></a>测试和训练数据生成</h3><p>在开始实现之前，我们需要先准备一些数据用于验证我们的模型工作是否正常。这里就直接实用<code>sklearn</code>库所提供的<code>make_classification</code>函数生成测试用的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N_CLASS = <span class="number">3</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line">x, y = make_classification(n_samples=<span class="number">2000</span>, n_features=<span class="number">5</span>, n_classes=N_CLASS,</span><br><span class="line">                           n_informative=<span class="number">5</span>, n_repeated=<span class="number">0</span>, n_redundant=<span class="number">0</span>, n_clusters_per_class=<span class="number">1</span>)</span><br><span class="line">sns.scatterplot(x=x[:,<span class="number">0</span>], y=x[:,<span class="number">1</span>], hue=y)</span><br></pre></td></tr></table></figure>

<p>测试用的数据将包含5个特征，也就是说输入的向量维度是5，总共有 3个类别</p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>BP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA时序约束</title>
    <url>/2023/03/22/Modelsim%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<p>（实习准备）学习如何使用 Modelsim 进行仿真。</p>
<span id="more"></span>

<h2 id="基本仿真流程指令"><a href="#基本仿真流程指令" class="headerlink" title="基本仿真流程指令"></a>基本仿真流程指令</h2><p>可以将需要执行的 指令放到一个 <code>*.do</code>文件中就执行后就直接可以进行仿真了。</p>
<p>可以直接拖拽 整个 <code>module</code>到波形窗口</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改变工作目录</span></span><br><span class="line"><span class="keyword">cd</span> /dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建仿真库文件</span></span><br><span class="line">vlib work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译源文件</span></span><br><span class="line">vlog *.v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行仿真</span></span><br><span class="line">vsim -novopt work.&lt;testbench&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行仿真</span></span><br><span class="line">run <span class="number">100</span>ns</span><br></pre></td></tr></table></figure>

<p>执行一个脚本的命令是</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">do test.do</span><br></pre></td></tr></table></figure>

<h2 id="常用的使用-GUI-的仿真流程"><a href="#常用的使用-GUI-的仿真流程" class="headerlink" title="常用的使用 GUI 的仿真流程"></a>常用的使用 GUI 的仿真流程</h2><ol>
<li>改变工作目录</li>
<li>新建工程</li>
<li>添加或者编写文件</li>
<li>编译文件</li>
<li>创建  <code>Simulation Configration</code></li>
</ol>
<p>modelsim 中不同的符号会有不同的含义（后面补充）</p>
<h2 id="Code-Coverage"><a href="#Code-Coverage" class="headerlink" title="Code Coverage"></a>Code Coverage</h2><p>ModelSim 的这功能可检查 经过仿真过后有多少的 代码是执行过，有多少是没有执行的。</p>
<p>如果需要做代码覆盖度检查，需要在编译的时候的命令需要改为</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">vopt +cover=becsxf test_sm -o test_sm_opt</span><br><span class="line">vsim -coverage test_sm_opt</span><br><span class="line">run <span class="number">1</span> ms</span><br></pre></td></tr></table></figure>

<p>可以选择 <code>compile prospereties</code> 在 <code>Converage</code>下面进行设置</p>
<h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><p>Debug 完成后通过右键选择信号添加到 Data Flow 窗口就可以看到</p>
<p>暂时不知道有什么用</p>
<h2 id="波形对比"><a href="#波形对比" class="headerlink" title="波形对比"></a>波形对比</h2><p>可以对比输出的波形是否符合测试条件</p>
<ol>
<li>生成基准波形的示例代码</li>
</ol>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">vlib work</span><br><span class="line">vlog *.v</span><br><span class="line">vopt +acc test_sm -o opt_test_gold</span><br><span class="line"><span class="comment"># 生成基准波形</span></span><br><span class="line">vsim -wlf gold.wlf opt_test_gold</span><br><span class="line">add wave *</span><br><span class="line">run <span class="number">750</span> ns</span><br><span class="line">quit -sim</span><br></pre></td></tr></table></figure>

<p>在需要对比波形的 仿真结束后选择 <code>tools</code>  -&gt; <code>Waveform Compare</code>-&gt; <code>Start Comprison</code> 选择完基准波形后就可以显示不一样的模型了。</p>
<h2 id="原理图生成"><a href="#原理图生成" class="headerlink" title="原理图生成"></a>原理图生成</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">vsim -debugdb work.&lt;test_bench&gt;</span><br></pre></td></tr></table></figure>

<p>执行完成会自动进入 仿真界面，选择<code>view</code>-&gt;<code>schematic</code></p>
<p><img src="https://i.imgur.com/6D6GiSF.png" alt="image-20230331221928539"></p>
<p>选择后点击展开视图就可以查看原理图了</p>
<p><img src="https://i.imgur.com/IQoW46j.png" alt="image-20230331222205738"></p>
<h2 id="设置VSCode-为默认编辑器"><a href="#设置VSCode-为默认编辑器" class="headerlink" title="设置VSCode 为默认编辑器"></a>设置VSCode 为默认编辑器</h2><p>新建一个<code>$HOME/.mentor/perf.tcl</code>文件，然后添加下面的内容</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> external_editor</span> &#123;<span class="keyword">filename</span> linenumber&#125; &#123; <span class="keyword">exec</span> <span class="string">&quot;code&quot;</span> -g <span class="variable">$filename</span>:<span class="variable">$linenumber</span>&#125;</span><br><span class="line"><span class="keyword">set</span> PrefSource(altEditor) external_editor</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.zshrc</code>或者 <code>~/.bashrc</code>里面添加环境变量，这样就可以在开启软件的时候自动更换外部编辑器了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export MODELSIM_TCL=&quot;$HOME/.mentor/perf.tcl&quot;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Logging 使用总结</title>
    <url>/2022/08/31/Python%20Log%20output/</url>
    <content><![CDATA[<p>在程序调试以及运行过程中 Log 都是分析程序运行的重要部分。本文记录了<code>python</code>的<code>logging</code>库的使用方法。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>logging</code>提供了方便的日志输出接口，可以指定将日志输出到控制台或者保存到文件，并提供了5种不同的输出日志输出等级：<code>DEBUG</code>&lt;<code>INFO</code>&lt;<code>WARNING</code>&lt;<code>ERROR</code>&lt;<code>CRITICAL</code>，可以为不同的输出方式（文件、控制台）等指定不同的输出等级，只有大于等于输出等级的日志才会被显示出来。</p>
<p><code>Logging</code>中包含了4个重要的对象</p>
<ul>
<li><code>Logger</code>    log操作的主要对象</li>
<li><code>Handler</code>    日志保存到地方（可以是控制台或者一个文件），一个 <code>logger</code>可以包括多个<code>Handler</code></li>
<li><code>Filter</code>      过滤日志的方法</li>
<li><code>Formatter</code>  指定日志输出的格式，可以为每个<code>Handler</code>单独指定不同的<code>Formatter</code></li>
</ul>
<h2 id="常见使用方法"><a href="#常见使用方法" class="headerlink" title="常见使用方法"></a>常见使用方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, logger</span><br><span class="line"><span class="comment"># 获取一个logger对象，可以指定logger 的名字，这个名字可以用来区分不同的logger输出</span></span><br><span class="line">logger = logging.Logger(<span class="string">&#x27;AmazeballsLogger&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置log控制台的输出，指定为sys.stdout，默认值是sys.stderr</span></span><br><span class="line">sh = logging.StreamHandler(sys.stdout)</span><br><span class="line"><span class="comment"># 添加控制台输出Handler到Logger</span></span><br><span class="line">logger.addHandler(sh)</span><br><span class="line"><span class="comment"># 设置log输出到一个文件</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">&quot;/path/to/file.log&quot;</span>, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件输出Handler到Logger</span></span><br><span class="line">logger.addHandler(sh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定全局输出的格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>)</span><br><span class="line">logger.handler.setFormatter(formatter)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Logger</code>初始化完毕后就可以使用<code>logger</code>提供的接口输出日志信息了，具体的使用方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.critical(<span class="string">&quot;critical&quot;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">logger.warning(<span class="string">&quot;warning&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">logger.debug(<span class="string">&quot;debug&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="指定输出等级"><a href="#指定输出等级" class="headerlink" title="指定输出等级"></a>指定输出等级</h2><p>当我们有一些信息只想保存在log文件但是不想显示在控制台中时，可以设置不同输出<code>Handler</code>的<code>Level</code>属性达到目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先设置全局的输出等级为最低，否则默认全局的最低输出等级是 WARNING,后面的设置都不会生效</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置控制台的日志输出等级，只有大于 WARNING 等级的日志会被输出到控制台</span></span><br><span class="line">sh.setLevel(logging.WARNING)</span><br><span class="line">logger.addHandler(sh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件的日志输出等级，只有大于 DEBUG 等级的日志会被保存到文件</span></span><br><span class="line">fh.setLevel(logging.DEBUG)</span><br><span class="line">logger.addHandler(fh)</span><br></pre></td></tr></table></figure>
<p>设置完成后执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.critical(<span class="string">&quot;critical&quot;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">logger.warning(<span class="string">&quot;warning&quot;</span>)</span><br><span class="line">logger.info(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">logger.debug(<span class="string">&quot;debug&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>控制台输出</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-04-13 17:52:57,729 - CRITICAL - critical</span><br><span class="line">2020-04-13 17:52:57,731 - ERROR - error</span><br><span class="line">2020-04-13 17:52:57,734 - WARNING - warning</span><br></pre></td></tr></table></figure>
<p><strong>文件输出</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-04-13 17:52:57,729 - CRITICAL - critical</span><br><span class="line">2020-04-13 17:52:57,731 - ERROR - error</span><br><span class="line">2020-04-13 17:52:57,734 - WARNING - warning</span><br><span class="line">2020-04-13 17:52:57,734 - INFO - info</span><br><span class="line">2020-04-13 17:52:57,734 - DEBUG - debug</span><br></pre></td></tr></table></figure>

<h2 id="设置输出格式"><a href="#设置输出格式" class="headerlink" title="设置输出格式"></a>设置输出格式</h2><p>可以使用不同的占位符设置log的显示日志</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %(asctime)s 输出时间，String</span></span><br><span class="line"><span class="comment"># %(filename)s 输出日志的源文件文件名，String</span></span><br><span class="line"><span class="comment"># %(lineno)d 输出日志的源文件所在文件的行数, Decimal</span></span><br><span class="line"><span class="comment"># %(levelname)s 输出等级, String</span></span><br><span class="line"><span class="comment"># %(message)s&quot; 输出信息内容 String</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&quot;[%(asctime)s][%(filename)s][line:%(lineno)d][%(levelname)s] %(message)s&quot;</span>)</span><br><span class="line">logger.handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独指定不同 Handler 的输出格式</span></span><br><span class="line">fh.setFormatter(logging.Formatter(<span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建深度学习环境</title>
    <url>/2022/03/13/docker%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>记录Docker的常见用法，主要是用在机器学习上。</p>
<span id="more"></span>

<h2 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker pull &lt;image_name&gt;</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除镜像</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker rmi &lt;image_id&gt;</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看本地已经下载的镜像</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker images <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">基本运行</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run &lt;image_name&gt;:tag &lt;commands&gt;</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run ubuntu:leatest /bin/echo <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">以后台模式运行(detach mode)</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -d &lt;image_name&gt; &lt;commands&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看运行中的container，可以查看Container <span class="built_in">id</span> 和 name</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker ps</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止和重启container</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker stop &lt;container_name&gt;</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker restart &lt;container_name&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">detach/ escape <span class="keyword">in</span> a iteractive containner</span></span><br><span class="line">&lt;C-p&gt;+&lt;C+q&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">attach to a container</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker attach &lt;container_name&gt;/&lt;container_id&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高级运行"><a href="#高级运行" class="headerlink" title="高级运行"></a>高级运行</h2><p>可以在执行 <code>run</code>命令的时候添加各种参数设置 container的各种参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker run &lt;parameters&gt; &lt;image_name&gt; &lt;commands&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;parameter list&gt;</span><br><span class="line">-it # 交互模式运行</span><br><span class="line">--name &lt;container_name&gt; # 指定container运行名字</span><br><span class="line">-v &lt;host_folder&gt;:&lt;container_folder&gt; # 映射宿主机文件夹到container，也就是 volume</span><br><span class="line">-p &lt;host_port&gt;:&lt;container_port&gt; # 映射container端口到宿主机</span><br></pre></td></tr></table></figure>

<p>给Container挂载GPU，在运行的时候添加参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--gpus all</span><br><span class="line"><span class="meta"># </span><span class="language-bash">or</span></span><br><span class="line">--runtime=nvidia</span><br></pre></td></tr></table></figure>

<p>最终运行例子，这里以运行 Pytorch 环境为例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --gpus all \</span><br><span class="line">--ipc=host</span><br><span class="line">-it \</span><br><span class="line">--name pytorch_yjm \</span><br><span class="line">-v /home/jiaming:/workspace \</span><br><span class="line">-p 8022:22 \</span><br><span class="line">pytorch/pytorch:1.9.0-cuda10.2-cudnn7-devel \</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="深度学习工具配置"><a href="#深度学习工具配置" class="headerlink" title="深度学习工具配置"></a>深度学习工具配置</h2><ul>
<li>配置SSH</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install update</span><br><span class="line">apt install -y openssh-server vim</span><br><span class="line">vim \etc\ssh\sshd_config # 配置ssh</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Port <span class="number">22</span></span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 root 密码，并重启ssh服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure>

<ul>
<li>炼丹专用库的安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install -y numpy seaborn opencv pandas</span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果需要使用 jupyter 的话</span></span><br><span class="line">conda install -y jupyter</span><br></pre></td></tr></table></figure>

<h2 id="Save-container-to-an-image"><a href="#Save-container-to-an-image" class="headerlink" title="Save container to an image"></a>Save container to an image</h2><p>我们以交互方式配置完环境后，为了不用每次都重新配置，可以将Container 保存为image。 这样每次只用Run一下这个镜像就可以了。自定镜像的方法有 通过<code>dockerfile</code>编译生成 和 通过 commit 的方式。这里展示 commit 的方式，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker commit -a <span class="string">&quot;author_name&quot;</span> -m <span class="string">&quot;messages&quot;</span> &lt;container_id&gt; &lt;save_image_name&gt;:&lt;tag&gt;</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker commit -a <span class="string">&quot;jiaming&quot;</span> -m <span class="string">&quot;pytorch&quot;</span> a404c6c174a2  mytorch:v1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog语法基础</title>
    <url>/2022/03/17/Verilog%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>学习Verilog的基本语法.</p>
<span id="more"></span>

<h2 id="电路的描述方式"><a href="#电路的描述方式" class="headerlink" title="电路的描述方式"></a>电路的描述方式</h2><p>verilog是描述电路的语言。为了实现系统的逻辑功能，在设计系统时可以采用多种描述方式进行建模。<code>verilog</code>通常使用三种不同的风格描述电路。在设计电路的时候可以任意使用一种或混合使用多种描述方式来描述电路。经过综合工具综合后的结果一般都是门级结构描述。</p>
<ol>
<li><strong>结构描述方式：</strong>调用其他已经定义好的低层模块对整个电路功能进行描述，或者直接调用<code>verilog</code>内部基本的门级元件描述电路的结构。</li>
<li><strong>数据流描述方式：</strong>设计者从数据在各存储单元之间进行流动和运算的角度对电路的功能进行描述。设计者可以使用<code>verilog</code>提供的高层次运算符，例如 <code>+</code>等直接对数据进行高层次的数学逻辑运算建模，而不用关心具体的门级电路结构。</li>
<li><strong>行为描述方式：</strong>直接根据电路的外部行为进行建模，与具体的硬件电路无关。</li>
</ol>
<h2 id="信号声明方式"><a href="#信号声明方式" class="headerlink" title="信号声明方式"></a>信号声明方式</h2><h3 id="数字表示方法"><a href="#数字表示方法" class="headerlink" title="数字表示方法"></a>数字表示方法</h3><p>整形数字的定义格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[-][&lt;位宽&gt;]&#x27;&lt;进制&gt;&lt;数值&gt;</span><br></pre></td></tr></table></figure>

<p>其中进制的标识符分别为：二进制（b或B）、八进制（o或O）十进制（d或D）、十六进制（h或H）。若省略进制则默认为十进制。</p>
<p><em>负号的标识需要在位宽的前面</em></p>
<p>数值还可以使用符号表示不定态</p>
<ul>
<li>x（X）表示未知状态</li>
<li>z（Z，？）表示高阻态</li>
</ul>
<p>一个 <code>x</code>或<code>z</code>可以分别表示十六进制中的四位，八进制中的三位，二进制的一位</p>
<h3 id="变量数据类型"><a href="#变量数据类型" class="headerlink" title="变量数据类型"></a>变量数据类型</h3><p><code>verlog</code>中的常量有三种类型</p>
<ol>
<li><code>parameter</code></li>
<li><code>wire</code></li>
<li><code>reg</code></li>
</ol>
<ul>
<li><p><code>parameter</code>类型</p>
<p>  <code>parameter</code>用于定义在不变的值，例如状态机中的状态、数学运算中的常数等。常量的类型包括三种：</p>
<ul>
<li>整数型常量 （可逻辑综合）</li>
<li>实数型常量 （用于逻辑仿真）</li>
<li>字符串型常量 （用于逻辑仿真）</li>
</ul>
<p>  声明方式如下：</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b10x0</span>			<span class="comment">// 4位二进制，第二位为不定值</span></span><br><span class="line"><span class="keyword">parameter</span> b=<span class="number">12&#x27;dz</span>			<span class="comment">// 12位十进制，全位为高阻态</span></span><br><span class="line"><span class="keyword">parameter</span> c=<span class="number">8&#x27;h4x</span>			<span class="comment">// 8位十六进制，低4位为不定值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>wire</code>类型</p>
<p>线网类型代表各个模块之间的物理连线，不能存储逻辑值，它的值由它的驱动元件决定，线网类型的默认值为高阻态z。<code>verilog</code>中所有的输入输出信号类型默认均为<code>wire</code>类型。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [位宽] 线网名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明例子</span></span><br><span class="line"><span class="keyword">wire</span> a;				<span class="comment">// 定义一个 1位 的wire</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] b;		<span class="comment">// 定义一个8 位的wire</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">1</span>] c, d;	<span class="comment">// 定义一个4 位的wire</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reg</code>类型</p>
<p>寄存器类型表示一个抽象的数据存储单元，它具有状态保存作用。寄存器类型只能在<code>initial</code>和<code>always</code>内部被赋值。在赋值前默认值为<code>x</code>。对于<code>reg</code>类型，赋值语句的作用就像改变一组触发器的存储单元的值。可以用各种构造控制改变值的时机，如上升沿、下降沿等。单个<code>reg</code>类型的声明格式如下，其中的 n 代表寄存器的位宽。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [位宽] 寄存器名称;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] a;		<span class="comment">// 声明一个 4 位的寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">1</span>] b;		<span class="comment">// 声明一个 4 位的寄存器</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p> $ git config –global init.defaultBranch main$ git branch -M main # 如果是已经新建了的仓库，修改当前的分支名称为 mainshell</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[msb:lsb] name;</span><br></pre></td></tr></table></figure>
<p>上面的<code>msb</code>和<code>lsb</code>分别代表向量的最高有效位和最低有效位。<code>msb</code>和<code>lsb</code>必须为常数、常数表达式或者parameter参数。</p>
<h3 id="变量数组"><a href="#变量数组" class="headerlink" title="变量数组"></a>变量数组</h3><p>线网和变量都可以声明为一个数组，数组中的每个元素可以是标量也可以是向量。数组的定义格式为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">数据类型 [位宽] 变量名称[地址范围]</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">wire</span> bus[<span class="number">5</span>:<span class="number">0</span>]; 			<span class="comment">//声明 6个位宽为 1 的wire 类型数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data[<span class="number">3</span>:<span class="number">0</span>]; 	<span class="comment">// 声明4个位宽为7 的reg 类型数组</span></span><br></pre></td></tr></table></figure>

<p>通过使用下标可以访问数组中特定的单元</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">data[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">data[<span class="number">3</span>] = <span class="number">8&#x27;hff</span>;</span><br></pre></td></tr></table></figure>

<p><strong>助记：</strong></p>
<p>位宽写在<code>wire</code>或者<code>reg</code>关键字后面则表示位宽，变量名后面则表示数组大小。如果位宽不写，则默认为1。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>verilog中支持的运算符与c语言中的运算符基本一致，但是由于<code>verilog</code>支持不定值的赋值方式，所以某些运算符的运算结果可能会不太一样。而且还有<code>verilog</code>中的所特有的运算符这里也会列出来。</p>
<h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><ol>
<li>在进程整数除法运算时，结果要略去小数的部分只取整数部分。</li>
<li>在进行取模运算时结果的符号位与第一个操作数的符号位一致。</li>
</ol>
<p><strong>注意：当所运算的操作数中含有不确定的值<code>x</code>或者<code>z</code>时算数运算的结果也是不确定的</strong></p>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ol>
<li><code>! &amp;&amp; ||</code>这三个逻辑运算符只有作用于 全 0 的操作数时才认为该操作数具有逻辑零的值，操作数中有任意多个1则认为该操作数为1，当操作数中含有<code>x</code>时则返回结果仍然为 <code>x</code>。</li>
<li>判断逻辑相等和不相等分为两种 ,逻辑相等<code>== !=</code>和逻辑全等<code>=== !==</code>，当进行<strong>相等运算</strong>时，两个操作数必须逐位相等，比较结果才为1（真），如果任意一个操作数含有不定态（X）或高祖态（Z），其相等比较的结果就会是不定值。进行<strong>全等运算</strong>时，对不定或高阻状态也进行比较，当两个操作数完全一致时，其结果才为1，否则为0.</li>
</ol>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li><p>在使用<code>~ &amp; | ^ ^~</code>等位运算符时，若两个操作数的位宽不相等，则会自动将操作数在右端对齐，位数少的操作数相应的高位会使用0进行填充。</p>
</li>
<li><p>移位操作，移位操作分为两种，移位运算符 <code>&gt;&gt;</code>，<code>&lt;&lt;</code>，<strong>算术移位运算符</strong><code>&lt;&lt;&lt;</code>,<code>&gt;&gt;&gt;</code>。</p>
<p>对于左移操作中出现的空位，都使用 0 开进行填充，在进行右移操作时，<strong>算术移位会使用符号位进行填充</strong>。</p>
<p>需要注意<code>&gt;&gt;&gt;</code>作用于有符号数，左边会补符号位；<code>&lt;&lt;&lt;</code>作用于有符号数，右边补<code>0</code>，符号位也被移走；</p>
<p><strong>注意事项：</strong></p>
<p><em>左移会导致位宽增加，右移位宽不变。</em></p>
</li>
</ul>
<h3 id="拼接与缩位"><a href="#拼接与缩位" class="headerlink" title="拼接与缩位"></a>拼接与缩位</h3><p>下面列举<code>verilog</code>中所特有的运算符。</p>
<ul>
<li><p>拼接运算符：可以将两个或多个信号的某些为进行拼接表示一个整体信号。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">&#123;a, b[<span class="number">3</span>:<span class="number">0</span>], w, <span class="number">3&#x27;b101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将信号复制再进行拼接</span></span><br><span class="line">&#123;<span class="number">4</span>&#123;w&#125;&#125; <span class="comment">// 等同于 </span></span><br><span class="line">&#123;w, w, w, w&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缩位运算符：缩位运算符的符号与位运算符的符号一样，但缩位运算符是针对当个操作数的，对当个操作数从左到右按照位的顺序两两进行相应的运算。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4&#x27;b0101</span>;</span><br><span class="line"></span><br><span class="line">&amp;a			<span class="comment">//  0</span></span><br><span class="line">|a 			<span class="comment">// 1</span></span><br><span class="line">^a			<span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="程序的基本结构"><a href="#程序的基本结构" class="headerlink" title="程序的基本结构"></a>程序的基本结构</h2><h3 id="结构化描述"><a href="#结构化描述" class="headerlink" title="结构化描述"></a>结构化描述</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里演示全加器的实现</span></span><br><span class="line"><span class="comment">// 可以按照以下格式声明端口</span></span><br><span class="line"><span class="comment">// 输入输出方向 信号类型[位宽] 信号名;</span></span><br><span class="line"><span class="keyword">module</span> fadder</span><br><span class="line">(</span><br><span class="line">	i_A, i_B, i_Cin,</span><br><span class="line">    o_S, o_C</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">input</span> i_A, i_B, i_Cin; <span class="comment">// 输入端口</span></span><br><span class="line">	<span class="keyword">output</span> o_S, o_C; <span class="comment">// 输出端口</span></span><br><span class="line">	<span class="keyword">parameter</span> s_delay=<span class="number">1</span>, c_delay=<span class="number">1</span>; <span class="comment">// 定义两个参数，参数也可以代表常量</span></span><br><span class="line">	<span class="keyword">assign</span> #s_delay o_S = i_A ^ i_B ^ i_Cin; <span class="comment">// 延时s_delay </span></span><br><span class="line">    <span class="keyword">assign</span> #c_delay o_C = (i_A ^ i_B) &amp; i_Cin | (i_A &amp; i_B) <span class="comment">// 延时c_delay </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>当需要调用已经写好的模块或者IP时（类似于函数调用），需要例化模块，并传递信号。</p>
<p>例化模块的基本语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">模块名 实例名 (.端口名<span class="number">1</span>(连线<span class="number">1</span>), .端口名<span class="number">2</span>(连线<span class="number">2</span>), ...)；</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<p>在顶层文件使用被调用模块的端口时，如果端口声明为<code>input</code>，则向该端口传递的信号可以是<code>wire</code>或者<code>reg</code>类型。如果端口声明为<code>output</code>，则向该端口传递的信号必须是<code>wire</code>类型。</p>
<p>一个完整地例化模块调用过程：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fadder_delay_1</span><br><span class="line">(</span><br><span class="line">	i_A, i_B, i_Cin,</span><br><span class="line">    o_S, o_C</span><br><span class="line">)</span><br><span class="line">	<span class="comment">// 实例化一个模块并设置其中的参数</span></span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    fadder fadder_delay_1_ins(<span class="variable">.i_A</span>(i_A), <span class="variable">.i_B</span>(i_B), <span class="variable">.i_Cin</span>(i_Cin), <span class="variable">.o_S</span>(o_S), o_C(o_C));</span><br><span class="line">    <span class="keyword">defparam</span> fadder_delay_1_ins<span class="variable">.s_delay</span>=<span class="number">2</span>, fadder_delay_1_ins<span class="variable">.c_delay</span>=<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    fadder <span class="variable">#(2,3)</span> </span><br><span class="line">    	fadder_delay_1_ins(<span class="variable">.i_A</span>(i_A), <span class="variable">.i_B</span>(i_B), <span class="variable">.i_Cin</span>(i_Cin), <span class="variable">.o_S</span>(o_S), o_C(o_C));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三种方式</span></span><br><span class="line">    fadder <span class="variable">#(.s_delay(2),.c_delay(3))</span></span><br><span class="line">    	fadder_delay_1_ins(<span class="variable">.i_A</span>(i_A), <span class="variable">.i_B</span>(i_B), <span class="variable">.i_Cin</span>(i_Cin), <span class="variable">.o_S</span>(o_S), o_C(o_C));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="数据流描述"><a href="#数据流描述" class="headerlink" title="数据流描述"></a>数据流描述</h3><p>在使用数据流描述电路时通常使用连续赋值语句实现。连续赋值语句必须以 <code>assign</code>开头，出现在和门单元实例化相同的代码层次，它的结构为</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> [delay] wire_type_var=expression;</span><br></pre></td></tr></table></figure>

<p>使用数据流的方式描述一个4位的加法器</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> adder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b, <span class="keyword">input</span> cin, <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] sum, <span class="keyword">output</span> cout;</span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> &#123;cout,sum&#125; = a+b+cin;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>在进行逻辑综合时，综合器会自动优化综合出来的门电路。</p>
<h3 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a>行为描述</h3><p>行为描述一般使用<code>initial</code>和<code>always</code>过程块结构。</p>
<ul>
<li><p>initial过程块</p>
<p>主要用于仿真测试，用来对变量进行初始化或者产生激励波形，过程块中的内容只会被执行一次，一个<code>module</code>可以有多个<code>initial</code>块结构，各个<code>initial</code>过程块之间并行运行。若块中的语句没有添加延时控制，则可以延时指定的时钟周期后再执行后续指令。</p>
<p><em>initial过程块不能进行逻辑综合</em></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	#延时数 行为语句; </span><br><span class="line">    #延时数 行为语句; </span><br><span class="line">    ..</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">a=<span class="number">4&#x27;b0000</span>; 		<span class="comment">// 缺省为在0时刻执行该代码</span></span><br><span class="line">#<span class="number">5</span> a=<span class="number">4&#x27;b0001</span> 	<span class="comment">// 经过5个时间单位后执行赋值</span></span><br><span class="line">#<span class="number">5</span> a=<span class="number">4&#x27;b0010</span> 	<span class="comment">// 经过 10 个时间单位后执行赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>always 过程块，always 过程块会一致被重复执行，多个<code>always</code>过程块并行执行，与书写顺序无关。</p>
<p><code>@</code>中包含的敏感信号可为电平触发或者逻辑变量触发，使用电平触发时可以使用 <code>posedge</code>和<code>negedge</code>表示上升沿和下降沿。</p>
<p>在<code>always</code>过程块中执行的赋值语句，等号左边必须为<code>reg</code>类型。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (敏感信号列表) <span class="comment">// always @(*) 代表任意信号变化(电平变化)时都会发生的操作</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    行为语句<span class="number">1</span>;</span><br><span class="line">    行为语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)					<span class="comment">// 只在上升沿触发执行</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> clk)	<span class="comment">// 在上升沿和下降沿都执行	</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><p>由于<code>verilog</code>程序所描述的是电路结构，具有天然的并行特性，因此对变量的赋值于软件编程语言存在非常大的不同。</p>
<p><strong>使用准则：</strong></p>
<ol>
<li>在描述组合逻辑的 <code>always</code> 块中使用阻塞赋值 <code>=</code>, 综合成组合逻辑电路结构，这种电路的输出结果只和输入的电平变化有关。</li>
<li>在描述时序逻辑的 <code>always</code>块中使用非阻塞赋值 <code>&lt;=</code>, 综合成时序逻辑电路结构，这种电路的结构往往和触发沿有关，当触发沿满足条件时才发生变化。</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>在同一个 always 块中不能混用阻塞赋值和非阻塞赋值</li>
<li>不允许在多个 always 块中对同一个变量进行赋值</li>
</ol>
<p>下面通过两个例子帮助理解两种赋值方式的不同。</p>
<h3 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h3><p>所谓阻塞的概念是指，在同一个always块中，<em>后面的赋值语句是在前一句赋值语句结束后才开始赋值的</em>。例如下面的示例</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> CLK_i <span class="keyword">or</span> <span class="keyword">negedge</span> RSTn_i)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(!RSTn_i)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          a = <span class="number">1</span>;</span><br><span class="line">          b = <span class="number">2</span>;</span><br><span class="line">          c = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          a = <span class="number">0</span>;</span><br><span class="line">          b = a;</span><br><span class="line">          c = b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在复位结束后，有 <code>a = 1; b = 2; c = 3;</code></p>
<p>第一个上升沿到来的时候，有<code>a = 0; b = 0; c = 0;</code>，而后的结果就不会再发生变化了。</p>
<h3 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h3><p>所谓非阻塞的概念是指，在计算非阻塞赋值的RHS以及更新LHS期间，允许其他的非阻塞赋值语句同时计算RHS和更新LHS。</p>
<p><em>右边表达式是同一时间计算出来的，并同时更新左边的表达式， 即右边表达式通过组合逻辑计算出来后，马上所存到DFF中</em></p>
<p>备注： RHS - &gt; 右边的表达式； LHS - &gt; 左边的表达式；</p>
<ul>
<li><p><code>always</code>开始时，先计算右边表达式的值</p>
</li>
<li><p><code>always</code>结束后才更新左边表达式的值，只能下次<code>always</code>执行时才能感知到变量的变化</p>
</li>
</ul>
<p>将阻塞赋值的例子修改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> CLK_i <span class="keyword">or</span> <span class="keyword">negedge</span> RSTn_i)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(!RSTn_i)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          a &lt;= <span class="number">1</span>;</span><br><span class="line">          b &lt;= <span class="number">2</span>;</span><br><span class="line">          c &lt;= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          a &lt;= <span class="number">0</span>;</span><br><span class="line">          b &lt;= a;</span><br><span class="line">          c &lt;= b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>复位结束后，值与阻塞赋值相同，有 <code>a = 1; b = 2; c = 3;</code></p>
<p>当第一个上升沿到达时，有<code>a = 0; b = 1; c = 2;</code></p>
<p>当第二个上升沿到达时，有<code>a = 0; b = 0; c = 1;</code></p>
<p>当第三个上升沿到达时，有<code>a = 0; b = 0; c = 0;</code>，而后的结果就不会再发生变化了。</p>
<p>可以看到，当使用非阻塞赋值时，右侧的表达式的值是在同一时刻确定的，而阻塞赋值则存在一个先后次序关系。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>条件判断语句属于过程描述语句，不能单独用来描述组合逻辑电路，<code>if</code>和<code>case</code>语句只能出现在<code>always</code>语句内，如果需要使用条件判断语句描述组合逻辑电路，可以在<code>always @(*)</code>中进行书写，在综合时会生成多路选择器。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (w1)</span><br><span class="line">        <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// expression</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> (w2)</span><br><span class="line">        a1: <span class="comment">//...</span></span><br><span class="line">        a2: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果只含有一个判断变量可以使用三元表达式进行描述，在综合的时候会生成 一个 2选1 的多路选择器。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> w1 = (c1) ? a1 : a2; <span class="comment">// c1 为真则选择 a1 输出，否则选择 a2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意（避免生成Latch）：</strong></p>
<p>使用条件判断语句描述组合逻辑电路时需要对所有可能的情况都要进行描述描述，因为<code>verilog</code>对于没有指定条件的输出采用的”维持输出不变“的原则，此时就需要电路具有状态保持功能，但是组合逻辑电路中并没有”记忆原件“，因此就会在综合的时候为组合逻辑电路加上锁存器（Latch）以”记住“此时的状态。</p>
<h3 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h3><p>逻辑判断使用<code>if () ... else if () ... else</code> 语句表示。具体的语法和c 语言的差不多，这是在书写多条语句的时候需要使用 <code>begin ... end</code>括起来。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    expression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condistion1)</span><br><span class="line">    expression1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    expression2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condistion1)</span><br><span class="line">    expression1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condistion2)</span><br><span class="line">    expression2;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    expression3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h3><p>多条件判断时可以使用 <code>case</code> 语句，它的使用格式是</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">var</span>)</span><br><span class="line">            condition1: expression1;</span><br><span class="line">            condition2: expression2;</span><br><span class="line">            defualt: defualt_expression;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持不定态的casex</span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">casex</span> (in)</span><br><span class="line">            <span class="number">4&#x27;bxxx1</span>: pos &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;bxx10</span>: pos &lt;= <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="number">4&#x27;bx100</span>: pos &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="number">4&#x27;b1000</span>: pos &lt;= <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="keyword">default</span>: pos &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>尽量避免使用 <code>casex</code>语句，可以使用<code>casez</code>语句。</p>
<p><strong>注意：</strong></p>
<ol>
<li>分支表达式的值互不相同</li>
<li>所有表达式的位宽必须相等，不3能使用 ‘bx 代替 n’bx</li>
<li>当不需要考虑 x 和 高阻时 使用  <code>casex ... endcase</code></li>
<li>当不需要考虑 高阻时 使用 <code>casez ... endcase</code></li>
<li>0 !&#x3D; x or z</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>软件开发的高级语言大多提供了<code>for</code>或<code>while</code>等循环流程控制语句。<code>verilog</code>中也提供了<code>for</code>语句，但是在HDL语言中，循环执行的操作一般通过时序逻辑电路完成，<code>for</code>语句一般只用在testbench 中进行数据生成，在RTL编程中很少进行使用。</p>
<p>主要原因就是<code>for</code>循环会被综合器做并行展开，每个变量独立占用寄存器资源，如果不能很好地考虑运行逻辑，会造成资源的极大浪费。</p>
<p>常见使用格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    counter = <span class="number">&#x27;b0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (counter&lt;=<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span> ;</span><br><span class="line">        counter = counter + <span class="number">1&#x27;b1</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="生成语句"><a href="#生成语句" class="headerlink" title="生成语句"></a>生成语句</h2><ol>
<li>批量生成语句</li>
</ol>
<p>2001标准中新加入的<code>generate</code>语句可以批量例化多个模块，并设置其中的连线。<code>genvar</code>声明了<code>generatate</code>块中使用的变量名。</p>
<p>具体格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> i; <span class="comment">// 标识变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">for</span>(init; condistion; next)<span class="keyword">begin</span>:module_name</span><br><span class="line">        <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>for</code>中的表达式和C语言中时一样的，只是关键字<code>begin</code>后面需要跟一个<code>module_name</code>，该名称指明了<code>generate</code>所生成模块的名称，可以通过<code>module_name[index]</code>的方式的访问实例化生成的模块。</p>
<p>例如: </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> i;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">generate</span> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">510</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span> :ut</span><br><span class="line">        relu110 u(<span class="variable">.l</span>(q[i+<span class="number">1</span>]), <span class="variable">.c</span>(q[i]), <span class="variable">.r</span>(q[i-<span class="number">1</span>]), <span class="variable">.n</span>(q_next[i])); </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：不能将<code>generate for</code>语句放在 <code>always</code>语句中</strong></p>
<ol start="2">
<li>条件生成语句</li>
</ol>
<p>条件生成语句包括 <code>generate if </code>和<code>generate case</code>两种。</p>
<p><code>generate if</code>语句的格式</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">begin</span>: Name1</span><br><span class="line">		<span class="comment">//expression</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>: Name2</span><br><span class="line">		<span class="comment">//expression</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p><code>case</code> 语句的格式</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span></span><br><span class="line">	<span class="keyword">case</span> (&lt;constant_expression&gt;)</span><br><span class="line">     	&lt;value&gt;: <span class="keyword">begin</span>: &lt;label_1&gt;</span><br><span class="line">                 &lt;code&gt;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">     	&lt;value&gt;: <span class="keyword">begin</span>: &lt;label_2&gt;</span><br><span class="line">                 &lt;code&gt;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">     	<span class="keyword">default</span>: <span class="keyword">begin</span>: &lt;label_3&gt;</span><br><span class="line">                 &lt;code&gt;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<p>注意： 这段表达是在编译时生效的，因此 condition 应该满足以下几个条件</p>
<ul>
<li><p>条件表达式必须是参数或宏定义。</p>
</li>
<li><p>条件表达式必须在编译时求值。</p>
</li>
</ul>
<ol start="3">
<li>生成语句的嵌套</li>
</ol>
<p><code>generate for </code>语句中可以嵌套<code>if</code>和<code>case</code>语句用于判断，这样可以提升生成语句的灵活性。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">generate</span> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">511</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span> :ut</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            relu110 u(<span class="variable">.l</span>(q[i+<span class="number">1</span>]), <span class="variable">.c</span>(q[i]), <span class="variable">.r</span>(<span class="number">1&#x27;b0</span>), <span class="variable">.n</span>(q_next[i]));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">511</span>)</span><br><span class="line">            relu110 u(<span class="variable">.l</span>(<span class="number">1&#x27;b0</span>), <span class="variable">.c</span>(q[i]), <span class="variable">.r</span>(q[i-<span class="number">1</span>]), <span class="variable">.n</span>(q_next[i]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            relu110 u(<span class="variable">.l</span>(q[i+<span class="number">1</span>]), <span class="variable">.c</span>(q[i]), <span class="variable">.r</span>(q[i-<span class="number">1</span>]), <span class="variable">.n</span>(q_next[i])); </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<h2 id="属性语法"><a href="#属性语法" class="headerlink" title="属性语法"></a>属性语法</h2><p>属性语法不直接影响模块的逻辑行为，但它们可以提供有关模块和其实例的信息，以帮助综合工具和其他工具正确处理设计。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告诉综合工具保留指定的信号或模块，即使它们似乎没有被使用, 方便进行调试查看</span></span><br><span class="line">(* KEEP=<span class="string">&quot;TRUE&quot;</span>*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉综合工具不要修改指定的信号或模块，并且不要尝试进行优化。</span></span><br><span class="line">(* DONT_TOUCH=<span class="string">&quot;TRUE&quot;</span>*)</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> func1(<span class="keyword">integer</span> pa) </span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// expresion</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是返回值</span></span><br><span class="line">        func1 = <span class="comment">//expression; </span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>



<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><ol>
<li>变量索引与部分选择</li>
</ol>
<p>part-select 即引用数组中一个元素的某几位。</p>
<p>例：<code>reg [9:0]</code> <code>a[9:0]</code> 引用第0个元素的后四位：<code>a[0][0+:4]</code> 或 <code>a[0][3-:4]</code>，其中 <code>-:</code>和<code>+:</code> <strong>左边可以是常数或者变量，右边必须是常数</strong>。(这个会很有用，可以省很多时间写部分索引)</p>
<ol start="2">
<li><code>1’sb1</code>表示 -1，<code>1’sb0 </code>表示 0</li>
<li>单纯的十进制数为 32bit interger 有符号数</li>
<li><code>±</code>运算赋值运算 所有操作数是有符号数，那么结果才是有符号数。</li>
</ol>
<h2 id="编程规范："><a href="#编程规范：" class="headerlink" title="编程规范："></a>编程规范：</h2><p>总结<code>verilog</code>的编程规范，一共10条。</p>
<ol>
<li>不要太多的 if—else 嵌套</li>
<li>不要编写过于庞大的状态机</li>
<li>复杂的状态机，可以采用 2 段式以上的实现</li>
<li>尽量使用时序逻辑完成编程</li>
<li>使用组合逻辑不要过于庞大</li>
<li>复杂代码拆分简单模块</li>
<li>复杂计算，增加流水设计</li>
<li>高速模块和低速模块搭配使用</li>
<li>case 语句一定有 default</li>
<li>组合逻辑有 if 必须有 else 防止产生锁存器，锁存器所以出毛刺</li>
</ol>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>linux shell脚本基础</title>
    <url>/2022/04/10/linux-shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>备课😳，复习（预习）一下<code>shell</code>脚本的基本语法。</p>
<span id="more"></span>

<h2 id="shell基本语法"><a href="#shell基本语法" class="headerlink" title="shell基本语法"></a>shell基本语法</h2><hr>
<p><code>shell</code>脚本可以将完成一个任务的所有命令按照执行的先后顺序，自上而下地写入到一个文件，并给予执行权限。</p>
<h3 id="脚本运行方法"><a href="#脚本运行方法" class="headerlink" title="脚本运行方法"></a>脚本运行方法</h3><ul>
<li>赋予运行权限</li>
<li>使用<code>bash</code>执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x demo.sh</span><br><span class="line">./demo.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">或者</span> </span><br><span class="line">bash demo1.sh</span><br></pre></td></tr></table></figure>

<h3 id="shell常用符号"><a href="#shell常用符号" class="headerlink" title="shell常用符号"></a>shell常用符号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~:			# home 目录</span><br><span class="line">!: 			# 执行历史命令，!! 执行上一条命令</span><br><span class="line">$:			# 变量取内容符，$USER</span><br><span class="line">+ - * / % 		# 加减乘除</span><br><span class="line">&amp;:			# 后台运行</span><br><span class="line">*:			# 通配符，匹配所有</span><br><span class="line">?:			# 通配符，匹配除回车外的一个字符</span><br><span class="line">;:			# 一行执行多个指令的时候用作分割</span><br><span class="line">|:			# 管道符，将上一个命令的输出作为下一个命令的输入</span><br><span class="line">\:			# 转义字符</span><br><span class="line">``:			# 反引号，在命令中执行命令，可类比于python中的exec()函数</span><br><span class="line">&#x27;:			# 单引号，shell中的字符串需要使用 单引号括起来，与双引号不同的是单引号不解释变量 &#x27;$USER&#x27;</span><br><span class="line">&quot;:			# 双引号，脚本中出现的字符可以使用双引号括起来 &quot;$USER&quot; 会解释变量</span><br><span class="line">&gt;:			# 输出重定向符  只用一个 &gt; 会覆盖文件 ，用两个 &gt;&gt; 会追加文件</span><br><span class="line">&lt;:			# 输出重定向符，只用一个 就是只输入一次，两个 &lt;&lt; 就是追加输入（可以用于交互式的命令输入例如fdosk），使用 &lt;&lt;EOF表示结束书输入</span><br><span class="line">$?:			# 通过上一个命令的 exit code判断上一条命令是否执行成功，为0则代表执行成功，否则为执行失败。expr 1 + 1 &amp;&gt;/dev/null; echo $?可以用分号分隔上一个命令，从而达到判断执行是否成功的作用 </span><br></pre></td></tr></table></figure>

<h3 id="shell-数学运算"><a href="#shell-数学运算" class="headerlink" title="shell 数学运算"></a>shell 数学运算</h3><p><code>shell</code>中完成数学运算的方式有很多种</p>
<ul>
<li><code>expr</code>表达式</li>
<li><code>let</code>表达式。</li>
<li><code>(())</code>表达式</li>
</ul>
<p><strong>注意1：expr 表达式中运算符的前后必须要有空格</strong></p>
<p><strong>注意2：expr 表达式中使用乘运算符 * 时需要使用转义符</strong></p>
<p><strong>注意3：let 表达式中&#x3D;前后不能有空格</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">expr</span> 表达式</span></span><br><span class="line">expr 1 + 1</span><br><span class="line">expr 1 - 1</span><br><span class="line">expr 3 \* 4</span><br><span class="line">expr 9 / 3</span><br><span class="line">expr 10 % 3</span><br><span class="line"><span class="meta"># </span><span class="language-bash">`<span class="built_in">let</span>`可以完成同样的功能，但必须要一个变量缓存计算结果</span></span><br><span class="line">let sum=1+2</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(()) 中对表达式没有要求,使用乘法时也不需要转义</span></span><br><span class="line">echo $((1+1))</span><br><span class="line">echo $((100 * 3))</span><br></pre></td></tr></table></figure>

<p>当运算中需要<strong>使用小数</strong>时，可以使用管道运算符<code>|</code>配合<code>bc</code>命令完成 <em>（bc可能需要单独安装 ）</em></p>
<p><code>bc</code>中使用<code>scale=n</code>制定保留小数的位数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;scale=2;100/3&quot;|bc</span><br><span class="line"><span class="meta"># </span><span class="language-bash">上面的输出为 33.33</span></span><br><span class="line"></span><br><span class="line">echo &quot;当前内存占用为: `echo &quot;scale=2;100/3&quot;|bc`%&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">当前内存占用为 33.33%</span></span><br></pre></td></tr></table></figure>

<h3 id="shell退出"><a href="#shell退出" class="headerlink" title="shell退出"></a>shell退出</h3><p>exit code 的范围为8位，即0-255</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit 0 # 表示正常退出</span><br><span class="line"></span><br><span class="line">echo $? # 查看上一条指令是否正常执行并退出</span><br></pre></td></tr></table></figure>

<h3 id="shell-输入输出"><a href="#shell-输入输出" class="headerlink" title="shell 输入输出"></a>shell 输入输出</h3><p><code>read</code>命令可以从终端读入内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read acc # 将输出内容保存到 变量acc中</span><br><span class="line">read -s passwd # 输出内容保存到 passwd中，且输入的时候输入内容不回显,一般用于密码输入</span><br><span class="line">read -p &quot;这里是提示:&quot; abc #-p 指定输入时的提示</span><br><span class="line">read -n6 abc # 输入的长度只能为6</span><br><span class="line">read -t5 abc # 只能在 5s 内输入，超过时间后执行下一行</span><br></pre></td></tr></table></figure>

<p><code>echo</code>命令的作用是在显示器中输出一段提示文字。常用用法和参数如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world!&quot; # 普通输出，输出后换行</span><br><span class="line">echo -n &quot;hello world!&quot; # 输出后不换行</span><br><span class="line">echo -e &quot;\t abc&quot; # 输出字符串中包含有特殊的转义字符时使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h2><h3 id="变量的分类与定义语法"><a href="#变量的分类与定义语法" class="headerlink" title="变量的分类与定义语法"></a>变量的分类与定义语法</h3><p><code>shell</code>中变量类型分为三种，其中本地和全局变量都属于环境变量。</p>
<ol>
<li>本地变量：用户私有变量，只有本用户读取或修改，保存在<code>.bash_profile</code>和<code>.bashrc</code>文件中</li>
<li>全局变量：所有用户都可以使用，保存在<code>/etc/profile</code>和&#x2F;<code>etc/.bashrc</code>中</li>
<li>用户自定义变量：用户自定变量，例如在脚本中定义的变量</li>
</ol>
<p>变量名在定义时不需要加<code>$</code>，但是在使用的时候需要加<code>$</code>符号。</p>
<p>定义变量的格式为：<strong>变量名&#x3D;值</strong>。将变量设置成全局变量的时候需要加上前缀 <code>export</code></p>
<p><strong>注意：变量名和等号之间不能有空格</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">定义一个临时变量，在终端关闭或者重启之后该变量会被清除</span></span><br><span class="line">VAR1=1</span><br><span class="line">AGE=18</span><br><span class="line"><span class="meta"># </span><span class="language-bash">手动清除一个变量</span></span><br><span class="line">unset VAR1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">定义一个全局变量</span></span><br><span class="line">export GENDER=&#x27;MALE&#x27;</span><br></pre></td></tr></table></figure>

<p><em>变量名最好全部写成大写以示区分</em></p>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>数组可以将一系列的内容保存到同一个变量中，在访问时通过下标进行访问。</p>
<p>定义数组：数组名称&#x3D;(元素1 元素2 元素3 ….)</p>
<p>各个元素之间通过空格隔开。</p>
<p>数组的访问 : ${数组[下标]}， 下标从0开始</p>
<p><strong>注意: bash 默认下标从0开始，但是zsh的下标默认从1开始</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">单个赋值</span></span><br><span class="line">arr0[0]=&#x27;abc&#x27;</span><br><span class="line">arr0[1]=&#x27;def&#x27;</span><br><span class="line"></span><br><span class="line">arr1=(&#x27;tom&#x27; &#x27;jack&#x27; &#x27;rose&#x27;) # 连续赋值</span><br><span class="line">arr1=(`cat /etc/passwd`) # 将文件的行读入作为一个数组</span><br><span class="line"></span><br><span class="line">echo $&#123;arr1[@]&#125; # @ 符号代表数组所有的成员</span><br><span class="line">echo $&#123;#arr1[@]&#125; # 获取数组的长度</span><br><span class="line">echo $&#123;!arr1[@]&#125; # 打印数组的索引，备注:zsh不支持</span><br><span class="line">echo $&#123;arr1[@]:1&#125; # 切片，从1开始的元素</span><br><span class="line">echo $&#123;arr1[@]:1:2&#125; # 切片，从1开始访问两个元素</span><br></pre></td></tr></table></figure>

<p><code>shell</code>中的关联数组可以类比字典类型，可以自定义索引访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -A r_arr</span><br><span class="line"><span class="meta"># </span><span class="language-bash">连续赋值</span></span><br><span class="line">r_arr=([name]=&#x27;tom&#x27; [age]=&#x27;18&#x27;)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">或者单独赋值</span></span><br><span class="line">r_arr=([gender]=&#x27;male&#x27;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">访问关联数组</span></span><br><span class="line">echo &quot;$&#123;r_arr[name]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><hr>
<h3 id="常见的运算符号"><a href="#常见的运算符号" class="headerlink" title="常见的运算符号"></a>常见的运算符号</h3><p><code>shell</code>中没有 <code>&gt;=,&lt;=</code> 之类的判断符号，<strong>整数数学的比较运算运算符</strong>有下面这些</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-eq				等于</span><br><span class="line">-gt				大于</span><br><span class="line">-lt				小于</span><br><span class="line">-ge				大于或等于</span><br><span class="line">-le				小于或等于</span><br><span class="line">-ne				不等于</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">用法</span></span><br><span class="line">test 1 -q 1;echo $?</span><br></pre></td></tr></table></figure>

<p>常见的文件的判断运算符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-d 				检查文件是否存在且为目录</span><br><span class="line">-e 				检查文件是否存在</span><br><span class="line">-f 				检查文件是否存在且为文件</span><br><span class="line">-r 				检查文件是否存在且可读</span><br><span class="line">-w 				检查文件是否存在且可写</span><br><span class="line">-x				检查文件是否存在且可执行</span><br></pre></td></tr></table></figure>

<p>常见的字符串比较运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">==				等于</span><br><span class="line">!=				不等于</span><br><span class="line">-n 				检查字符串长度是否大于0</span><br><span class="line">-z				检查字符串长度是否为0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">用法</span></span><br><span class="line">test -z &quot;&quot;; echo $?</span><br><span class="line">test &#x27;abc&#x27;==&#x27;bcd&#x27;;echo $?</span><br></pre></td></tr></table></figure>

<p>逻辑运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!				取反</span><br><span class="line">&amp;&amp;				逻辑与</span><br><span class="line">|| 				逻辑或</span><br></pre></td></tr></table></figure>

<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if</code>语句的格式如下，condition中可以使用前面所提到的逻辑运算符将条件连接起来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">else</span><br><span class="line">	commands</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">elif [  ]</span><br><span class="line">	commands</span><br><span class="line">else</span><br><span class="line">	commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>用法举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">可以使用 <span class="variable">$1</span> ，<span class="variable">$2</span> 等变量获取传入的命令行参数</span></span><br><span class="line">if [ $1 -eq $2 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;等于&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;不等于&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><p>第一种<code>for</code>语句的语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in value1 value2</span><br><span class="line">do</span><br><span class="line">	commands</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="language-bash">例子,<span class="built_in">seq</span> 是一个shell 命令，可以生成指定范围内的数字序列</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">1 直接赋值</span></span><br><span class="line">for x in 1 2 3 4 5 6 7 8 9</span><br><span class="line">	do</span><br><span class="line">	echo $&#123;x&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2 使用 shell 命令赋值</span></span><br><span class="line">for var in `seq 1 9`</span><br><span class="line">do </span><br><span class="line">	echo $&#123;var&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">seq</span> 的用法</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">seq</span> [start] [step] [end]</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">seq</span> [start] [end]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3 可以直接用字符串赋值，使用 空格分隔</span></span><br><span class="line">for var in hello peter, i\&#x27;m Doctor Octopus</span><br><span class="line">	do</span><br><span class="line">	echo $var</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种<code>for</code>语句的语法, 类似于 C语言的写法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=1;i&lt;10;i++))</span><br><span class="line">	do</span><br><span class="line">	echo $&#123;i&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以由多个条件，condition 两边记得加空格</span></span><br><span class="line">for (( a=1,b=1;a&lt;100;a++,b++ ))</span><br><span class="line">	do</span><br><span class="line">	echo &quot;$&#123;a&#125;,$&#123;b&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="while-和-until-循环"><a href="#while-和-until-循环" class="headerlink" title="while 和 until 循环"></a>while 和 until 循环</h3><p><code>while</code>语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">例子</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><code>until</code>语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">用法</span></span><br><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h3><p>当有多个分支时除了可以使用<code>if elif ...</code>这种结构还可以使用 <code>case</code>语句进行分支选择</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case value in</span><br><span class="line">pattern1)</span><br><span class="line">	commands</span><br><span class="line">;;</span><br><span class="line">pattern2)</span><br><span class="line">	commands</span><br><span class="line">;;</span><br><span class="line">...</span><br><span class="line">*）</span><br><span class="line">	commands</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">例子</span></span><br><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p>流程控制一般包含有 <code>continue</code>和<code>break</code>语句用于控制循环的执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while		# 不加任何条件语句则表示死循环</span><br><span class="line">	do</span><br><span class="line">	read a</span><br><span class="line">	if [ a -eq 0]</span><br><span class="line">		then</span><br><span class="line">		break</span><br><span class="line">    elif [ a -eq 1 ]</span><br><span class="line">    	continue</span><br><span class="line">    else</span><br><span class="line">    	echo &quot;your number is $&#123;a&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><hr>
<p>定义函数的语法有两种,分别为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">语法一</span></span><br><span class="line">func_name ()</span><br><span class="line">&#123;</span><br><span class="line">	commands</span><br><span class="line">	return N</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">语法二</span></span><br><span class="line">function func_name ()</span><br><span class="line">&#123;</span><br><span class="line">	commands</span><br><span class="line">	return N</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">函数参数例子</span></span><br><span class="line">function hell0_func ()</span><br><span class="line">&#123;</span><br><span class="line">	echo &quot;hello $1&quot; 	# $1 代表第一个函数参数，$0是当前的脚本文件名</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="language-bash"><span class="comment">#						# 函数的参数个数</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">?						<span class="comment"># 最后一个命令的退出状态，为 0 表示没有错误</span></span>					</span><br></pre></td></tr></table></figure>

<p>调用函数的方法比较奇怪，不需要加<code>()</code>,需要传参的话直接写在后面就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">函数传参的例子</span></span><br><span class="line">hello_func alex			</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">带返回值函数调用的例子</span></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile基础</title>
    <url>/2022/04/11/makefile%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>继续备课，复习makefile的基础知识</p>
<span id="more"></span>

<p>Makefile 是由 make 命令引用的文本文件，它描述了目标的构建方式，并包含诸如源文件级依赖关系以及构建顺序依赖关系之类的信息。</p>
<h2 id="makefile基本结构"><a href="#makefile基本结构" class="headerlink" title="makefile基本结构"></a>makefile基本结构</h2><p>makefile的基本结构包括三个部分</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">	[TAB]command</span><br></pre></td></tr></table></figure>

<ul>
<li><p>target</p>
<p>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）</p>
</li>
<li><p>prerequisites</p>
<p>生成该target所依赖的文件或target</p>
</li>
<li><p>command</p>
<p>生成target需要执行的命令，一般为<code>shell</code>命令，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</p>
</li>
</ul>
<p><strong>注意：command前面的TAB是必须的</strong></p>
<h2 id="makefile基本示例"><a href="#makefile基本示例" class="headerlink" title="makefile基本示例"></a>makefile基本示例</h2><p>首先在一个目录下新建,<code>main.c</code>,<code>func1.c</code>,<code>func1.h</code>三个文件。其中<code>main.c</code>文件依赖于<code>func1.c</code>文件中的<code>func1</code>函数。在目录中新建一个<code>makefile</code>，写入如下内容。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: main.o func1.o</span></span><br><span class="line">	gcc -o main1 func1.o main.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc -c main.c</span><br><span class="line"><span class="section">func1.o: func1.c func1.h</span></span><br><span class="line">	gcc -c func1.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o</span><br></pre></td></tr></table></figure>

<p>在终端<code>cd</code>进入目录之后，执行<code>make</code>命令就可以将直接编译出可执行文件<code>main1</code>。</p>
<p>也可以手动执行<code>make all</code>指令指定生成，当没有为<code>make</code>指定生成的target 时，则默认选择第一个target。</p>
<p>使用 <code>make clean</code>可以删除编译中生成的<code>.o</code>结尾的中间文件。</p>
<h2 id="makefile中的变量"><a href="#makefile中的变量" class="headerlink" title="makefile中的变量"></a>makefile中的变量</h2><p>可以看到虽然上一节中使用<code>makefile</code>简化了编译所输入的命令，但是所编写的 <code>makefile</code>中含有很多 <code>.o</code>结尾的prerequisites，当所依赖的文件过多时，<code>makefile</code>就会变的非常复杂，为了进一步简化书写，可以使用变量简化<code>makefile</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o </span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(objects)</span></span><br><span class="line">    gcc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    gcc -c command.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas教程</title>
    <url>/2022/03/29/pandas%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>这是很久之前在Kaggle上学的，写了一些笔记，但还少一篇比较全面的总结，这篇文章相当于补上了。</p>
<span id="more"></span>

<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p><code>DataFrame</code>是<code>pandas</code>里面最基本的数据结构和操作单元，<code>pandas</code>所有的操作都是围绕它来进行的。<code>DataFrame</code>可以理解为一个类似于Excel的多维的数据表，可以存储并操作表格型的数据。</p>
<ul>
<li><code>df.index</code>代表的是行编号</li>
<li><code>df.columns</code>代表的是列编号</li>
</ul>
<h3 id="新建DataFrame"><a href="#新建DataFrame" class="headerlink" title="新建DataFrame"></a>新建DataFrame</h3><p>新建 DataFrame的方式一般有以下几种：</p>
<ol>
<li><p>通过一维的<code>list</code>或者<code>numpy.ndarrys</code>创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">df = pd.DataFrame(data) <span class="comment">#输出是一列</span></span><br><span class="line"><span class="comment"># 二维</span></span><br><span class="line">data = [[<span class="string">&#x27;Alex&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Clarke&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>]) <span class="comment">#可以指定列名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过字典创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两列元素的长度需要相同</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125; </span><br><span class="line">df = pd.DataFrame(data) <span class="comment"># 这里默认的 index 就是 range(n)，n 是列表的长度</span></span><br><span class="line"><span class="comment"># 可以指定行的名称</span></span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;rank1&#x27;</span>,<span class="string">&#x27;rank2&#x27;</span>,<span class="string">&#x27;rank3&#x27;</span>,<span class="string">&#x27;rank4&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Series</p>
<p><code>pd.Series</code> 可以表示 <code>dataframe</code>中的一列，可以将<code>pd.Series</code>组成一个字典或者列表再初始化得到一个<code>dataframe</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"><span class="comment"># one 列的最后一行会补全为 NaN</span></span><br><span class="line">df = pd.DataFrame(d)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p><code>dataframe</code>有很多非常有用的属性，可以快速地分析一个表格数据，这里分别列举出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.describe() <span class="comment"># 计算数据中的数值型的一些常见统计信息(以列为单位)</span></span><br><span class="line">df1.index <span class="comment"># 返回 行索引</span></span><br><span class="line">df1.columns <span class="comment"># 返回列索引</span></span><br><span class="line">df1.values <span class="comment"># 返回所有的值，以array的形式</span></span><br><span class="line">df1.T <span class="comment">#返回 转置结果</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>使用<code>panda</code>提供的方法可以非常快速地对表格进行操作</p>
<p>假设我们有这样一个表格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">date_index=pd.date_range(<span class="string">&#x27;20211020&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">3</span>), index=date_index, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/bYZ4kvL.png" alt="image-20220408214411140"></p>
<p>按照列方向进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/3k5y9Rk.png" alt="image-20220408214558146"></p>
<p>按照某个列的值进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.sort_values(by=<span class="string">&#x27;a&#x27;</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/BDgO5xP.png" alt="image-20220408214706887"></p>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><p>对表中的某个元素进行访问也是一个常用的操作，<code>pandas</code>提供了多种方式完成这个操作</p>
<ol>
<li><code>df.loc</code>以标签的形式访问</li>
<li><code>df.iloc</code>使用整数索引进行访问</li>
</ol>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread并行程序开发基础</title>
    <url>/2022/04/23/pthread%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>备课，复习 pthread 的使用，内容包括pthread 的基础知识以及并发所需要的PV操作</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>POSIX Threads</strong>（Portable Operating System Interface）, commonly known as <strong>pthreads</strong>, is an <a href="https://en.wikipedia.org/wiki/Execution_model">execution model</a> that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a <em><a href="https://en.wikipedia.org/wiki/Thread_(computing)">thread</a></em>, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</p>
<ul>
<li>是一种独立于编程语言的程序并行运行模型</li>
<li>控制程序的并行工作流（线程）</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在编写<code>pthread</code>程序的第一步就是导入头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>	<span class="comment">// pthread api</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>		<span class="comment">// posix system 中通用的api</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> 	<span class="comment">// 信号量操作相关</span></span></span><br></pre></td></tr></table></figure>

<p>使用 gcc 编译的时候需要加上 <code>-lpthread</code>参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc demo1.c -lpthread -o demo1</span><br></pre></td></tr></table></figure>

<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>进程创建可以使用以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *thread_id,<span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),<span class="type">void</span> *arg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>thread_id</code>是进程的唯一标识符</li>
<li><code>attr_t</code> 设置进程的属性，可以设置想进程的调度策略，堆栈相关信息，可以设置为默认值 <code>NULL</code></li>
<li><code>start_routine</code>是线程开始运行的函数指针，函数指针的原型包括一个<code>void</code>类型的形参指针</li>
<li><code>arg</code>设置线程运行时传递的参数，可以在线程开始运行时传递用户自定义参数</li>
</ul>
<p>在进程运行过程中可以使用<code>pthread_self</code>获取当前线程的标识符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> tid = pthread_self();</span><br></pre></td></tr></table></figure>

<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>当一个进程可以通过<code>return </code>或者 <code>pthread_exit()</code>方式结束自身的运行。</p>
<p>一个线程结束，只是说它结束了运行状态，但是并不意味着它的所有信息都已经消失。</p>
<p>可以通过 调用 <code>pthread_cancel</code>函数结束其他进程，但前提是需要获得需要结束进程的进程标识符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cancel(<span class="type">pthread_t</span>)</span><br></pre></td></tr></table></figure>

<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步算是OS 里面比较重要的内容了，<code>pthread</code>提供了很多 API 供我们使用。</p>
<p><code>pthread_join(pthread_t tid, void* revalue)</code>可以阻塞当前线程并等待一个线程运行完毕再重新运行该进程。<code>revalue</code>是进程运行结束所返回的结果。</p>
<h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>为了解决多个线程同时访问同一个内存问题，常用的<code>mutex</code>互斥锁方式可以通过定义一个<code>pthread_mutex_t</code>变量解决，它的使用方式如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> buff_mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;buff_mutex);</span><br><span class="line">    <span class="comment">// 访问内存</span></span><br><span class="line">    buff_count++;</span><br><span class="line">    pthread_mutex_unlock(&amp;buff_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;buff_mutex);</span><br><span class="line">    <span class="comment">// 访问内存</span></span><br><span class="line">    buff_count--;</span><br><span class="line">    pthread_mutex_unlock(&amp;buff_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;buff_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;buff_mutex);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_destroy(&amp;buff_mutex); <span class="comment">// 使用完成后需要销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用之前需要先调用 <code>pthread_mutex_init</code>初始化，当某个线程需要访问临界区时，使用 <code>pthread_mutex_lock(&amp;count_mutex);</code>进入临界区，结束访问临界区后使用 <code>pthread_mutex_unlock(&amp;count_mutex)</code>退出临界区访问。<code>mutex</code>使用完成后需要调用 <code>pthread_mutex_destroy</code>将mutex销毁。</p>
<h3 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h3><p>理论上<code>mutex </code>可以当做一个 <code>semaphore=1</code>的信号量使用，在一定程度上两者是等价的,<code>Mutex</code>管理的是资源的访问，而<code>Semaphore</code>管理的是资源的数量。</p>
<p>信号量可以根据资源的数量控制进程的访问。例如著名的生产者消费者问题，假设缓冲区数量为N</p>
<ul>
<li>当缓冲区中的资源数目小于N，生产者就可以不断生产，但当生产的资源数等于N，生产者就要停止生产，并等待消费者进行消费。</li>
<li>当缓冲区中资源的数目大于N，消费者就可以不断消费直到资源的数目等于0，消费者就要阻塞直到生产者生产出货物。</li>
</ul>
<p>Linux中可以使用<code>semaphore.h</code>头文件中提供的API 完成PV线程同步操作。下面的代码就是实现生产者消费者问题的代码。其中<code>sem_t</code>定义了一个信号量，定义信号量后调用 <code>sem_init()</code>初始化信号量的值。 <code>sem_wait()</code>相当于 P操作，<code>sem_post()</code>相当于V操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者消费者问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> buff_mutex; <span class="comment">// 创建一个互斥锁</span></span><br><span class="line"><span class="type">int</span> buff_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> buff[<span class="number">10</span>];</span><br><span class="line"><span class="type">sem_t</span> empty, full; <span class="comment">// 声明信号量</span></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// P(full)</span></span><br><span class="line">        pthread_mutex_lock(&amp;buff_mutex);</span><br><span class="line">        buff[buff_count] = <span class="number">0</span>;</span><br><span class="line">        buff_count--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[consumer thread] buffer count %d&quot;</span>, buff_count); <span class="comment">// 打印当前的缓冲区信息</span></span><br><span class="line">        pthread_mutex_unlock(&amp;buff_mutex);</span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// V(empty)</span></span><br><span class="line">        sleep(<span class="number">2</span>); <span class="comment">//假设每次消费需要 2 秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// P(empty)</span></span><br><span class="line">        pthread_mutex_lock(&amp;buff_mutex); <span class="comment">// 进入临界区</span></span><br><span class="line">        buff[buff_count] = <span class="number">1</span>;</span><br><span class="line">        buff_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[consumer thread] buffer count %d&quot;</span>, buff_count); <span class="comment">// 打印当前的缓冲区信息</span></span><br><span class="line">        pthread_mutex_unlock(&amp;buff_mutex); <span class="comment">// 退出临界区</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">//v(full)</span></span><br><span class="line">        sleep(<span class="number">3</span>); <span class="comment">// 假设每次生成需要 3 秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p_id, c_id;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;buff_mutex, <span class="literal">NULL</span>); <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 初始化，第三个参数为信号量初值</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;p_id, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>); <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    pthread_create(&amp;c_id, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(p_id, <span class="literal">NULL</span>); <span class="comment">// 阻塞当前线程，等待生产者和消费者线程执行完毕</span></span><br><span class="line">    pthread_join(c_id, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;buff_mutex); <span class="comment">// 使用完后需要销毁</span></span><br><span class="line">    sem_destroy(&amp;empty); <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;full);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch的张量扩展机制</title>
    <url>/2022/09/13/pytorch%E7%9A%84%E5%BC%A0%E9%87%8F%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>复现华为2020年的论文<a href="https://paperswithcode.com/paper/addernet-do-we-really-need-multiplications-in">AdderNet</a>,在编码过程中涉及到了<code>pytorch</code>中张量的扩展机制，这里记录一下踩到的坑。</p>
<span id="more"></span>

<h2 id="张量扩展机制"><a href="#张量扩展机制" class="headerlink" title="张量扩展机制"></a>张量扩展机制</h2><p><code>Pytorch</code>中的大部分算术操作都是支持维度扩展的：即使两个张量的维度不相等，但只要两个张量的维度满足一定的条件，在进行运算时<code>python</code>会自动对这两个张量的数据进行扩展，使它们的维度相等，扩展后再进行加减操作。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=torch.tensor([[<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>],[<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>]]) <span class="comment"># size= 1 x 2 x3</span></span><br><span class="line">b=torch.tensor([[<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>]]) <span class="comment"># size= 1 x 3</span></span><br><span class="line">a - b</span><br></pre></td></tr></table></figure>

<p>得出的结果是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>]]]) </span><br><span class="line"><span class="comment"># size= 1 x 2 x 3</span></span><br></pre></td></tr></table></figure>

<p>两个张量需要满足的条件为：</p>
<ul>
<li>每个张量至少含有一个维度</li>
<li>在对张量进行迭代运算时，会从最末尾的维度对齐后开始迭代，迭代到某一个维度时，两个张量此时的维度必须以下的三个条件之一：<ul>
<li>相等</li>
<li>有一个维度为1</li>
<li>有一个张量此时的维度不存在</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=torch.randn(<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.randn(  <span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 =&gt; 1 满足条件</span></span><br><span class="line"><span class="comment"># 4 =&gt; 1 满足条件</span></span><br><span class="line"><span class="comment"># 3 =&gt; 3 满足条件</span></span><br><span class="line"><span class="comment"># 5 =&gt; None 满足条件</span></span><br><span class="line"><span class="comment"># 此时就可以执行</span></span><br><span class="line">z = x - y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反例</span></span><br><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.empty(  <span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 =&gt; 1 满足条件</span></span><br><span class="line"><span class="comment"># 4 =&gt; 1 满足条件</span></span><br><span class="line"><span class="comment"># 2 =&gt; 3 不满足条件</span></span><br><span class="line"><span class="comment"># 5 =&gt; None 满足条件</span></span><br><span class="line"><span class="comment"># 此时执行下面的代码就会报错</span></span><br><span class="line">z = x - y</span><br></pre></td></tr></table></figure>

<h2 id="张量扩展后的运算规则"><a href="#张量扩展后的运算规则" class="headerlink" title="张量扩展后的运算规则"></a>张量扩展后的运算规则</h2><p>如果两个张量满足了维度扩展的条件(broadcastable)，通过运算得到的结果的尺寸为</p>
<ul>
<li>如果x和y的维数不相等，在维数较少的张量的维数上预加1，使其长度相等 （对应第三种情况）</li>
<li>对于每个维度的大小，所产生的维度大小是沿该维度的x和y的大小的最大值。</li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux使用总结</title>
    <url>/2022/04/28/tmux%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><code>tmux</code>（终端复用器）是连接<code>SSH</code>远程连接服务器时比较常用的工具。本文记录它的常用使用方法。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>tmux</strong> is an <a href="https://en.wikipedia.org/wiki/Open-source">open-source</a> <a href="https://en.wikipedia.org/wiki/Terminal_multiplexer">terminal multiplexer</a> for <a href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> <a href="https://en.wikipedia.org/wiki/Operating_system">operating systems</a>. It allows multiple <a href="https://en.wikipedia.org/wiki/Computer_terminal">terminal</a> sessions to be accessed simultaneously in a single window. It is useful for running more than one <a href="https://en.wikipedia.org/wiki/Command-line_interface">command-line</a> program at the same time. It can also be used to detach <a href="https://en.wikipedia.org/wiki/Process_(computing)">processes</a> from their controlling terminals, allowing remote sessions to remain active without being visible.</p>
<p><code>tmux</code>具有的特点有：</p>
<ul>
<li>可以在一个窗口同时访问多个终端对话</li>
<li>每个会话都可以<code>detach</code>在后台运行</li>
</ul>
<p><code>tmux</code>的控制层次分为三个部分，从上到下为依次包含的关系。</p>
<ul>
<li>sessions</li>
<li>windows</li>
<li>panel</li>
</ul>
<p>一个<code>session</code>可以包含多个<code>window</code>一个<code>window</code>可以切分成若干个<code>panel</code>。这里盗用一张图</p>
<p><img src="http://louiszhai.github.io/docImages/tmux01.png" alt="tmux层级"></p>
<p>安装完<code>tmux</code>之后，直接在终端里面输入 <code>tmux</code>就可以出现上面这个界面了</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>session</code>的相关操作，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">直接输入 tmux 默认创建一个 新的 session</span></span><br><span class="line">tmux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建一个指定名字的session，注意这里的 session_name 不需要双引号</span></span><br><span class="line">tmux new -s session_name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">detach session 将当前会话转到后台运行，或者使用 快捷键 &lt;CTRL&gt;+B d</span></span><br><span class="line">tmux detach </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">恢复连接一个会话</span></span><br><span class="line">tmux a -t session_name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看当前tmux 的所有会话</span></span><br><span class="line">tmux ls </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">退出一个 session</span></span><br><span class="line">tmux kill-session -t session_name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">退出服务/ 关闭所有 session</span></span><br><span class="line">tmux kill-server</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/5ID4LYF.png" alt="image-20220428151116378"></p>
<p>如果当前处在一个 <code>session </code>中可以使用快捷键 <code>&lt;CTRL&gt;+B s </code>进入会话选择界面，通过方向键或者<code>hjkl</code>选择需要进入的会话，按下<code>ENTER</code>进入。</p>
<p><strong>session操作快捷键总结：</strong></p>
<p><code>tmux</code>中所有的命令都需要前缀按键，即<code>&lt;CTRL&gt;-B</code>，命令基本就下面这两个就够用了。</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">命令描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s</td>
<td align="center">显示当前的会话列表，用于选择切换</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">将当前会话转到后台运行</td>
</tr>
</tbody></table>
<p><strong>window操作快捷键总结：</strong></p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">命令描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">显示所有会话中的窗口列表</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">在当前会话中新建一个窗口</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">删除当前窗口,需要 y&#x2F;n 确认</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">切换到上一个窗口</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">切换到下一个窗口</td>
</tr>
</tbody></table>
<p><strong>panel操作快捷键总结</strong></p>
<p>panel就是第一个图那里，将一个<code>window</code>划分为多个区域，每个区域就称为一个<code>panel</code></p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">命令描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">横向等分当前区域为两个panel</td>
</tr>
<tr>
<td align="center">“</td>
<td align="center">纵向等分当前区域为两个panel</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">关闭当前面板,需要 y&#x2F;n确认</td>
</tr>
<tr>
<td align="center">方向键</td>
<td align="center">切换当前panel 的交点</td>
</tr>
<tr>
<td align="center">Alt+方向键</td>
<td align="center">调整当前Panel的长宽等</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">显示当前面板的编号，通过按下数字键完成切换</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">将当前面包最大化，再进行一个则恢复原样</td>
</tr>
</tbody></table>
<p>如果划分了很多panel, 希望panel 可以水平或者垂直均匀分布，可以使用以下快捷键</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">命令描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Alt + 1</td>
<td align="center">将所有panel 水平均匀分布</td>
</tr>
<tr>
<td align="center">Alt + 2</td>
<td align="center">将所有panel 垂直均匀分布</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>tqdm常用方法总结</title>
    <url>/2022/04/27/tqdm%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><code>tqdm</code>可以非常方便地在控制台或者<code>jupyter notebook</code>上面显示一个进度条,通过进度条我们可以很方便地观察当前运行任务的进度，处理速度等信息。</p>
<span id="more"></span>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>如果任务是需要遍历一个<code>List</code>或者其他的一些可以迭代的对象，可以直接将<code>tqdm()</code>包裹到可迭代对象上面上再通过for循环就可以在控制台显示出当前循环进行的进度条了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> tqdm([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]):</span><br><span class="line">    text = text + char</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果只是需要range，还可以直接使用trange()函数直接代替range</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h2 id="自定义显示信息"><a href="#自定义显示信息" class="headerlink" title="自定义显示信息"></a>自定义显示信息</h2><p>因为<code>tqdm</code>中实现了<code>__enter__()</code>和<code>__exit__()</code>两个方法，所以可以直接使用<code>with</code>表达式获取到 <code>tqdm</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 可以在初始化的时候设置进度条相应的参数</span></span><br><span class="line"><span class="keyword">with</span> tqdm(total, ncols=<span class="number">100</span>, position=<span class="number">0</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    pbar.set_description(<span class="string">f&quot;description&quot;</span>) <span class="comment"># 也可以在 with 范围内 使用 set_xxxx 实时设置进度条的参数</span></span><br></pre></td></tr></table></figure>

<p>如果不想用 <code>with</code>多嵌套一层代码，特别是想显示多个进度条，使用多个<code>with</code>就会显得很不优雅，其实<code>with</code>主要是为了控制变量的作用范围，<code>tqdm</code>本身是可以直接当做对象进行初始化的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_tqdm = tqdm(total=<span class="number">100</span>, ncols=<span class="number">100</span>, position=<span class="number">0</span>, leave=<span class="literal">False</span>,colour=<span class="string">&#x27;red&#x27;</span>) <span class="comment"># 设置进度条显示到第0行</span></span><br><span class="line">_tqdm1 = tqdm(total=<span class="number">1000</span>, ncols=<span class="number">100</span>, position=<span class="number">1</span>, colour=<span class="string">&#x27;green&#x27;</span>) <span class="comment"># 设置进度条显示到第1行，保证两个进度条错开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    _tqdm.set_description(<span class="string">f&quot;epoch <span class="subst">&#123;x&#125;</span>&quot;</span>) <span class="comment"># 进度条前面显示的东西</span></span><br><span class="line">    _tqdm.update(<span class="number">1</span>) <span class="comment"># 这里控制每次增加 1</span></span><br><span class="line">    _tqdm.set_postfix(epoch=<span class="string">f&quot;<span class="subst">&#123;x&#125;</span>&quot;</span>) <span class="comment"># 进度条后面显示的信息输入参数是字典</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        _tqdm1.update(<span class="number">1</span>) </span><br><span class="line">        _tqdm1.set_postfix(epoch=<span class="string">f&quot;<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line">    _tqdm1.n = <span class="number">0</span> <span class="comment"># 直接设置当前进度条的值</span></span><br><span class="line">    _tqdm1.refresh() <span class="comment"># 更新完 n 后记得 refresh一下显示</span></span><br></pre></td></tr></table></figure>

<p>tqdm的常见属性为:</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">使用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>n</strong></td>
<td align="left">可以直接设置当前进度条的进度，pbar.n &#x3D; 80，设置完之后 需要调用*pbar.refrash()*刷新显示</td>
</tr>
<tr>
<td align="left"><strong>total</strong></td>
<td align="left">进度条的总长度， n &lt;&#x3D; total</td>
</tr>
<tr>
<td align="left"><strong>ncols</strong></td>
<td align="left">进度条显示的宽度，应该是以字符长度为单位</td>
</tr>
<tr>
<td align="left"><strong>description</strong></td>
<td align="left">进度条前面显示的信息</td>
</tr>
<tr>
<td align="left"><strong>postfix</strong></td>
<td align="left">进度条后面显示的信息</td>
</tr>
<tr>
<td align="left"><strong>colour</strong></td>
<td align="left">设置进度条显示的颜色，可以使用pbar.colour &#x3D; ‘green’</td>
</tr>
<tr>
<td align="left"><strong>position</strong></td>
<td align="left">进度条显示在第几行</td>
</tr>
<tr>
<td align="left"><strong>leave</strong></td>
<td align="left">如果设置为<code>False</code>或者<code>None</code>则最运行完成后，进度条显示为 0，否则进度条就会隐藏</td>
</tr>
</tbody></table>
<h2 id="tqdm与print混用问题"><a href="#tqdm与print混用问题" class="headerlink" title="tqdm与print混用问题"></a>tqdm与print混用问题</h2><p>如果在显示进度条的同时还需要调用<code>print</code>打印一些调试信息，直接混用的话，进度条的显示会分为多行显示，打印的信息也会显得很混乱。就类似于下面这样</p>
<p><img src="https://i.imgur.com/M8hnbzT.png" alt="image-20220427224747262"></p>
<p>为了解决这个问题，这里参照了<a href="https://zhuanlan.zhihu.com/p/450780357">这篇帖子</a>，可以使用<code>tqdm.write()</code>代替<code>print</code>输出信息。最后的效果这样</p>
<p><img src="https://i.imgur.com/fvj7J8p.png" alt="image-20220427225036971"></p>
<p><strong>注意：tqdm.write()只能接受 字符串类型的数据输出</strong></p>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>tqdm</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog编程规范</title>
    <url>/2022/09/19/verilog-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>参考华为内部的<code>verilog</code>编程规范，总结自己的代码风格。</p>
<span id="more"></span>

<h2 id="设计风格"><a href="#设计风格" class="headerlink" title="设计风格"></a>设计风格</h2><p>内容包括变量（信号）命名规范，模块命名规范等</p>
<h3 id="信号与常量"><a href="#信号与常量" class="headerlink" title="信号与常量"></a>信号与常量</h3><ol>
<li>对低电平有效的信号，信号名后缀“_n”</li>
<li>使用降序排列的定义向量有效位顺序，最低为是0</li>
<li>使用大写字母定义<code>parameter</code>,使用小写字母定义 <code>input</code>，<code>reg</code>，<code>output</code>等信号的命名</li>
<li>时钟信号统一使用前缀 “clk”，复位信号统一使用前缀 “rst”</li>
</ol>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol>
<li>模块的命名全部小写</li>
<li>到其他模块的信号声明顺序按照 : 输入、（双向）、输出</li>
<li>每个模块只包含一个模块，模块名称与文件名保持一致</li>
<li>在调用模块时，使用<code>name_based</code>的方式进行调用而不是<code>order_based</code>的方式进行调用</li>
<li>模块例化统一使用  “U_name_i”，进行命名，如果多次例化，则i使用数字编号</li>
</ol>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>在模块设计时遵守以下原则：</p>
<ol>
<li>同步时序逻辑块<code>always</code>块中有且只有一个使用信号，并且在同一个沿做出动作</li>
<li>不要在时钟信号路径上添加任何<code>buffer</code></li>
<li>不要采取向量的方式定义一组时钟信号</li>
<li>一个<code>always</code>语句中只能有一个事件列表</li>
<li>时序逻辑电路中统一使用非阻塞赋值方式</li>
<li>组合逻辑电路中统一使用阻塞赋值方式</li>
</ol>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog代码模板</title>
    <url>/2023/03/13/verilog%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>从培训机构学习的关于Verilog编程的一些规范。</p>
<span id="more"></span>

<h2 id="计数器代码"><a href="#计数器代码" class="headerlink" title="计数器代码"></a>计数器代码</h2><p>计数器代码设计规则：</p>
<ol>
<li>计数器逐一考虑三要素：初值、加1条件、结束值</li>
<li>计数初值必须为0</li>
<li>使用某一计数值，必须同时满足加1条件</li>
<li>结束条件必须满足加1条件，且结束值必须是 $x -1$的形式</li>
<li>当取某个数时，<code>assign</code>形式必须为：（加1条件） &amp;&amp; (cnt &#x3D;&#x3D; 计数值 -1)</li>
<li>计数器计数结束后必须回到 0</li>
<li>设置限定范围使用 $&gt;&#x3D;$和$&lt;$两种符号</li>
<li>设计步骤是：先写计数器的<code>always</code>段，条件用名字判断；用 <code>assign</code>写出 加1条件；最后用 <code>assign </code>写出结束条件</li>
<li>加1条件必须与计数器严格对其，其他信号一律向计数器对齐</li>
<li>计数器的命名规范：加1条件的前缀必须以 <code>add_</code>开头，结束计数条件必须以<code>end_</code>开头</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> add_cnt, end_cnt;	<span class="comment">// 加1条件和结束条件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!reset_n) <span class="keyword">begin</span></span><br><span class="line">        cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (add_cnt) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (end_cnt)</span><br><span class="line">            cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">            cnt &lt;= cnt + <span class="number">8&#x27;d1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> add_cnt = a == <span class="number">2</span>; <span class="comment">// 开始计数的条件</span></span><br><span class="line"><span class="keyword">assign</span> end_cnt = add_cnt &amp;&amp; cnt == <span class="number">10</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog状态机基础</title>
    <url>/2022/09/10/verilog%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>学习<code>verilog</code>状态机的的几种常见写法。</p>
<span id="more"></span>

<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。有限状态机被用于描述电路的状态变化。</p>
<h2 id="状态机概览"><a href="#状态机概览" class="headerlink" title="状态机概览"></a>状态机概览</h2><p>状态机可分为两类：</p>
<ul>
<li><p>Mealy 状态机：</p>
<p>状态机的输出和当前状态和输入相关</p>
</li>
<li><p>Moore状态机：</p>
<p>状态机的输出<strong>只和当前状态</strong>相关。</p>
</li>
</ul>
<p><strong>状态机的4个要素</strong>现态、条件、动作、次态。其中“现态”和“条件”作为产生”次态“和”动作“的原因。</p>
<ul>
<li><strong>现态</strong>：是指当前所处的状态</li>
<li><strong>条件</strong>：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移</li>
<li><strong>动作</strong>：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。<em>动作不是必需的</em>，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li>
<li><strong>次态</strong>：条件满足后要迁往的新状态。次态一旦被激活，就会转变成现态。</li>
</ul>
<p>在实现过程中需要注意的问题：</p>
<ol>
<li>区分”状态“与”动作“：动作时改变后所做出的动作，一般动作执行结束后不会一致保持，但是状态会一直保持，直到下一个状态的改变。</li>
</ol>
<p>状态机的描述方法分为3种：</p>
<ol>
<li><p>一段式状态机</p>
</li>
<li><p>二段式状态机</p>
</li>
<li><p>三段式状态机</p>
</li>
<li><p>四段式状态机</p>
</li>
</ol>
<h2 id="一段式状态机"><a href="#一段式状态机" class="headerlink" title="一段式状态机"></a>一段式状态机</h2><p>在描述比较简单的逻辑转换关系时可以直接使用一段式状态机，一段式状态机的特征是只有一个<code>always</code>的时序逻辑块，状态转移，以及输出的变化都在该<code>always</code>块中进行更改。一段式状态机在软件开发中使用的比较多的，但是在硬件描述中则不是非常推荐。</p>
<p><strong>注意：</strong></p>
<p>在声明状态常量时使用<code>localparam</code>关键字进行声明而不是 <code>parameter</code>，这样可以避免<code>Vivado</code>的综合工具报警告</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> m1(</span><br><span class="line">	<span class="keyword">input</span> clk_i,</span><br><span class="line">    <span class="keyword">input</span> rst_n_i;</span><br><span class="line">    <span class="keyword">output</span> out_o</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] state;</span><br><span class="line">    <span class="comment">// 表示状态的常量声明，在实际工程中需要对状态名称进行更准确的描述。</span></span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S0 = <span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S1 = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S2 = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S3 = <span class="number">2&#x27;b11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_i) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_i) <span class="keyword">begin</span></span><br><span class="line">            state &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            out_o &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 使用 case 语句描述状态的变化以及输出的变换</span></span><br><span class="line">            <span class="keyword">case</span> (state)</span><br><span class="line">                s0: <span class="keyword">begin</span></span><br><span class="line">                    out_r &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">					state &lt;= S1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S2: <span class="keyword">begin</span></span><br><span class="line">                    out_r &lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">					state &lt;= S3;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S3: <span class="keyword">begin</span></span><br><span class="line">                    out_r &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">					state &lt;= S4;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S4: <span class="keyword">begin</span></span><br><span class="line">                    out_r &lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">					state &lt;= S3;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> out_o = out_r;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="二段式状态机"><a href="#二段式状态机" class="headerlink" title="二段式状态机"></a>二段式状态机</h2><p>两段式状态机的特征是采用两个 always 模块实现状态机的功能，其中一个 <code>always</code> 采用同步时序逻辑描述状态转移，另一个 <code>always</code> 采用组合逻辑来判断状态条件转移。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> m1(</span><br><span class="line">	<span class="keyword">input</span> clk_i,</span><br><span class="line">    <span class="keyword">input</span> rst_n_i;</span><br><span class="line">    <span class="keyword">output</span> out_o</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] current_state;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] next_state;</span><br><span class="line">    <span class="comment">// 表示状态的常量声明，在实际工程中需要对状态名称进行更准确的描述。</span></span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S0 = <span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S1 = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S2 = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S3 = <span class="number">2&#x27;b11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述状态的转换</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_i) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n_i)</span><br><span class="line">			Current_state&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			Current_state&lt;=next_state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述下一个状态的转换以及输出的变换</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (state)</span><br><span class="line">            s0: <span class="keyword">begin</span></span><br><span class="line">                out_r =<span class="number">1&#x27;b0</span>;</span><br><span class="line">                next_state = S1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                out_r =<span class="number">1&#x27;b1</span>;</span><br><span class="line">                next_state = S3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S3: <span class="keyword">begin</span></span><br><span class="line">                out_r =<span class="number">1&#x27;b0</span>;</span><br><span class="line">                next_state = S4;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S4: <span class="keyword">begin</span></span><br><span class="line">                out_r =<span class="number">1&#x27;b1</span>;</span><br><span class="line">                next_state = S3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> out_o = out_r;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="三段式状态机"><a href="#三段式状态机" class="headerlink" title="三段式状态机"></a>三段式状态机</h2><p>三段式状态机的特征是在第一个 <code>always</code> 模块采用同步时序逻辑方式描述状态转移，第二个 <code>always</code> 采用组合逻辑方式描述状态转移规律，第三个 <code>always</code> 采用组合逻辑方式描述电路的输出。这种状态机的组合逻辑与时序逻辑完全独立。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> m1(</span><br><span class="line">	<span class="keyword">input</span> clk_i,</span><br><span class="line">    <span class="keyword">input</span> rst_n_i;</span><br><span class="line">    <span class="keyword">output</span> out_o</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] current_state;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] next_state;</span><br><span class="line">    <span class="comment">// 表示状态的常量声明，在实际工程中需要对状态名称进行更准确的描述。</span></span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S0 = <span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S1 = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S2 = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>] S3 = <span class="number">2&#x27;b11</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改变当前电路的状态, 这一段一般不用变化</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_i) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n_i)</span><br><span class="line">			Current_state&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			Current_state&lt;=next_state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述状态的转换</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (Current_state)</span><br><span class="line">            s0: <span class="keyword">begin</span></span><br><span class="line">                next_state = S1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                next_state = S3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S3: <span class="keyword">begin</span></span><br><span class="line">                next_state = S4;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S4: <span class="keyword">begin</span></span><br><span class="line">                next_state = S3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span> : next_state = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 描述电路输出</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">case</span> (Current_state)</span><br><span class="line">            S0, S1, S2: out_r = <span class="number">1&#x27;b1</span>;</span><br><span class="line">            S3, S4: out_r = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">default</span>: out_r=out_r;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> out_o = out_r;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="四段式状态机"><a href="#四段式状态机" class="headerlink" title="四段式状态机"></a>四段式状态机</h2><p>四段式状态机是在三段式状态机的基础上进行的修改，可以更加清晰地分离状态变化以及输出，并且可以避免写出 <code>state_c &lt;= state_c</code>之类的代码，避免生成锁存器，它包含四个部分：</p>
<p>状态信息的声明：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">localparam</span> IDLE = <span class="number">4&#x27;d0</span>;</span><br><span class="line"><span class="keyword">localparam</span> S1 = <span class="number">4&#x27;d1</span>;</span><br><span class="line"><span class="keyword">localparam</span> S2 = <span class="number">4&#x27;d2</span>;</span><br><span class="line"><span class="keyword">localparam</span> S3 = <span class="number">4&#x27;d3</span>;</span><br></pre></td></tr></table></figure>

<p><strong>时序逻辑部分</strong>，该部分的内容在所有代码中都不需要改变，格式化地描述现态和次态的转换。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] state_c; <span class="comment">// 当前的状态寄存器</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] state_n; <span class="comment">// 下一个状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_sys <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        state_c &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        state_c &lt;= state_n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>组合逻辑部分</strong>，该部分代码描述状态转移的条件：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state_c)</span><br><span class="line">        IDLE: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (c_idle_s1) </span><br><span class="line">                state_n = S1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                state_n = state_c; <span class="comment">// 避免生成锁存器</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        S1: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (c_s1_s2) </span><br><span class="line">                state_n = S2;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                state_n = state_c;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        S2: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (c_s2_s3) </span><br><span class="line">                state_n = S3;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                state_n = state_c;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        IDLE: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (c_s3_idle) </span><br><span class="line">                state_n = IDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                state_n = state_c;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>组合逻辑部分</strong>，定义状态转移的信号。注意条件命名规范： <code>c_现态_次态</code>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> c_idle_d1 = state_c == IDLE &amp;&amp; 转移条件;</span><br><span class="line"><span class="keyword">assign</span> c_s1_s2 = state_c == S1 &amp;&amp; 转移条件;</span><br><span class="line"><span class="keyword">assign</span> c_s2_s3 = state_c == S2 &amp;&amp; 转移条件;</span><br><span class="line"><span class="keyword">assign</span> c_s3_idle = state_c == S3 &amp;&amp; 转移条件;</span><br></pre></td></tr></table></figure>

<p><strong>设计输出信号</strong>，此部分不限于使用时序逻辑还是组合逻辑进行描述，只需要清晰就可以了。</p>
<blockquote>
<p>一般一个 always 语句只控制一个信号，有多少个输出信号就有多少个always 块</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_sys <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (state_c)</span><br><span class="line">            IDLE, S1, S2: out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">           	S3 : out1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">default</span> : out1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>使用组合逻辑的分支判断的时候，每个分支只能造成一个变量发生改变，且保证每个分支中都在改变这个变量，否则，就会综合出锁存器电路。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了可以使用 <code>localparam</code> 定义参数外还可以使用 <code>typedef</code>定义状态的名称</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    STATE_IDLE,</span><br><span class="line">    STATE_A,</span><br><span class="line">    STATE_B</span><br><span class="line">&#125; state_t;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>vim高效编辑</title>
    <url>/2022/09/23/vim%E9%AB%98%E6%95%88%E7%BC%96%E8%BE%91/</url>
    <content><![CDATA[<p>复习编辑器之神<code>Vim</code>, 顺便立个Flag，以后的<code>verilog</code>都使用<code>Vim</code>进行编写。 🙌</p>
<span id="more"></span>

<h2 id="选择与替换"><a href="#选择与替换" class="headerlink" title="选择与替换"></a>选择与替换</h2><h3 id="选择块内容："><a href="#选择块内容：" class="headerlink" title="选择块内容："></a>选择块内容：</h3><p>如果使用的是<code>GVim</code>，可以直接使用 鼠标进行拖动，<code>GVim</code>会自动进入<code>Visual Mode</code>。如果在拖动鼠标的同时按住键盘的<code>Alt</code>键，<code>Vim</code>就会进入<code>Visual-Block</code>模式，在这个模式下可以进行块选择。</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; 快速选择段落内容</span></span><br><span class="line"><span class="string">vip</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 选择 &#123; ( [ 的内容</span><br><span class="line">vi(</span><br><span class="line"><span class="string">&quot; 选取上一次选择的区域, 正常模式下</span></span><br><span class="line"><span class="string">gv</span></span><br></pre></td></tr></table></figure>

<p>在<code>Visual-Mode</code>中选择需要的内容后就可以使用<code>d x y p</code>等命令对选中的内容进行相关操作。</p>
<h3 id="搜索关键字："><a href="#搜索关键字：" class="headerlink" title="搜索关键字："></a>搜索关键字：</h3><p>当需要在<code>Vim</code>中搜索关键字时，在<code>normal mode</code>下使用<code>/name</code> 进行搜索。</p>
<p>搜索时可以连接<strong>标识符</strong>，指定搜索的范围，是否大小写敏感等。具体表示符如下：</p>
<ul>
<li><code>/g</code> 表示在全局范围内进行操作 </li>
<li><code>/c</code> 表示在替换操作时需要进行确认</li>
<li><code>/I</code>表示需要在搜索时对关键字的大小写敏感</li>
</ul>
<p><strong>指定搜索范围</strong>：</p>
<ul>
<li><code>:%</code> 代表整个文件</li>
<li><code>: i, j</code>搜索范围是 第 i 到 j行</li>
<li><code>:.,+x</code>搜索范围是从当前行和接下来的两行</li>
</ul>
<p>搜索关键字的一个重要作用就是在<code>/</code>前面加上<code>s</code>，就可以进行关键字的搜索替换，具体格式为:<code>s/name/new_name</code></p>
<p>例如，在写<code>testbench</code>的时候需要从原模块中复制输入输出的定义后将<code>input</code>替换为<code>reg</code>，将<code>output</code>替换为<code>wire</code>类型。可以使用如下命令进行修改替换：</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; 全局范围内进行搜索 input 替换为 reg，% 代表整个文件，g 代表全局范围内，c代表在替换时需要进行逐项确认</span></span><br><span class="line"><span class="string">:%s/input/reg/gc </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 在 i，j 行之间进行搜索替换</span><br><span class="line">:i,js/<span class="keyword">input</span>/<span class="keyword">reg</span>/gc</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 在选中的内容中进行搜索替换</span></span><br><span class="line"><span class="string">:&lt;,&#x27;&gt;s/input/reg</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 从当前行开始，向下两行的范围内进行搜索替换，点代表当前行</span><br><span class="line">:.,+<span class="number">2</span>/s/<span class="keyword">input</span>/<span class="keyword">reg</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 在全局范围内对已经选择（搜索）到的关键字进行替换</span></span><br><span class="line"><span class="string">:%s//new_name/gc</span></span><br></pre></td></tr></table></figure>

<p>在搜索完成后可以使用<code>noh</code>取消搜索结果的高亮显示。</p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><h3 id="在多行添加内容："><a href="#在多行添加内容：" class="headerlink" title="在多行添加内容："></a>在多行添加内容：</h3><p>在例化代码模块时，可以快速从源文件中将模块复制过来并将参数名统一添加<code>.</code>和括号<code>()</code>。</p>
<p>在列选择模式下选择第一列，按下 <code>I</code>，输入需要插入的内容后，按下<code>&lt;ESC&gt;</code>键后就可以完成批量添加。下面就是将<code>module</code>改为例化模块的方法。</p>
<p><img src="https://i.imgur.com/xkFkgMO.gif" alt="mutil-edit"></p>
<h3 id="宏功能"><a href="#宏功能" class="headerlink" title="宏功能"></a>宏功能</h3><p>宏功能可以将需要重复执行的动作记录下来，然后批量执行。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">qx</td>
<td align="center">Normal Mode</td>
<td align="center">录制宏 到 x，x可以是 abcde…等等</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">Normal Mode</td>
<td align="center">停止录制</td>
</tr>
<tr>
<td align="center">@x</td>
<td align="center">Normal Mode</td>
<td align="center">运行宏，可以在按之前输出数字指定重复执行的次数</td>
</tr>
</tbody></table>
<h2 id="快速对齐"><a href="#快速对齐" class="headerlink" title="快速对齐"></a>快速对齐</h2><p>使用<a href="https://github.com/junegunn/vim-plug">Vim-Plug</a>安装<a href="https://github.com/junegunn/vim-easy-align">Easy-Align</a>插件，并在<code>.vimrc</code>里面加上</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line">xmap ga &lt;Plug&gt;(EasyAlign)</span><br><span class="line">nmap ga &lt;Plug&gt;(EasyAlign)</span><br></pre></td></tr></table></figure>

<p>配置好后再<code>Visual-Mode</code>下选择需要对齐的代码，按下 <code>ga</code>+ <code>标识符</code>就可以快速对齐代码了。</p>
<p>例如需要对齐一些<code>localparam</code>的声明，再使用鼠标选择之后，按下<code>ga</code>+ <code>**</code> + <code>&lt;SPACE&gt;</code>就可以快速以空格为中心将代码进行对齐。</p>
<p>可以在输入对齐字符之前按下<code>&lt;Left&gt;</code> 或者<code>&lt;Right&gt;</code>选择左对齐或者右对齐。</p>
<p><img src="https://i.imgur.com/0tJE8pX.gif" alt="easy-align"></p>
<h2 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h2><h3 id="单词之间的移动"><a href="#单词之间的移动" class="headerlink" title="单词之间的移动"></a>单词之间的移动</h3><p>在<code>Vim</code>中使用光标移动到一个单词后，在<code>Normal Mode</code>下按下<code>*</code>，<code>Vim</code>就会自动高亮所有匹配的单词，再次按下<code>*</code>，指针就会跳转到下一个一样的单词，按下<code>#</code>可以跳转到上一个单词。</p>
<p>使用<code>~~</code>可以跳转到上一个编辑的位置。</p>
<blockquote>
<p>! 注意：这里是~~，~代表对的单词的大小写进行替换。</p>
</blockquote>
<h3 id="配对括号之间的跳转"><a href="#配对括号之间的跳转" class="headerlink" title="配对括号之间的跳转"></a>配对括号之间的跳转</h3><p>在一个括号上按下 <code>%</code>可以快速跳转到它匹配的另一半的位置。</p>
<h3 id="文件内跳转"><a href="#文件内跳转" class="headerlink" title="文件内跳转"></a>文件内跳转</h3><figure class="highlight v"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; n 为行数</span></span><br><span class="line"><span class="string">:n</span></span><br><span class="line"><span class="string">&quot;</span> 跳转到文件头</span><br><span class="line">gg</span><br><span class="line"><span class="string">&quot; 跳转到文件尾</span></span><br><span class="line"><span class="string">G</span></span><br></pre></td></tr></table></figure>

<h3 id="行内的跳转"><a href="#行内的跳转" class="headerlink" title="行内的跳转"></a>行内的跳转</h3><figure class="highlight v"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; 下一个单词的第一个字母</span></span><br><span class="line"><span class="string">w </span></span><br><span class="line"><span class="string">&quot;</span> 上一个单词的第一个字母</span><br><span class="line">b</span><br><span class="line"><span class="string">&quot; 当前单词的最后一个字母，如果已经在最后一个字母，则会跳转到下一个单词的最后一个字母</span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">&quot;</span> 上一个单词的最后一个字母</span><br><span class="line">ge</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 跳转到行首</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&quot;</span> 跳转到行尾</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h3 id="Easy-Motion插件"><a href="#Easy-Motion插件" class="headerlink" title="Easy-Motion插件"></a>Easy-Motion插件</h3><p>使用<a href="https://github.com/junegunn/vim-plug">Vim-Plug</a>安装<a href="https://github.com/easymotion/vim-easymotion">Easy-Motion</a>插件，并在<code>.vimrc</code>里面加上</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line">nmap s &lt;Plug&gt;(easymotion-overwin-f2)</span><br></pre></td></tr></table></figure>

<p>在<code>Normal-Mode</code>中按下<code>s</code>并输入想要跳转到地方的头两个单词，并按下屏幕中提示的字符就可以将指针快速地移动到指定为位置。</p>
<p>例如我当前的光标再<code>else</code>的位置，我想快速跳转到 <code>clk_baud</code>位置处。在<code>Normal Mode</code>下按下 scl，并根据提示按下<code>s</code>键，光标就跳转到了指定的位置。</p>
<p><img src="https://i.imgur.com/h6LqYRN.gif" alt="easy-motion"></p>
<h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><p>可以设置折叠的模式，这里直接设置为<code>marker</code>模式，且折叠标记设置为<code>//BEGIN</code>和<code>//END</code>。</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line">:set foldmethod=marker</span><br><span class="line">:set foldmarker=<span class="comment">//BEGIN,//END</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zc</td>
<td align="center">Normal Mode</td>
<td align="center">折叠当前块</td>
</tr>
<tr>
<td align="center">zo</td>
<td align="center">Normal Mode</td>
<td align="center">展开当前块</td>
</tr>
<tr>
<td align="center">zC</td>
<td align="center">Normal Mode</td>
<td align="center">折叠所有可以折叠的块</td>
</tr>
<tr>
<td align="center">zO</td>
<td align="center">Normal Mode</td>
<td align="center">展开所有可以折叠的块</td>
</tr>
</tbody></table>
<h2 id="不常用操作"><a href="#不常用操作" class="headerlink" title="不常用操作"></a>不常用操作</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CTRL-O</td>
<td align="center">Normal Mode</td>
<td align="center">打开上一个最近打开的文件</td>
</tr>
<tr>
<td align="center">CTRL-I</td>
<td align="center">Normal Mode</td>
<td align="center">打开下一个最近打开的文件</td>
</tr>
<tr>
<td align="center">Ctrl-u</td>
<td align="center">Normal Mode</td>
<td align="center">向下移动半个屏幕</td>
</tr>
<tr>
<td align="center">Ctrl-d</td>
<td align="center">Normal Mode</td>
<td align="center">向上移动半个屏幕</td>
</tr>
</tbody></table>
<h2 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:vs</td>
<td align="center">Normal Mode</td>
<td align="center">横向拆分窗口</td>
</tr>
<tr>
<td align="center">:sp</td>
<td align="center">Normal Mode</td>
<td align="center">纵向拆分窗口</td>
</tr>
<tr>
<td align="center">C-w w h j k l</td>
<td align="center">Normal Mode</td>
<td align="center">切换当前窗口，w 是循环切换</td>
</tr>
<tr>
<td align="center">C-w q</td>
<td align="center">Normal Mode</td>
<td align="center">关闭当前窗口</td>
</tr>
</tbody></table>
<h2 id="Buffer操作"><a href="#Buffer操作" class="headerlink" title="Buffer操作"></a>Buffer操作</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:ls</td>
<td align="center">Normal Mode</td>
<td align="center">列出当前所有打开的文件</td>
</tr>
<tr>
<td align="center">:bn</td>
<td align="center">Normal Mode</td>
<td align="center">跳转到下一个编辑文件</td>
</tr>
<tr>
<td align="center">:bp</td>
<td align="center">Normal Mode</td>
<td align="center">跳转到上一个打开的编辑文件</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>使用<code>--cmd</code> 可以在<code>shell</code>里面调用<code>vim</code>的命令，从而和<code>shell </code>进行结合并自动化完成某些操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim --cmd PluginInstall </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github Actions 自动化部署 Hexo</title>
    <url>/2022/03/11/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-Hexo/</url>
    <content><![CDATA[<p>用<code>hexo</code>搭建个人博客并使用<code>github action</code>自动进行部署</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前立的每天写点东西的Flag感觉都差不多遗忘了，注册的博客园感觉也不好玩，默认的界面太丑了，写东西都没感觉（好吧，这是借口）。觉得还是搭建自己的博客比较Geek 一点，自己DIY也比较方便（就是想折腾）。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>新建一个<code>&lt;username&gt;.github.io</code>的Github仓库。</li>
<li>新建一个Blog 的私有仓库用于保存Blog 源代码</li>
<li>在本地安装 Node.js</li>
</ul>
<h2 id="本地初始化Hexo"><a href="#本地初始化Hexo" class="headerlink" title="本地初始化Hexo"></a>本地初始化Hexo</h2><p>安装完Node.js后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">安装 hexo</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">npm install hexo-cli -g</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">hexo 初始化</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">npm install</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexo-的配置"><a href="#Hexo-的配置" class="headerlink" title="Hexo 的配置"></a>Hexo 的配置</h2><p>因为 Github的限制，所以在访问仓库时需要设置 Taken。</p>
<p>Token 获取步骤 ：依次选择，下面的选项，创建一个Token。</p>
<p>Account -&gt; settings -&gt; Developer settings -&gt; Personal access tokens</p>
<p>&#x3D;&#x3D;创建时记得勾选全部权限&#x3D;&#x3D;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Jiaming&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;写点啥&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;希望坚持每天都写点啥&#x27;</span></span><br><span class="line"><span class="comment"># 设置主题</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">keep</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置推送选项</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">git@github.com:jiamingyy/jiamingyy.github.io.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">taken:</span> <span class="string">&lt;personel</span> <span class="string">access</span> <span class="string">token&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置完 deploy 之后，就可以通过<code>hexo d</code> 命令发布网页到github了。</p>
<p>Hexo 的常用操作如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">hexo g <span class="comment"># 编译生成发布文件</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">hexo s <span class="comment"># 开启本地服务器预览</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">hexo new &lt;post&gt; <span class="string">&quot;title&quot;</span> <span class="comment"># 新建一个文章</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">新建一个页面，类似于 About me 的功能，新建之后可以在相应的主题config中进行开启</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">hexo new page <span class="string">&quot;title&quot;</span></span>  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">hexo d <span class="comment"># 部署</span></span></span><br></pre></td></tr></table></figure>

<h2 id="使用Github-Actions-自动部署"><a href="#使用Github-Actions-自动部署" class="headerlink" title="使用Github Actions 自动部署"></a>使用Github Actions 自动部署</h2><p>为了可以在多台设备上随时进行写作和同步，我们可以利用 Github 提供的Actions 服务自动化对博客进行部署。也可以省去我们在本地配置环境的时间，专注于写作。当我们写了新的文章，只需要将Blog 的源代码推送到Github 的 Blog 仓库，Github actions 就可以在直接云端执行 <code>hexo g</code>、<code>hexo d</code>这些操作，自动帮我们部署到page中。</p>
<p>在开始配置之前需要确定以下事情：</p>
<ol>
<li><p>本地Blog部署生成和部署正常</p>
</li>
<li><p>Blog 仓库已经创建完毕</p>
</li>
</ol>
<p>在所有事情完成后，第一步，先在本地创建访问RSA密匙，使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;这里面可以随便写&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>创建完成后可以得到 <code>id_rsa</code> 和 <code>id_rsa.pub</code>两个文件，分别为私钥和公钥文件。</p>
<p>将<code>id_rsa.pub</code>的内容复制到 <code>&lt;username&gt;.github.io</code>的Settings中的 Deploy keys.  Keys的名称可以随便写。</p>
<p><img src="https://i.imgur.com/ucHcW9g.png"></p>
<p>接下来配置 Blog仓库，也就是存放我们Blog 源代码的仓库。在Settings -&gt; Secrets -&gt; Actions 中点击 New repository secret , 将<code>id_rsa</code>文件中的内容复制到里面。&#x3D;&#x3D;注意名称命名为 DEPLOY_KEY&#x3D;&#x3D;</p>
<p><img src="https://i.imgur.com/4xO8Dug.png"></p>
<p>在配置完Secret Key 之后点击进入 Blog 的 Actions 界面。选择New workflow。添加如下内容。&#x3D;&#x3D;注意参数中的deploy_key &#x3D; $&#x3D;&#x3D;这个也就是我们刚刚设置的Secret Key 的名称。代码更新的内容可参照<a href="https://github.com/marketplace/actions/hexo-action">hexo actions</a>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is a basic workflow to help you get started with Actions</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"><span class="comment"># Controls when the workflow will run</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Triggers the workflow on push or pull request events but only for the main branch</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v3.0.0</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $&#123;&#123; runner.os &#125;&#125;-node-</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">user_name:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">username</span>  <span class="comment"># (or delete this input setting to use bot account)</span></span><br><span class="line">        <span class="attr">user_email:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">useremail</span>  <span class="comment"># (or delete this input setting to use bot account)</span></span><br><span class="line">        <span class="attr">commit_msg:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>  <span class="comment"># (or delete this input setting to use hexo default settings)</span></span><br><span class="line">    <span class="comment"># Use the output from the `deploy` step(use for test action)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; steps.deploy.outputs.notify &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="更新测试"><a href="#更新测试" class="headerlink" title="更新测试"></a>更新测试</h2><p>在设置两个仓库后就可以向Blog 仓库中commit 代码了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> Blog  <span class="comment"># 进入Blog 目录</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git init <span class="comment"># 初始化仓库</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;email@email.com&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git remote add origin &lt;github repository address&gt;</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">add 之前记得先添加 .gitignore 文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git push</span></span><br></pre></td></tr></table></figure>

<p>完成推送之后就可以在Actions 那里查看是否正常编译部署。部署完成再等一会儿，就可以打开<code>&lt;username&gt;.github.io</code>查看部署是否完成了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>在自动部署中，配置的主题需要使用 submodule 的形式引入，如果没有以该种形式引入的话，最终生成的<code>index.html</code>会为一个空的文件，Actions的生成 logs 也会产生Warning。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">git submodule add https://github.com/litten/hexo-theme-yilia.git themes/yilia <span class="comment">#以yilia 主题为例</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>为了访问 Fork 的主题，需要在Blog源代码仓库的Settings 中给 Actions 设置访问Fork仓库的权限，否则会Checkout 失败。</p>
</li>
<li><p>因为 BLM 运动，GitHub 把默认主分支的名字改成了Main，但本地的git 默认的分支名称还是 master，所以最好把git默认的分支名称也改成 main</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">git config --global init.defaultBranch main</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git branch -M main <span class="comment"># 如果是已经新建了的仓库，修改当前的分支名称为 main</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>基础神经网络架构总结</title>
    <url>/2023/04/09/%E5%9F%BA%E7%A1%80%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结常用的神经网络结构。</p>
<span id="more"></span>

<h2 id="全连接-FC"><a href="#全连接-FC" class="headerlink" title="全连接(FC)"></a>全连接(FC)</h2><p>全连接层(FC层)MLP（Multilayer Perceptron）多层感知机的基本结构，本质上为权重矩阵与输入矩阵简单相乘并叠加非线性激活函数的运算形式。当前的神经网络机构的运算范式的基础。下面就是它的公式：其中$W^T$代表该层的参数，$X$表示输入，这个输入必须是2维的（加上$Batch$的话是3维）。全连接层一般会组成一个前馈网络用作最后一层。</p>

$$
y = \sigma(W^TX + B)
$$


<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>卷积可以可以看做是FC层在二维上的扩展。卷积层的输入是一个三维的数据$C \times H \times W$（不包括$Batch$）。相当于将全连接层权重进行了二维排布，组成一个卷积核。</p>
<p>且卷积神经网络拥有的权值共享的特性。也就是说对于单个通道是共用的（大白话就是使用一个卷积核卷积一整个图像）。</p>
<p>卷积的输出大小计算公式是：$N$表示输出的宽度，$W$表示图像的宽度，$F$表示卷积核的宽度，$P$表示填充的大小（一般为1），$S$表示卷积的步长</p>

$$
N=  \lfloor x (W-F+2P)/S \rfloor + 1
$$


<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h3 id="普通RNN"><a href="#普通RNN" class="headerlink" title="普通RNN"></a>普通RNN</h3><p>RNN 相比与FCN的区别在于，RNN会保存当前一次的输出状态，并将该输出状态作为下一次的输入和新的数据输入一起参与新一轮的计算。它的公式为: $H_t$表示的是当前时刻的输出，$[ ]$表示的是拼接运算。初始时刻的$H_{t-1}$可以为0。RNN的本质上与FCN是一样的，只不过多了将上一个时刻的输出作为一部分输入输入到了神经网络。</p>

$$
H_t = \sigma (W^T[X_{t-1}, H_{t-1}] + B)
$$


<h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>普通RNN存在的缺点是当输入的时间序列信息特别长的时候由于不相关的信息太多会造成网络非常难以训练。LSTM （ Long Short-Term Memory）的提出就是为了解决这样的问题，LSTM通过引入更多的计算部件控制当前时刻的输入以及上一个时刻输入对于输出结果的影响。它的计算则相对更加复杂一点。计算分为三个门：</p>
<p>其中$W_f, W_i, W_o, W_c$均为可学习的参数矩阵，$B_f, B_i, B_o, B_c$为可学习的偏置参数。</p>
<p><strong>遗忘门：</strong></p>

$$
F_t = \sigma(W_f^T [H_{t-1}, X_t] + B_f)
$$


<p><strong>输入门：</strong></p>

$$
I_t = \sigma(W_i^T [H_{t-1}, X_t] + B_i)
$$


<p>输出门：</p>

$$
O_t = \sigma(W_o^T [H_{t-1}, X_t] + B_o)
$$


<p>除了$H_t$需要记录，LSTM还需要维护多一个<strong>细胞状态</strong>作为下一次计算的输入：$\odot$表示Element-Wise 的相乘。</p>

$$
\tilde{C}_{t}&=\tanh(W_c^T[H_{t-1}, X_t]+B_c) \\
C_t &=F_t \odot \tilde{C}_{t-1} + I_t \odot \tilde{C}_{t}
$$


<blockquote>
<p>$\tanh$ 的函数图像为如下图，输出的范围为$(-1,1)$</p>
<p><img src="https://i.imgur.com/jFyv5Ox.png" alt="img"></p>
</blockquote>
<p>最终的<strong>输出</strong>为：</p>

$$
H_t = O_t \odot \tanh(C_t)
$$


<h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>GRU（Gated Recurrent Unit）可以视为简化版的LSTM。GRU只使用了两个门控单元：</p>
<p><strong>更新门</strong>:</p>

$$
Z_t = \sigma(W_z^T [H_{t-1}, X_t] + B_z)
$$


<p><strong>重置门</strong>:</p>

$$
R_t = \sigma(W_r^T [H_{t-1}, X_t] + B_r)
$$


<p>最终<strong>输出</strong>：</p>

$$
\tilde{H}_t = \tanh(W_h^T(R_t\odot[H_{t-1}, X_t])+B_h) \newline
H_t = (1 - Z_t) \odot H_{t-1} + Z_t \odot \tilde{H}_t
$$


<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h3><p>注意力机制(Attention)相对于本质普通的神经网络还是有比较大的区别。它的计算过程设计得非常精细，对于长序列数据的处理能力相比RNN更加强大（主观判断）。<br>它的输入为一排 向量，输出也是一排向量，输出的向量是综合了序列中所有信息之后得到的表达。</p>
<p>首先需要先根据输入计算三个矩阵$QKV$， 分别对应Query、Key和Value，它们都是输入$X \in \mathbb{R}^{d \times L}$，$X$是一个由$L$个维度为$d$的向量组成的输入矩阵。计算三个矩阵的过程为：</p>

$$
Q & = W_QX  \newline
K & = W_KX  \newline
V & = W_VX
$$


<p>其中, $W_Q, W_K, W_V \in \mathbb{R}^{d \times d}$均为可学习的参数矩阵。</p>
<p>$K$和$V$会组合在一起运算得到注意力分数Attention Score 矩阵$A \in \mathbb{R}^{L \times L}$，它表示了其中第$(i,j)$个元素表示位置$i$与位置$j$之间的相关性得分，计算公式为:</p>

$$
A_{ij} = softmax(\frac{Q_i^TK_j}{\sqrt{d}})
$$


<p>其中 $\frac{1}{\sqrt{d}}$是为了环节是为了缓解点积得分可能较大的问题，同时可以使梯度更加稳定。$A$矩阵的每一列对应的就是输出的 $Attention Score$ ，因为过了$softmax$所以有</p>

$$
\sum A_{j} = \sum_i A_{ij} = 1
$$


<p>使用矩阵$A$对Value矩阵$V$进行加权求和j就得到了输出矩阵 $\tilde{O} \in \mathbb{R} ^{d \times L}$。这个输出再经过一个线性变换就得到了最终的输出$O$。</p>

$$
\tilde{O} &= VA \newline
O &= W_O\tilde{O}
$$


<h3 id="Multi-head-self-attention"><a href="#Multi-head-self-attention" class="headerlink" title="Multi-head self-attention"></a>Multi-head self-attention</h3><p>GOOGLE关于Transformer的原始论文中使用的是多头注意力机制。多头注意力机制是单头注意力机制的改良版本，可以允许模型同时关注在不同位置的表达子空间上的不同信息。</p>
<p>它的公式是，$h$表示头的个数：</p>

$$
MultiHead(Q,K,V)=Concat(head_1, head_2,...,head_h)
$$


<p>每个头的$QKV$计算和普通自注意力计算是一样，只是在还需要再经过没个头专属的线性映射矩阵后再进行每个头的注意力机制的计算：</p>

$$
head_i = Attention(W_Q^iQ,W_K^iK,W_V^iV)
$$


<p>最终的输出为</p>

$$
O = W_O \times MultiHead(Q,K,V)=W_O \times Concat(head_1, head_2,...,head_h)
$$


<p>因为 $Concat$得到的矩阵大小为$hd \times L$，$W_O$的大小为$d \times hd$。所以最终输出的$O$仍然是$d \times L$。</p>
<p><img src="https://i.imgur.com/P2MMQFQ.png" alt="普通的注意力机制和多头注意力机制的架构区别"></p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>RNN</tag>
        <tag>ATTENTION</tag>
      </tags>
  </entry>
  <entry>
    <title>定点数量化</title>
    <url>/2022/10/12/%E5%AE%9A%E7%82%B9%E6%95%B0%E9%87%8F%E5%8C%96/</url>
    <content><![CDATA[<p>FPGA 部署中常常使用的是定点数量化推理，而之前研究的是关于整数量化推理的内容，定点数量化后的网络可以直接进行前向推理而不需要进行复杂的<code>rescale</code>来保证网络层和层之间运算的正确性。</p>
<p><img src="https://i.imgur.com/mKjkYJy.png" alt="image-20221012152329987"><span id="more"></span></p>
<h2 id="定点数量化"><a href="#定点数量化" class="headerlink" title="定点数量化"></a>定点数量化</h2><p>定点数地表示：</p>
<p>定点数有两个参数$WL,FL$，$WL$表示一个数所占用的总比特数，$FL$表示一个数小数部分所占用的比特数。例如，$WL&#x3D;8, FL &#x3D; 4$， 假设有一个无符号定点数为$0b1101.1010$，其表示的数可以记为：</p>

$$
1\times8+1\times4+0\times2+1\times1+0.5\times1+0\times0.25+1\times0.125+0\times0.0625=13.625
$$


<p>等价于</p>

$$
218 \times 0.0625 = 13.625
$$




<p>此时一个无符号整数所能表示的范围为：$[0, 15.9425]$，表示精度为$0.0625$。</p>
<p><strong>无符号定点数量化</strong></p>

$$
fix\_quant = \frac{1}{2^{FL}}round(clip(x \cdot 2^{FL}, 0, 2^{WL} - 1))
$$


<p><strong>有符号整数量化</strong></p>

$$
fix\_quant = \frac{1}{2^{FL}}round(clip(x \cdot 2^{FL}, -2^{WL -1} + 1, 2^{WL -1} - 1))
$$


<p>Global Scale Factor<br>$$<br>fix_quant &#x3D; \frac{G_s}{2^{FL}}round(clip(\frac{x}{G_s} \cdot 2^{FL}, -2^{WL -1} + 1, 2^{WL -1} - 1))<br>$$</p>
<p>当每个层的$FL$确定之后就可以很容易</p>
<p>因为采用了所有层都采用了</p>
<h2 id="整数量化"><a href="#整数量化" class="headerlink" title="整数量化"></a>整数量化</h2><p>常见的整数量化过程如下面的公式所示，其中$q$代表量化后的值，$r$代表全精度的值。</p>

$$
q = round(\frac{r}{S})\\
r = S(q - Z) \\
S = (r_{max} - r_{min})/(2^{WL} - 1)
$$


<p>带0点的量化推理计算过程：</p>

$$
q_{c}^{(i, k)}=Z_{c}+P \sum_{j=1}^{N}\left(\left(q_{a}^{(i, j)}-Z_{a}\right)\left(q_{b}^{(j, k)}-Z_{b}\right)\right) \\
q_{c}^{(i, k)}=Z_{c}+P\left(N Z_{a} Z_{b}-Z_{a} M_{b}^{(k)}-Z_{b} M_{a}^{(i)}+\sum_{j=1}^{N} q_{a}^{(i, j)} q_{b}^{(j, k)}\right)\\
P = \frac{S_aS_b}{S_c} \\
M_{b}^{(k)}=\sum_{j=1}^{N} q_{b}^{(j, k)}, M_{a}^{(i)}=\sum_{j=1}^{N} q_{a}^{(i, j)}
$$


<p>如果采用对称量化，即量化后的零点和量化前的值的零点是对齐的，所有的$Z&#x3D;0$，公式就可以简化为</p>

$$
q_{c}^{(i, k)}=P \sum_{j=1}^{N}\left(q_{a}^{(i, j)}q_{b}^{(j, k)}\right) \\
P = \frac{S_aS_b}{S_c}
$$



<p>可以看到，公式中的$M_b, M_a$都是都是可以提前计算出来的，在推理过程中需要计算的就只有$P\cdot\sum_{j&#x3D;1}^{N} q_{a}^{(i, j)} q_{b}^{(j, k)}$这一项了。该部分的相乘累加是在整数上进行的。</p>
<h2 id="定点数量化-vs-整数量化："><a href="#定点数量化-vs-整数量化：" class="headerlink" title="定点数量化 vs 整数量化："></a>定点数量化 vs 整数量化：</h2><p>定点数量化可以当作整数量化的特殊情况，当$FL$确定之后，相当于整数量化中固定$S &#x3D; \frac{1}{2^{FL}}$，同时截断范围为$clip(0,2^{FL} \cdot (2^{WL} - 1)$。如果网络所有层采用同样的量化形式（即所有层的$WL, FL$的值均相等），在这种情况下网络间的运算就可以直接跳过 $P$参数的计算</p>
<p>思路：</p>
<ol>
<li>$S &#x3D; \frac{1}{2^{FL}}$不是最优的，但是具有计算上的优势，可以完全避免<code>Rescale</code>的额外计算，其本质上就是整个网络共享一个Scale<ol>
<li>结合自适应的<code>Scale</code>训练方法，使整个网络共享一个<code>Scale</code>,这样就可以结合定点量化以及整数量化的优点</li>
<li></li>
</ol>
</li>
<li><code>Overflow</code>问题<ol>
<li>饱和赋值</li>
<li>接纳溢出，并加以利用</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Paper</tag>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>开发板PS部分配置信息</title>
    <url>/2022/10/08/%E5%BC%80%E5%8F%91%E6%9D%BFPS%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>记录手上几块开发板PS部分的配置信息，方便查阅</p>
<span id="more"></span>

<h2 id="ALINX-ZYNQ-7020"><a href="#ALINX-ZYNQ-7020" class="headerlink" title="ALINX-ZYNQ-7020"></a>ALINX-ZYNQ-7020</h2><p>创建工程芯片型号：</p>
<p>xc7z020clg400-2</p>
<p>外设：</p>
<table>
<thead>
<tr>
<th align="left">外设名称</th>
<th align="left">引脚占用</th>
<th align="left">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UART1</td>
<td align="left">MIO 48 - 49</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">QSPI</td>
<td align="left">MIO 1-6</td>
<td align="left">Single Port</td>
</tr>
<tr>
<td align="left">EHT0</td>
<td align="left">MIO 16-27</td>
<td align="left">需要在MIO配置中设置使用的 电平标准为HSTL 1.8V, Speed : Fast</td>
</tr>
<tr>
<td align="left">SD0</td>
<td align="left">MIO 40-45</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SD0-Card Detection</td>
<td align="left">MIO 47</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">DDR3</td>
<td align="left">默认</td>
<td align="left">MT41J256M16 RE-125</td>
</tr>
<tr>
<td align="left">PS Clock</td>
<td align="left">默认</td>
<td align="left">输入33.3333 MHz，工作时钟 666.666MHz</td>
</tr>
<tr>
<td align="left">FCLK_CLK0</td>
<td align="left">默认</td>
<td align="left">给 PL 端提供的时钟</td>
</tr>
</tbody></table>
<h2 id="MLK-MZU07AEV"><a href="#MLK-MZU07AEV" class="headerlink" title="MLK-MZU07AEV"></a>MLK-MZU07AEV</h2><p>创建工程芯片型号：</p>
<p>xczu7ev-ffvc1156-2-i</p>
<p>外设：</p>
<p>Bank0 IO Voltage为LVCMOS1.8V Bank1 IO Voltage为LVCMOS1.8V<br>Bank2 IO Voltage为LVCMOS1.8V Bank3 IO Voltage为LVCMOS1.8V</p>
<table>
<thead>
<tr>
<th align="left">外设名称</th>
<th align="left">引脚占用</th>
<th align="left">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QSPI</td>
<td align="left">MIO 0-12</td>
<td align="left">Dual Parallel， Data Mode ：</td>
</tr>
<tr>
<td align="left">SD0</td>
<td align="left">MIO13-16 ,21, 22, 24</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SD0-Card Detection</td>
<td align="left">MIO 24</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">UART0</td>
<td align="left">MIO 34-35</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">IIC0</td>
<td align="left">MIO18-MIO19</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>数字电路基础 - 基础知识</title>
    <url>/2022/03/16/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%20-%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>复习基本的数字电路知识。包括基本的编码方式、基本门电路的符号、逻辑代数化简方法、常见的组合逻辑设计方法。</p>
<span id="more"></span>

<h2 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h2><p>我们比较常用的编码有8421码，其他的码感觉用的不多。</p>
<p><img src="https://i.imgur.com/ZgH7ncQ.png" alt="常用编码"></p>
<p>这里着重学习以下 格雷码，格雷码又叫循环二进制码或反射二进制码。格雷码相邻的两个码之间仅有一个位不一样，其与8421码可通过以下步骤互转：</p>
<p><strong>8421 转格雷码（编码）</strong>：从&#x3D;&#x3D;右往左&#x3D;&#x3D;的第 N 位和 第 N+1 位进行异或，最后一位两个码相同。</p>
<p><strong>格雷码转 8421（译码）</strong>: 从&#x3D;&#x3D;右往左&#x3D;&#x3D;的第 N 位和 第 N+1 位进行异或，最后一位两个码相同。</p>
<p>两个步骤是一样的。一个数异或同一个数两次得到的结果不变。</p>
<img src="https://i.imgur.com/YkyZHbq.png" alt="格雷码" style="zoom:67%;" />

<h2 id="基本门电路"><a href="#基本门电路" class="headerlink" title="基本门电路"></a>基本门电路</h2><p>这部分比较简单，记住下面这个表就可以了。</p>
<ul>
<li>记住常见的门电路符号</li>
<li>可以根据电路图写出逻辑代数表达式<br><img src="https://i.imgur.com/XPak1sq.png" alt="常见门电路的符号"></li>
</ul>
<h2 id="逻辑表达式化简"><a href="#逻辑表达式化简" class="headerlink" title="逻辑表达式化简"></a>逻辑表达式化简</h2><p>在使用逻辑代数表达式描述完之后功能之后还需要对表达式进行化简，化简的表达式所转化得到的电路具有更少的元件，使电路图可以更加直观，同时也可以节省成本。化简的方法有下面两种。</p>
<h3 id="公式法化简-（这个得看熟练程度）"><a href="#公式法化简-（这个得看熟练程度）" class="headerlink" title="公式法化简 （这个得看熟练程度）"></a>公式法化简 （这个得看熟练程度）</h3><p><img src="https://i.imgur.com/jFJklb4.png" alt="逻辑代数公式表"></p>
<h3 id="卡诺图化简方法-（这个要实用一点，但需要列的表比较多）"><a href="#卡诺图化简方法-（这个要实用一点，但需要列的表比较多）" class="headerlink" title="卡诺图化简方法 （这个要实用一点，但需要列的表比较多）"></a>卡诺图化简方法 （这个要实用一点，但需要列的表比较多）</h3><p>将所有的输入变量构成最小项，并将最小项根据格雷码的顺序写成表格，保证相邻的两项只有一个输入变量变化，如由 A, B 构成的最小项包括 AB, A’B, AB’, A’B’，就可以构成下图这种两变量 卡诺图</p>
<table>
<thead>
<tr>
<th align="center">A&#x2F;B</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">m0</td>
<td align="center">m1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">m2</td>
<td align="center">m3</td>
</tr>
</tbody></table>
<p>卡诺图利用 $\bar{A}B + AB &#x3D; (\bar{A} + A)B &#x3D; B$进行化简，在卡诺图中画的圆圈跨过两个格子则说明所跨过的变量可以消去。</p>
<p>卡诺图的化简步骤需要遵循:</p>
<ol>
<li>所有的标1方格都需要被圈覆盖</li>
<li>每个圈中包含的相邻小方格数必须为2的整数次幂</li>
<li>圈需要尽可能大，圈和圈之间可以重叠</li>
<li>每个圈中至少有一个标1的方格未被其他圈所覆盖</li>
</ol>
<p><img src="https://i.imgur.com/poel6EW.png" alt="常见卡诺图化简"></p>
<h2 id="组合逻辑电路设计过程"><a href="#组合逻辑电路设计过程" class="headerlink" title="组合逻辑电路设计过程"></a>组合逻辑电路设计过程</h2><ol>
<li>根据需求确定功能</li>
<li>根据功能列出真值表</li>
<li>根据真值表写出逻辑表达式</li>
<li>将逻辑表达式化简</li>
<li>逻辑表达式转化为逻辑电路图</li>
</ol>
<h2 id="编码器实现"><a href="#编码器实现" class="headerlink" title="编码器实现"></a>编码器实现</h2><p>译码器的作用就是按照输入的类似并行的数据格式转换为BCD码，常用的集成芯片是<strong>74LS148</strong>。它的真值表如下图。$\bar{EI}$的作用是作为输入使能端口，$\bar{GS}$ 是编码器的工作标志位低电平有效，$EO$扩展端口可以用于多个芯片进行互联。</p>
<p><img src="https://i.imgur.com/ApP7YKY.png"></p>
<p>因此可以根据它的真值表写出输出的表达式为（这里写的是最基本的编码器的逻辑代数表达式，跟上图对比需要再取反）<br>$$<br>\begin{array}{I}<br>A_0 &#x3D; I_6 + I_4 + I_2 + I_0  \\<br>A_1 &#x3D; I_5 + I_4 + I_1 + I_0  \\<br>A_2 &#x3D; I_0 + I_1 + I_2 + I_3  \\<br>\end{array}<br>$$</p>
<h2 id="译码器实现"><a href="#译码器实现" class="headerlink" title="译码器实现"></a>译码器实现</h2><p>译码器的作用与编码器相反，作用是将BCD码转换为对应序号的端口输出，这里是常用译码器74138的真值表。七段式数码管显示电路也可以借用这个思想进行设计。</p>
<p><img src="https://i.imgur.com/NXA4DwK.png"></p>
<p>同样是需要写出它的逻辑表达式。<br>$$<br>\begin{array}{l}<br>I_0 &#x3D; \bar{A_2}\bar{A_1}\bar{A_0},I_4 &#x3D; {A_2}\bar{A_1}\bar{A_0}  \\<br>I_1 &#x3D; \bar{A_2}\bar{A_1}{A_5}, I_5 &#x3D; {A_2}\bar{A_1}{A_0}  \\<br>I_2 &#x3D; \bar{A_2}{A_1}\bar{A_0},I_6 &#x3D; {A_2}{A_1}\bar{A_0}  \\<br>I_3 &#x3D; \bar{A_2}{A_1}{A_0},I_7 &#x3D; {A_2}{A_1}{A_0}  \\<br>\end{array}<br>$$</p>
<h2 id="加法器实现"><a href="#加法器实现" class="headerlink" title="加法器实现"></a>加法器实现</h2><p>加法器是现代计算机中最基础的一个运算单元。加法器分为半加器和全加器，<br>半加器不考虑进位，结构比较简单，只能计算一位二进制加法。因为半加器比较简单，所以这里直接给出它的逻辑表达式。<br>半加器逻辑表达式为<br>$$<br>S &#x3D; A \oplus B &#x3D; \bar{A}B + A\bar{B} \\<br>C &#x3D; A \times B<br>$$<br>全加器因为需要考虑到进位信息，所以稍微复杂一些，下面的就是全加器的真值表</p>
<p><img src="https://i.imgur.com/B96VxDf.png"></p>
<p>通过化简可以得出全加器的逻辑表达式为，这里只涉及一个全加器。<br>$$<br>S&#x3D;\bar{A}\bar{B}C + \bar{A}B\bar{C} + A\bar{B}\bar{C}&#x3D;A \oplus B \oplus C \\<br>C&#x3D;AB + BC + AC<br>$$<br>**行波进位加法器(Ripple-Carry Adder，RCA)**，如果要实现多位二进制数进行相加，可以通过将多个全加器进行级联，$c_{n - 1}$和下一个全加器的$c_{n}$相连就可以实现多个位的相加。<br><img src="https://i.imgur.com/FVPfMgX.png"></p>
<p>全加器的位数等于相加数的个数，最低位的 $c_{-1}$应接0，串行进位加法器电路比较简单，当时缺点是第N个全加器的输出必须要等到第N-1个全加器运算完成。</p>
<p>电路的门延迟为，其中T是每个门电路的输出延迟。<br>$$<br>ST &#x3D; (2N + 1)T<br>$$<br>RLA的改进版称为<strong>超前进位加法器（Carry-lookhead Adder CLA）</strong>，具体原理如下。</p>
<p>先对C的表达式进行化简, 其中$G_{i}$称为生成信号，$P_{i}$称为传播信号，$C_{i+1}$可以写为如下形式。<br>$$<br>C_{i+1} &#x3D; A_{i}B_{i} + (A_{i} + B_{i})C_{i} \\<br>G_{i} &#x3D; A_{i}B_{i} \\<br>P_{i} &#x3D; (A_{i} + B_{i}) \\<br>C_{i+1} &#x3D; G_{i} + P_{i}C_{i}<br>$$<br>按照形式，各级门电路的进位表达式可以写为:<br>$$<br>C_1 &#x3D; G_0+P_0C_0 \\<br>C_2 &#x3D; G_1+P_1C_1&#x3D;G_1 + P_1G_0+P_1P_0C_0 \\<br>C_3 &#x3D; G_2+P_2G_1+P_2P_1G_0 + P_2P_1P_0C_0<br>$$<br>规律也挺明显的，$C_{n+1}$ 等于 $C_{n}$ 乘一个 $P_n$ 再加 $G_n$（废话）。</p>
<p>CLA相较与RCA的计算延迟时间固定为三级门延迟，且延迟和加法器的位数无关，但是如果进一步扩宽加法器的位宽，则电路会变得非常复杂。</p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>数字电路基础 - 时序逻辑</title>
    <url>/2022/03/17/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%20-%20%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>学习触发器，边缘触发器的基础知识。</p>
<span id="more"></span>

<p>可以参照<a href="https://zhuanlan.zhihu.com/p/37137899">D触发器的进化之路</a>这篇文章，讲的比较清楚。</p>
<p>《编码》— 触发器可以保持信息，可以记住最近一次是哪个开关先闭合的。</p>
<h2 id="RS触发器"><a href="#RS触发器" class="headerlink" title="RS触发器"></a>RS触发器</h2><p>使用两个或非门或者与非门就可以构成最基本的RS锁存器。</p>
<p><img src="https://i.imgur.com/IegO4Ek.png" alt="image-20220905171451669"></p>
<p>这个电路的状态表如下图：</p>
<table>
<thead>
<tr>
<th>R</th>
<th>S</th>
<th>Q(n+1)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Q(n)</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>不稳，该种情况需要避免出现</td>
</tr>
</tbody></table>
<p>这种电路的缺点是：</p>
<ol>
<li>能控制存储的对象，但是有非法态</li>
<li>整个系统不受控，一直处在工作状态</li>
</ol>
<p>在输入端加入时钟控制功能，RS锁存器就变成了RS触发器。</p>
<p>使用两个或门的输出作为RS触发器的输入，当中间的引脚为1，则自动屏蔽输入，（或门有一个1则输出肯定为1，此时的RS触发器处于保持状态）</p>
<p>中间的引脚可以作为时钟信号的输入，插入时钟控制信号就可以避免刚刚说到的第二个缺点。</p>
<p>PS: 在上面那个或门的输出那里再插入一个或门，引出一个额外的输出端口作为清零端口。</p>
<p><img src="https://i.imgur.com/u1IKpYx.png" alt="image-20220905172111938"></p>
<h2 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h2><p>由于RS触发器拥有两个输入端口（R&#x2F;S）,为了避免这种情况，直接使用一个非门保证RS触发器的输入肯定是合法的。</p>
<p><img src="https://i.imgur.com/nyTr6tW.png" alt="image-20220905172334939"></p>
<p>将上面的电路进行封装，就变成了常见的电平触发的D触发器也称为DFF（D Filp-Flop）。在时钟信号为低电平时可以通过控制端口D改变保存的值，时钟信号为高电平时则进入所存状态。</p>
<p><img src="https://i.imgur.com/KByH2hI.png" alt="image-20220905172527859"></p>
<p>将两个DFF串联，时钟信号通过一个非门相连，就构成了电平触发的D触发器。</p>
<p><img src="https://i.imgur.com/TeOfiZb.png" alt="image-20220905172946640"></p>
<p>第一个传输数据的时候，第二个D触发器保持</p>
<p>第二个传输数据的时候，第一个触发器保持，</p>
<p>最后的结果就是，只在边沿触发的那一刻传输数据！</p>
<h2 id="分频器"><a href="#分频器" class="headerlink" title="分频器"></a>分频器</h2><p>将DFF的$\bar{Q}$接到D，就可以实现对CLK 的分频</p>
<p><img src="https://i.imgur.com/3VYjvTl.png" alt="image-20220905173033502"></p>
<p>输出的模型如下，可以看到Q的输出频率为输入Clk 的 $\frac{1}{2}$。</p>
<p><img src="https://i.imgur.com/HaiHLSm.png" alt="image-20220905173038458"></p>
<h2 id="倍频器"><a href="#倍频器" class="headerlink" title="倍频器"></a>倍频器</h2><p>DFF和与非门配合就可以实现2倍频电路。</p>
<p><img src="https://i.imgur.com/WJxs2eK.png" alt="Clock Doubler Circuit using Delay Chains"></p>
<h2 id="行波计数器"><a href="#行波计数器" class="headerlink" title="行波计数器"></a>行波计数器</h2><p>通过将DFF进行串联, 除了组成分频器外，因为串联一个DFF输出的频率就是原来频率的 1&#x2F;2。不同分频器当前的输出作为一个二进制数的数的一位，这个二进制数就代表了CLK 脉冲产生的个数</p>
<p><img src="https://i.imgur.com/NpGEXZV.png" alt="image-20220905174734191"></p>
<p>该电路的波形如下，将波形所代表的电平转化为十进制数就得到了Clk时钟的脉冲计数。</p>
<p><img src="https://i.imgur.com/DthnfeP.png" alt="image-20220905174744692"></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数运算</title>
    <url>/2022/08/25/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>浮点数在内存中的表达</p>
<span id="more"></span>

<h2 id="浮点数的表示（IEEE754）"><a href="#浮点数的表示（IEEE754）" class="headerlink" title="浮点数的表示（IEEE754）"></a>浮点数的表示（IEEE754）</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p> 浮点数在内存中分为3个部分进行表示：</p>
<ul>
<li>Sign (符号位)</li>
<li>Exponents (指数部分)</li>
<li>Matissa (尾数部分)</li>
</ul>
<p>其中符号位固定占1个bit，指数部分和尾数部分根据不同的数据类型所占用的大小也不相同，具体情况见下面的表</p>
<table>
<thead>
<tr>
<th align="center">num total bits</th>
<th align="center">precision</th>
<th align="center">exponent bits</th>
<th align="center">mantissa bits</th>
<th align="center">bias</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64 bits</td>
<td align="center">double</td>
<td align="center">11</td>
<td align="center">52</td>
<td align="center">1023</td>
</tr>
<tr>
<td align="center">32 bits</td>
<td align="center">single</td>
<td align="center">8</td>
<td align="center">23</td>
<td align="center">127</td>
</tr>
<tr>
<td align="center">16 bits</td>
<td align="center">half</td>
<td align="center">5</td>
<td align="center">10</td>
<td align="center">15</td>
</tr>
</tbody></table>
<p><img src="https://i.imgur.com/5cE5pYl.png" alt="image-20220825132831256"></p>
<h3 id="表示规则"><a href="#表示规则" class="headerlink" title="表示规则"></a>表示规则</h3><p>浮点数规定了三种表示类型：规格化数、非规格化数、特殊值。</p>
<p>规格化数就是比较常用的在计算机中表示小数的方式，其转化为</p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Float</tag>
      </tags>
  </entry>
  <entry>
    <title>论文写作结构总结</title>
    <url>/2022/07/29/%E8%AE%BA%E6%96%87%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>总结写论文时候各个部分所对应的一些结构，感谢汤老师的耐心教学😊。</p>
<span id="more"></span>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>一般写6-7句话，但是要根据所投会议或者出版社的具体要求，有一些会议还会有单词数量的限制。</p>
<ol>
<li>第1句：描述当前研究工作的意义，或者所研究问题的定义。</li>
<li>第2句：引出问题，结合自己所提出的方法描述当前方法的缺点</li>
<li>第3句：针对所提出的问题，我们提出了……的方法（<strong>方法的总结</strong>），结合当前领域所采用的一般步骤，详细概括一下方法<ol>
<li>First, ….</li>
<li>Second,…..</li>
<li>Third,….</li>
</ol>
</li>
<li>实验证明了（所提出的方法）是有效的</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>一般分为4-5段。</p>
<ol>
<li>第一段：详细描述一下，该领域研究的意义</li>
<li>第2-3段：总结当前所采用的一些方法以及他们存在的一些问题，和Related Works 的区别在于，这里一般讲的相对粗略一点，主要概述一些经典的方法或者第一个提出这个问题的文章。</li>
<li>第4段：讲述一下Motivation</li>
<li>第5段：详细描述一下 所做出的 Contribution（<strong>最好跟摘要的描述一一对应</strong>）</li>
</ol>
<h2 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h2><p>一般可根据需要分为 3-5段，主要介绍一下当前领域中采用的一些比较新的研究内容跟以及它们所属的类别，<strong>按照类别分段进行阐述</strong>。</p>
<p>在叙述的时候最好根据领域发展的脉络，<strong>描述一下领域发展的过程</strong></p>
<p><strong>对于后面实验所对比的方法在这里可以相对详细地介绍一下</strong></p>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>这部分没有什么限制，但需要注意一些点：</p>
<ul>
<li>公式尽量采用通用的符号</li>
<li>当论述中需要使用的公式符号比较多的时候可以单独开出<code>Prelimition</code>小节介绍相关的符号定义</li>
<li>在公式后面需要跟标点符号以及公式编号</li>
<li>如果可以，尽量画一个图进行描述</li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>这部分也没什么限制，需要包括以下部分：</p>
<ul>
<li>所采用的数据集的介绍</li>
<li>评价指标介绍（需要简要介绍一下，如果有公式可以放公式）</li>
<li>简单介绍一些实验采用的一些网络</li>
<li>实验的环境（可选）</li>
<li>Implement Detail. 可以适当放一下超参体现以下真实性</li>
<li>实验结果（实验的对比）</li>
<li>对于实验结果的描述（可以写一些图表中已经比较清楚的废话）</li>
<li>实验总结（实验证明了所提出的方法是有效的）</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>再次按照以下顺序重复说明一下文章的工作：</p>
<ol>
<li>摘要（缩减后）</li>
<li>所做出的贡献</li>
<li>采用的方法</li>
</ol>
<p>最后一句写一下<strong>Future Works</strong>。</p>
<h2 id="写作中常用的网站-持续更新"><a href="#写作中常用的网站-持续更新" class="headerlink" title="写作中常用的网站(持续更新)"></a>写作中常用的网站(持续更新)</h2><table>
<thead>
<tr>
<th>名称</th>
<th>网址</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Overleaf</td>
<td><a href="https://www.overleaf.com/">https://www.overleaf.com</a></td>
<td>在线的Latex编辑器，可以多人协作</td>
</tr>
<tr>
<td>Latex 表格生成</td>
<td><a href="https://www.tablesgenerator.com/">https://www.tablesgenerator.com/</a></td>
<td>生成Latex 表格</td>
</tr>
<tr>
<td>火龙果写作</td>
<td><a href="https://www.mypitaya.com/">https://www.mypitaya.com/</a></td>
<td>英文润色，语法检查</td>
</tr>
<tr>
<td>秘塔写作猫</td>
<td><a href="https://xiezuocat.com/">https://xiezuocat.com/</a></td>
<td>英文润色，语法检查</td>
</tr>
<tr>
<td>writefull</td>
<td><a href="https://www.writefull.com/">https://www.writefull.com/</a></td>
<td>学术写作润色</td>
</tr>
<tr>
<td>dblp</td>
<td><a href="https://dblp.uni-trier.de/">https://dblp.uni-trier.de/</a></td>
<td>导出参考文献的 bibtex 格</td>
</tr>
<tr>
<td>hemingway</td>
<td><a href="https://hemingwayapp.com/">https://hemingwayapp.com/</a></td>
<td>检测英语流利程度</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Paper</tag>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>贴片元件焊接方法</title>
    <url>/2022/05/07/%E8%B4%B4%E7%89%87%E5%85%83%E4%BB%B6%E7%9A%84%E7%84%8A%E6%8E%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>贴片元件的焊接方法</p>
<p>虽然之前接触焊接的很多，但一直都没有认真的学习和练习，焊接是一个常见技能，需要多加练习来熟练掌握。</p>
<span id="more"></span>

<p>注意事项：</p>
<ol>
<li>烙铁温度保持在350 度。</li>
</ol>
<h2 id="直插原件焊接"><a href="#直插原件焊接" class="headerlink" title="直插原件焊接"></a>直插原件焊接</h2><ol>
<li>烙铁头贴近焊盘和原件，同时为两者加热</li>
<li>将锡丝贴近烙铁头，通过浸润作用使液态锡均匀分到焊盘上，将原件接脚包裹</li>
<li>焊点形成圆锥侧面形状与PCB 形成 45 度夹角最佳</li>
</ol>
<p>注意事项：</p>
<ul>
<li>减少焊接持续时间避免长时间的加热损坏原件</li>
<li>焊接完一个焊点之后，锡丝先离开后，焊头再离开</li>
</ul>
<h2 id="贴片原件焊接"><a href="#贴片原件焊接" class="headerlink" title="贴片原件焊接"></a>贴片原件焊接</h2><ul>
<li>准备一个镊子</li>
<li>准备一个刀头焊头</li>
</ul>
<h3 id="电容电阻焊接方法"><a href="#电容电阻焊接方法" class="headerlink" title="电容电阻焊接方法"></a>电容电阻焊接方法</h3><ol>
<li>先给一边上锡，要注意锡量，保证锡面光滑圆润</li>
<li>使用镊子夹起电阻&#x2F;电容，使其紧贴PCB 表面</li>
<li>使用焊头融化刚刚上锡 的一侧，等待融化并将电容电阻的一头包裹</li>
<li>移开焊头，等待锡凝固，固定电容电阻</li>
<li>PCB 旋转 180度完成另外一面的焊接</li>
</ol>
<p>注意事项</p>
<ul>
<li>保证锡表面与PCB 和原件之间的夹角为45度角最佳</li>
<li>如果锡量太多，使用烙铁头轻轻抹一下焊点，就合适了</li>
</ul>
<h3 id="贴片-IC-焊接方法"><a href="#贴片-IC-焊接方法" class="headerlink" title="贴片 IC 焊接方法"></a>贴片 IC 焊接方法</h3><ol>
<li>先给2-3个 焊盘上锡</li>
<li>使用镊子夹取芯片靠近上锡的焊盘</li>
<li>使用焊头将锡重新融化后固定芯片</li>
<li>将IC 的一边管脚全部上锡，只需要关注新派你管脚和焊盘之间是否已经连上锡，不用关心管脚之间是否粘连</li>
<li>将焊头使用拖焊将管脚上的锡脱出，保证管脚和管脚之间没有锡的存在</li>
</ol>
<p>注意事项 </p>
<ul>
<li>注意芯片的焊接方向和PCB 的丝印方向对应</li>
<li>使用左手拿镊子右手拿焊笔，需要做到左手拿镊子的稳定与精准需要长时间的练习</li>
</ul>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>焊接方法</tag>
      </tags>
  </entry>
</search>
